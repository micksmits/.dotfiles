#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));

// ../../node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../../node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      aliceblue: [
        240,
        248,
        255
      ],
      antiquewhite: [
        250,
        235,
        215
      ],
      aqua: [
        0,
        255,
        255
      ],
      aquamarine: [
        127,
        255,
        212
      ],
      azure: [
        240,
        255,
        255
      ],
      beige: [
        245,
        245,
        220
      ],
      bisque: [
        255,
        228,
        196
      ],
      black: [
        0,
        0,
        0
      ],
      blanchedalmond: [
        255,
        235,
        205
      ],
      blue: [
        0,
        0,
        255
      ],
      blueviolet: [
        138,
        43,
        226
      ],
      brown: [
        165,
        42,
        42
      ],
      burlywood: [
        222,
        184,
        135
      ],
      cadetblue: [
        95,
        158,
        160
      ],
      chartreuse: [
        127,
        255,
        0
      ],
      chocolate: [
        210,
        105,
        30
      ],
      coral: [
        255,
        127,
        80
      ],
      cornflowerblue: [
        100,
        149,
        237
      ],
      cornsilk: [
        255,
        248,
        220
      ],
      crimson: [
        220,
        20,
        60
      ],
      cyan: [
        0,
        255,
        255
      ],
      darkblue: [
        0,
        0,
        139
      ],
      darkcyan: [
        0,
        139,
        139
      ],
      darkgoldenrod: [
        184,
        134,
        11
      ],
      darkgray: [
        169,
        169,
        169
      ],
      darkgreen: [
        0,
        100,
        0
      ],
      darkgrey: [
        169,
        169,
        169
      ],
      darkkhaki: [
        189,
        183,
        107
      ],
      darkmagenta: [
        139,
        0,
        139
      ],
      darkolivegreen: [
        85,
        107,
        47
      ],
      darkorange: [
        255,
        140,
        0
      ],
      darkorchid: [
        153,
        50,
        204
      ],
      darkred: [
        139,
        0,
        0
      ],
      darksalmon: [
        233,
        150,
        122
      ],
      darkseagreen: [
        143,
        188,
        143
      ],
      darkslateblue: [
        72,
        61,
        139
      ],
      darkslategray: [
        47,
        79,
        79
      ],
      darkslategrey: [
        47,
        79,
        79
      ],
      darkturquoise: [
        0,
        206,
        209
      ],
      darkviolet: [
        148,
        0,
        211
      ],
      deeppink: [
        255,
        20,
        147
      ],
      deepskyblue: [
        0,
        191,
        255
      ],
      dimgray: [
        105,
        105,
        105
      ],
      dimgrey: [
        105,
        105,
        105
      ],
      dodgerblue: [
        30,
        144,
        255
      ],
      firebrick: [
        178,
        34,
        34
      ],
      floralwhite: [
        255,
        250,
        240
      ],
      forestgreen: [
        34,
        139,
        34
      ],
      fuchsia: [
        255,
        0,
        255
      ],
      gainsboro: [
        220,
        220,
        220
      ],
      ghostwhite: [
        248,
        248,
        255
      ],
      gold: [
        255,
        215,
        0
      ],
      goldenrod: [
        218,
        165,
        32
      ],
      gray: [
        128,
        128,
        128
      ],
      green: [
        0,
        128,
        0
      ],
      greenyellow: [
        173,
        255,
        47
      ],
      grey: [
        128,
        128,
        128
      ],
      honeydew: [
        240,
        255,
        240
      ],
      hotpink: [
        255,
        105,
        180
      ],
      indianred: [
        205,
        92,
        92
      ],
      indigo: [
        75,
        0,
        130
      ],
      ivory: [
        255,
        255,
        240
      ],
      khaki: [
        240,
        230,
        140
      ],
      lavender: [
        230,
        230,
        250
      ],
      lavenderblush: [
        255,
        240,
        245
      ],
      lawngreen: [
        124,
        252,
        0
      ],
      lemonchiffon: [
        255,
        250,
        205
      ],
      lightblue: [
        173,
        216,
        230
      ],
      lightcoral: [
        240,
        128,
        128
      ],
      lightcyan: [
        224,
        255,
        255
      ],
      lightgoldenrodyellow: [
        250,
        250,
        210
      ],
      lightgray: [
        211,
        211,
        211
      ],
      lightgreen: [
        144,
        238,
        144
      ],
      lightgrey: [
        211,
        211,
        211
      ],
      lightpink: [
        255,
        182,
        193
      ],
      lightsalmon: [
        255,
        160,
        122
      ],
      lightseagreen: [
        32,
        178,
        170
      ],
      lightskyblue: [
        135,
        206,
        250
      ],
      lightslategray: [
        119,
        136,
        153
      ],
      lightslategrey: [
        119,
        136,
        153
      ],
      lightsteelblue: [
        176,
        196,
        222
      ],
      lightyellow: [
        255,
        255,
        224
      ],
      lime: [
        0,
        255,
        0
      ],
      limegreen: [
        50,
        205,
        50
      ],
      linen: [
        250,
        240,
        230
      ],
      magenta: [
        255,
        0,
        255
      ],
      maroon: [
        128,
        0,
        0
      ],
      mediumaquamarine: [
        102,
        205,
        170
      ],
      mediumblue: [
        0,
        0,
        205
      ],
      mediumorchid: [
        186,
        85,
        211
      ],
      mediumpurple: [
        147,
        112,
        219
      ],
      mediumseagreen: [
        60,
        179,
        113
      ],
      mediumslateblue: [
        123,
        104,
        238
      ],
      mediumspringgreen: [
        0,
        250,
        154
      ],
      mediumturquoise: [
        72,
        209,
        204
      ],
      mediumvioletred: [
        199,
        21,
        133
      ],
      midnightblue: [
        25,
        25,
        112
      ],
      mintcream: [
        245,
        255,
        250
      ],
      mistyrose: [
        255,
        228,
        225
      ],
      moccasin: [
        255,
        228,
        181
      ],
      navajowhite: [
        255,
        222,
        173
      ],
      navy: [
        0,
        0,
        128
      ],
      oldlace: [
        253,
        245,
        230
      ],
      olive: [
        128,
        128,
        0
      ],
      olivedrab: [
        107,
        142,
        35
      ],
      orange: [
        255,
        165,
        0
      ],
      orangered: [
        255,
        69,
        0
      ],
      orchid: [
        218,
        112,
        214
      ],
      palegoldenrod: [
        238,
        232,
        170
      ],
      palegreen: [
        152,
        251,
        152
      ],
      paleturquoise: [
        175,
        238,
        238
      ],
      palevioletred: [
        219,
        112,
        147
      ],
      papayawhip: [
        255,
        239,
        213
      ],
      peachpuff: [
        255,
        218,
        185
      ],
      peru: [
        205,
        133,
        63
      ],
      pink: [
        255,
        192,
        203
      ],
      plum: [
        221,
        160,
        221
      ],
      powderblue: [
        176,
        224,
        230
      ],
      purple: [
        128,
        0,
        128
      ],
      rebeccapurple: [
        102,
        51,
        153
      ],
      red: [
        255,
        0,
        0
      ],
      rosybrown: [
        188,
        143,
        143
      ],
      royalblue: [
        65,
        105,
        225
      ],
      saddlebrown: [
        139,
        69,
        19
      ],
      salmon: [
        250,
        128,
        114
      ],
      sandybrown: [
        244,
        164,
        96
      ],
      seagreen: [
        46,
        139,
        87
      ],
      seashell: [
        255,
        245,
        238
      ],
      sienna: [
        160,
        82,
        45
      ],
      silver: [
        192,
        192,
        192
      ],
      skyblue: [
        135,
        206,
        235
      ],
      slateblue: [
        106,
        90,
        205
      ],
      slategray: [
        112,
        128,
        144
      ],
      slategrey: [
        112,
        128,
        144
      ],
      snow: [
        255,
        250,
        250
      ],
      springgreen: [
        0,
        255,
        127
      ],
      steelblue: [
        70,
        130,
        180
      ],
      tan: [
        210,
        180,
        140
      ],
      teal: [
        0,
        128,
        128
      ],
      thistle: [
        216,
        191,
        216
      ],
      tomato: [
        255,
        99,
        71
      ],
      turquoise: [
        64,
        224,
        208
      ],
      violet: [
        238,
        130,
        238
      ],
      wheat: [
        245,
        222,
        179
      ],
      white: [
        255,
        255,
        255
      ],
      whitesmoke: [
        245,
        245,
        245
      ],
      yellow: [
        255,
        255,
        0
      ],
      yellowgreen: [
        154,
        205,
        50
      ]
    };
  }
});

// ../../node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "../../node_modules/color-convert/conversions.js"(exports2, module2) {
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var cssKeywords = require_color_name(), reverseKeywords = {}, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
    try {
      for (_iterator = Object.keys(cssKeywords)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0)
        key = _step.value, reverseKeywords[cssKeywords[key]] = key;
    } catch (err) {
      _didIteratorError2 = !0, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError2)
          throw _iteratorError2;
      }
    }
    var key, _iterator, _step, convert = {
      rgb: {
        channels: 3,
        labels: "rgb"
      },
      hsl: {
        channels: 3,
        labels: "hsl"
      },
      hsv: {
        channels: 3,
        labels: "hsv"
      },
      hwb: {
        channels: 3,
        labels: "hwb"
      },
      cmyk: {
        channels: 4,
        labels: "cmyk"
      },
      xyz: {
        channels: 3,
        labels: "xyz"
      },
      lab: {
        channels: 3,
        labels: "lab"
      },
      lch: {
        channels: 3,
        labels: "lch"
      },
      hex: {
        channels: 1,
        labels: [
          "hex"
        ]
      },
      keyword: {
        channels: 1,
        labels: [
          "keyword"
        ]
      },
      ansi16: {
        channels: 1,
        labels: [
          "ansi16"
        ]
      },
      ansi256: {
        channels: 1,
        labels: [
          "ansi256"
        ]
      },
      hcg: {
        channels: 3,
        labels: [
          "h",
          "c",
          "g"
        ]
      },
      apple: {
        channels: 3,
        labels: [
          "r16",
          "g16",
          "b16"
        ]
      },
      gray: {
        channels: 1,
        labels: [
          "gray"
        ]
      }
    };
    module2.exports = convert;
    var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
    try {
      for (_iterator1 = Object.keys(convert)[Symbol.iterator](); !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
        if (model = _step1.value, !("channels" in convert[model]))
          throw new Error("missing channels property: " + model);
        if (!("labels" in convert[model]))
          throw new Error("missing channel labels property: " + model);
        if (convert[model].labels.length !== convert[model].channels)
          throw new Error("channel and label counts mismatch: " + model);
        _convert_model = convert[model], channels = _convert_model.channels, labels = _convert_model.labels, delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", {
          value: channels
        }), Object.defineProperty(convert[model], "labels", {
          value: labels
        });
      }
    } catch (err) {
      _didIteratorError12 = !0, _iteratorError12 = err;
    } finally {
      try {
        !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
      } finally {
        if (_didIteratorError12)
          throw _iteratorError12;
      }
    }
    var model, _convert_model, channels, labels, _iterator1, _step1;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s;
      max === min ? h = 0 : r === max ? h = (g - b) / delta : g === max ? h = 2 + (b - r) / delta : b === max && (h = 4 + (r - g) / delta), h = Math.min(h * 60, 360), h < 0 && (h += 360);
      var l = (min + max) / 2;
      return max === min ? s = 0 : l <= 0.5 ? s = delta / (max + min) : s = delta / (2 - max - min), [
        h,
        s * 100,
        l * 100
      ];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif, gdif, bdif, h, s, r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, v = Math.max(r, g, b), diff = v - Math.min(r, g, b), diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      return diff === 0 ? (h = 0, s = 0) : (s = diff / v, rdif = diffc(r), gdif = diffc(g), bdif = diffc(b), r === v ? h = bdif - gdif : g === v ? h = 1 / 3 + rdif - bdif : b === v && (h = 2 / 3 + gdif - rdif), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0], g = rgb[1], b = rgb[2], h = convert.rgb.hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b));
      return b = 1 - 1 / 255 * Math.max(r, Math.max(g, b)), [
        h,
        w * 100,
        b * 100
      ];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, k = Math.min(1 - r, 1 - g, 1 - b), c = (1 - r - k) / (1 - k) || 0, m = (1 - g - k) / (1 - k) || 0, y = (1 - b - k) / (1 - k) || 0;
      return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
      ];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed)
        return reversed;
      var currentClosestDistance = 1 / 0, currentClosestKeyword, _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
      try {
        for (var _iterator2 = Object.keys(cssKeywords)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion3 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion3 = !0) {
          var keyword = _step2.value, value = cssKeywords[keyword], distance = comparativeDistance(rgb, value);
          distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
        }
      } catch (err) {
        _didIteratorError3 = !0, _iteratorError3 = err;
      } finally {
        try {
          !_iteratorNormalCompletion3 && _iterator2.return != null && _iterator2.return();
        } finally {
          if (_didIteratorError3)
            throw _iteratorError3;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92, b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805, y = r * 0.2126 + g * 0.7152 + b * 0.0722, z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [
        x * 100,
        y * 100,
        z * 100
      ];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb), x = xyz[0], y = xyz[1], z = xyz[2];
      x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      var l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z);
      return [
        l,
        a,
        b
      ];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t2, t3, val;
      if (s === 0)
        return val = l * 255, [
          val,
          val,
          val
        ];
      l < 0.5 ? t2 = l * (1 + s) : t2 = l + s - l * s;
      for (var t1 = 2 * l - t2, rgb = [
        0,
        0,
        0
      ], i = 0; i < 3; i++)
        t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb[i] = val * 255;
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, smin = s, lmin = Math.max(l, 0.01);
      l *= 2, s *= l <= 1 ? l : 2 - l, smin *= lmin <= 1 ? lmin : 2 - lmin;
      var v = (l + s) / 2, sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [
        h,
        sv * 100,
        v * 100
      ];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60, s = hsv[1] / 100, v = hsv[2] / 100, hi = Math.floor(h) % 6, f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f));
      switch (v *= 255, hi) {
        case 0:
          return [
            v,
            t,
            p
          ];
        case 1:
          return [
            q,
            v,
            p
          ];
        case 2:
          return [
            p,
            v,
            t
          ];
        case 3:
          return [
            p,
            q,
            v
          ];
        case 4:
          return [
            t,
            p,
            v
          ];
        case 5:
          return [
            v,
            p,
            q
          ];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, vmin = Math.max(v, 0.01), sl, l;
      l = (2 - s) * v;
      var lmin = (2 - s) * vmin;
      return sl = s * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l /= 2, [
        h,
        sl * 100,
        l * 100
      ];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, f;
      ratio > 1 && (wh /= ratio, bl /= ratio);
      var i = Math.floor(6 * h), v = 1 - bl;
      f = 6 * h - i, i & 1 && (f = 1 - f);
      var n = wh + f * (v - wh), r, g, b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v, g = n, b = wh;
          break;
        case 1:
          r = n, g = v, b = wh;
          break;
        case 2:
          r = wh, g = v, b = n;
          break;
        case 3:
          r = wh, g = n, b = v;
          break;
        case 4:
          r = n, g = wh, b = v;
          break;
        case 5:
          r = v, g = wh, b = n;
          break;
      }
      return [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100, r = 1 - Math.min(1, c * (1 - k) + k), g = 1 - Math.min(1, m * (1 - k) + k), b = 1 - Math.min(1, y * (1 - k) + k);
      return [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100, r, g, b;
      return r = x * 3.2406 + y * -1.5372 + z * -0.4986, g = x * -0.9689 + y * 1.8758 + z * 0.0415, b = x * 0.0557 + y * -0.204 + z * 1.057, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92, g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92, b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92, r = Math.min(Math.max(0, r), 1), g = Math.min(Math.max(0, g), 1), b = Math.min(Math.max(0, b), 1), [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0], y = xyz[1], z = xyz[2];
      x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      var l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z);
      return [
        l,
        a,
        b
      ];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], x, y, z;
      y = (l + 16) / 116, x = a / 500 + y, z = y - b / 200;
      var y2 = Math.pow(y, 3), x2 = Math.pow(x, 3), z2 = Math.pow(z, 3);
      return y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787, x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787, z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787, x *= 95.047, y *= 100, z *= 108.883, [
        x,
        y,
        z
      ];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], h, hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI, h < 0 && (h += 360);
      var c = Math.sqrt(a * a + b * b);
      return [
        l,
        c,
        h
      ];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0], c = lch[1], h = lch[2], hr = h / 360 * 2 * Math.PI, a = c * Math.cos(hr), b = c * Math.sin(hr);
      return [
        l,
        a,
        b
      ];
    };
    convert.rgb.ansi16 = function(args) {
      var saturation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _args = _sliced_to_array15(args, 3), r = _args[0], g = _args[1], b = _args[2], value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      if (value = Math.round(value / 50), value === 0)
        return 30;
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      return value === 2 && (ansi += 60), ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0], g = args[1], b = args[2];
      if (r === g && g === b)
        return r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232;
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7)
        return args > 50 && (color += 3.5), color = color / 10.5 * 255, [
          color,
          color,
          color
        ];
      var mult = (~~(args > 50) + 1) * 0.5, r = (color & 1) * mult * 255, g = (color >> 1 & 1) * mult * 255, b = (color >> 2 & 1) * mult * 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [
          c,
          c,
          c
        ];
      }
      args -= 16;
      var rem, r = Math.floor(args / 36) / 5 * 255, g = Math.floor((rem = args % 36) / 6) / 5 * 255, b = rem % 6 / 5 * 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255), string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2)
        return [
          0,
          0,
          0
        ];
      var colorString = match2[0];
      match2[0].length === 3 && (colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join(""));
      var integer = parseInt(colorString, 16), r = integer >> 16 & 255, g = integer >> 8 & 255, b = integer & 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, max = Math.max(Math.max(r, g), b), min = Math.min(Math.min(r, g), b), chroma = max - min, grayscale, hue;
      return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r ? hue = (g - b) / chroma % 6 : max === g ? hue = 2 + (b - r) / chroma : hue = 4 + (r - g) / chroma, hue /= 6, hue %= 1, [
        hue * 360,
        chroma * 100,
        grayscale * 100
      ];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100, l = hsl[2] / 100, c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l), f = 0;
      return c < 1 && (f = (l - 0.5 * c) / (1 - c)), [
        hsl[0],
        c * 100,
        f * 100
      ];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100, v = hsv[2] / 100, c = s * v, f = 0;
      return c < 1 && (f = (v - c) / (1 - c)), [
        hsv[0],
        c * 100,
        f * 100
      ];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360, c = hcg[1] / 100, g = hcg[2] / 100;
      if (c === 0)
        return [
          g * 255,
          g * 255,
          g * 255
        ];
      var pure = [
        0,
        0,
        0
      ], hi = h % 1 * 6, v = hi % 1, w = 1 - v, mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1, pure[1] = v, pure[2] = 0;
          break;
        case 1:
          pure[0] = w, pure[1] = 1, pure[2] = 0;
          break;
        case 2:
          pure[0] = 0, pure[1] = 1, pure[2] = v;
          break;
        case 3:
          pure[0] = 0, pure[1] = w, pure[2] = 1;
          break;
        case 4:
          pure[0] = v, pure[1] = 0, pure[2] = 1;
          break;
        default:
          pure[0] = 1, pure[1] = 0, pure[2] = w;
      }
      return mg = (1 - c) * g, [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c), f = 0;
      return v > 0 && (f = c / v), [
        hcg[0],
        f * 100,
        v * 100
      ];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, l = g * (1 - c) + 0.5 * c, s = 0;
      return l > 0 && l < 0.5 ? s = c / (2 * l) : l >= 0.5 && l < 1 && (s = c / (2 * (1 - l))), [
        hcg[0],
        s * 100,
        l * 100
      ];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c);
      return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
      ];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100, b = hwb[2] / 100, v = 1 - b, c = v - w, g = 0;
      return c < 1 && (g = (v - c) / (1 - c)), [
        hwb[0],
        c * 100,
        g * 100
      ];
    };
    convert.apple.rgb = function(apple) {
      return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
      ];
    };
    convert.rgb.apple = function(rgb) {
      return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
      ];
    };
    convert.gray.rgb = function(args) {
      return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
      ];
    };
    convert.gray.hsl = function(args) {
      return [
        0,
        0,
        args[0]
      ];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [
        0,
        100,
        gray[0]
      ];
    };
    convert.gray.cmyk = function(gray) {
      return [
        0,
        0,
        0,
        gray[0]
      ];
    };
    convert.gray.lab = function(gray) {
      return [
        gray[0],
        0,
        0
      ];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255, integer = (val << 16) + (val << 8) + val, string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [
        val / 255 * 100
      ];
    };
  }
});

// ../../node_modules/color-convert/route.js
var require_route = __commonJS({
  "../../node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      for (var graph = {}, models = Object.keys(conversions), len = models.length, i = 0; i < len; i++)
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph(), queue = [
        fromModel
      ];
      for (graph[fromModel].distance = 0; queue.length; )
        for (var current = queue.pop(), adjacents = Object.keys(conversions[current]), len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i], node = graph[adjacent];
          node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
        }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      for (var path6 = [
        graph[toModel].parent,
        toModel
      ], fn = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent; graph[cur].parent; )
        path6.unshift(graph[cur].parent), fn = link(conversions[graph[cur].parent][cur], fn), cur = graph[cur].parent;
      return fn.conversion = path6, fn;
    }
    module2.exports = function(fromModel) {
      for (var graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph), len = models.length, i = 0; i < len; i++) {
        var toModel = models[i], node = graph[toModel];
        node.parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
      }
      return conversion;
    };
  }
});

// ../../node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "../../node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions(), route = require_route(), convert = {}, models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        var arg0 = args[0];
        return arg0 == null ? arg0 : (arg0.length > 1 && (args = arg0), fn(args));
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        var arg0 = args[0];
        if (arg0 == null)
          return arg0;
        arg0.length > 1 && (args = arg0);
        var result = fn(args);
        if (typeof result == "object")
          for (var len = result.length, i = 0; i < len; i++)
            result[i] = Math.round(result[i]);
        return result;
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", {
        value: conversions[fromModel].channels
      }), Object.defineProperty(convert[fromModel], "labels", {
        value: conversions[fromModel].labels
      });
      var routes = route(fromModel), routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn), convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../../node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var wrapAnsi162 = function(fn, offset) {
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        var code = fn.apply(void 0, _to_consumable_array16(args));
        return "\x1B[".concat(code + offset, "m");
      };
    }, wrapAnsi2562 = function(fn, offset) {
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        var code = fn.apply(void 0, _to_consumable_array16(args));
        return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
      };
    }, wrapAnsi16m2 = function(fn, offset) {
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        var rgb = fn.apply(void 0, _to_consumable_array16(args));
        return "\x1B[".concat(38 + offset, ";2;").concat(rgb[0], ";").concat(rgb[1], ";").concat(rgb[2], "m");
      };
    }, ansi2ansi = function(n) {
      return n;
    }, rgb2rgb = function(r, g, b) {
      return [
        r,
        g,
        b
      ];
    }, setLazyProperty = function(object, property, get4) {
      Object.defineProperty(object, property, {
        get: function() {
          var value = get4();
          return Object.defineProperty(object, property, {
            value,
            enumerable: !0,
            configurable: !0
          }), value;
        },
        enumerable: !0,
        configurable: !0
      });
    }, colorConvert, makeDynamicStyles = function(wrap2, targetSpace, identity, isBackground) {
      colorConvert === void 0 && (colorConvert = require_color_convert());
      var offset = isBackground ? 10 : 0, styles3 = {}, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = Object.entries(colorConvert)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _step_value = _sliced_to_array15(_step.value, 2), sourceSpace = _step_value[0], suite = _step_value[1], name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          sourceSpace === targetSpace ? styles3[name] = wrap2(identity, offset) : typeof suite == "object" && (styles3[name] = wrap2(suite[targetSpace], offset));
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return styles3;
    };
    function assembleStyles2() {
      var codes2 = /* @__PURE__ */ new Map(), styles3 = {
        modifier: {
          reset: [
            0,
            0
          ],
          // 21 isn't widely supported and 22 does the same thing
          bold: [
            1,
            22
          ],
          dim: [
            2,
            22
          ],
          italic: [
            3,
            23
          ],
          underline: [
            4,
            24
          ],
          inverse: [
            7,
            27
          ],
          hidden: [
            8,
            28
          ],
          strikethrough: [
            9,
            29
          ]
        },
        color: {
          black: [
            30,
            39
          ],
          red: [
            31,
            39
          ],
          green: [
            32,
            39
          ],
          yellow: [
            33,
            39
          ],
          blue: [
            34,
            39
          ],
          magenta: [
            35,
            39
          ],
          cyan: [
            36,
            39
          ],
          white: [
            37,
            39
          ],
          // Bright color
          blackBright: [
            90,
            39
          ],
          redBright: [
            91,
            39
          ],
          greenBright: [
            92,
            39
          ],
          yellowBright: [
            93,
            39
          ],
          blueBright: [
            94,
            39
          ],
          magentaBright: [
            95,
            39
          ],
          cyanBright: [
            96,
            39
          ],
          whiteBright: [
            97,
            39
          ]
        },
        bgColor: {
          bgBlack: [
            40,
            49
          ],
          bgRed: [
            41,
            49
          ],
          bgGreen: [
            42,
            49
          ],
          bgYellow: [
            43,
            49
          ],
          bgBlue: [
            44,
            49
          ],
          bgMagenta: [
            45,
            49
          ],
          bgCyan: [
            46,
            49
          ],
          bgWhite: [
            47,
            49
          ],
          // Bright color
          bgBlackBright: [
            100,
            49
          ],
          bgRedBright: [
            101,
            49
          ],
          bgGreenBright: [
            102,
            49
          ],
          bgYellowBright: [
            103,
            49
          ],
          bgBlueBright: [
            104,
            49
          ],
          bgMagentaBright: [
            105,
            49
          ],
          bgCyanBright: [
            106,
            49
          ],
          bgWhiteBright: [
            107,
            49
          ]
        }
      };
      styles3.color.gray = styles3.color.blackBright, styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright, styles3.color.grey = styles3.color.blackBright, styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = Object.entries(styles3)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _step_value = _sliced_to_array15(_step.value, 2), groupName = _step_value[0], group = _step_value[1], _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = Object.entries(group)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var _step_value1 = _sliced_to_array15(_step1.value, 2), styleName = _step_value1[0], style = _step_value1[1];
              styles3[styleName] = {
                open: "\x1B[".concat(style[0], "m"),
                close: "\x1B[".concat(style[1], "m")
              }, group[styleName] = styles3[styleName], codes2.set(style[0], style[1]);
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
          Object.defineProperty(styles3, groupName, {
            value: group,
            enumerable: !1
          });
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return Object.defineProperty(styles3, "codes", {
        value: codes2,
        enumerable: !1
      }), styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", setLazyProperty(styles3.color, "ansi", function() {
        return makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, !1);
      }), setLazyProperty(styles3.color, "ansi256", function() {
        return makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, !1);
      }), setLazyProperty(styles3.color, "ansi16m", function() {
        return makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, !1);
      }), setLazyProperty(styles3.bgColor, "ansi", function() {
        return makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, !0);
      }), setLazyProperty(styles3.bgColor, "ansi256", function() {
        return makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, !0);
      }), setLazyProperty(styles3.bgColor, "ansi16m", function() {
        return makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, !0);
      }), styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: !0,
      get: assembleStyles2
    });
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag) {
      var argv2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : process.argv, prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv2.indexOf(prefix + flag), terminatorPosition = argv2.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os"), tty2 = require("tty"), hasFlag2 = require_has_flag(), env2 = process.env, forceColor;
    hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never") ? forceColor = 0 : (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) && (forceColor = 1);
    "FORCE_COLOR" in env2 && (env2.FORCE_COLOR === "true" ? forceColor = 1 : env2.FORCE_COLOR === "false" ? forceColor = 0 : forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3));
    function translateLevel2(level) {
      return level === 0 ? !1 : {
        level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor2(haveStream, streamIsTTY) {
      if (forceColor === 0)
        return 0;
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor"))
        return 3;
      if (hasFlag2("color=256"))
        return 2;
      if (haveStream && !streamIsTTY && forceColor === void 0)
        return 0;
      var min = forceColor || 0;
      if (env2.TERM === "dumb")
        return min;
      if (process.platform === "win32") {
        var osRelease = os2.release().split(".");
        return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in env2)
        return [
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI",
          "GITHUB_ACTIONS",
          "BUILDKITE"
        ].some(function(sign) {
          return sign in env2;
        }) || env2.CI_NAME === "codeship" ? 1 : min;
      if ("TEAMCITY_VERSION" in env2)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      if (env2.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in env2) {
        var version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(env2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM) || "COLORTERM" in env2 ? 1 : min;
    }
    function getSupportLevel(stream2) {
      var level = supportsColor2(stream2, stream2 && stream2.isTTY);
      return translateLevel2(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel2(supportsColor2(!0, tty2.isatty(1))),
      stderr: translateLevel2(supportsColor2(!0, tty2.isatty(2)))
    };
  }
});

// ../../node_modules/chalk/source/util.js
var require_util = __commonJS({
  "../../node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll2 = function(string, substring, replacer) {
      var index = string.indexOf(substring);
      if (index === -1)
        return string;
      var substringLength = substring.length, endIndex = 0, returnValue = "";
      do
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
      while (index !== -1);
      return returnValue += string.substr(endIndex), returnValue;
    }, stringEncaseCRLFWithFirstIndex2 = function(string, prefix, postfix, index) {
      var endIndex = 0, returnValue = "";
      do {
        var gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
      } while (index !== -1);
      return returnValue += string.substr(endIndex), returnValue;
    };
    module2.exports = {
      stringReplaceAll: stringReplaceAll2,
      stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex2
    };
  }
});

// ../../node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "../../node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = /* @__PURE__ */ new Map([
      [
        "n",
        `
`
      ],
      [
        "r",
        "\r"
      ],
      [
        "t",
        "	"
      ],
      [
        "b",
        "\b"
      ],
      [
        "f",
        "\f"
      ],
      [
        "v",
        "\v"
      ],
      [
        "0",
        "\0"
      ],
      [
        "\\",
        "\\"
      ],
      [
        "e",
        "\x1B"
      ],
      [
        "a",
        "\x07"
      ]
    ]);
    function unescape2(c) {
      var u = c[0] === "u", bracket = c[1] === "{";
      return u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3 ? String.fromCharCode(parseInt(c.slice(1), 16)) : u && bracket ? String.fromCodePoint(parseInt(c.slice(2, -1), 16)) : ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      var results = [], chunks = arguments_.trim().split(/\s*,\s*/g), matches, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var chunk = _step.value, number = Number(chunk);
          if (!Number.isNaN(number))
            results.push(number);
          else if (matches = chunk.match(STRING_REGEX))
            results.push(matches[2].replace(ESCAPE_REGEX, function(m, escape2, character) {
              return escape2 ? unescape2(escape2) : character;
            }));
          else
            throw new Error("Invalid Chalk template style argument: ".concat(chunk, " (in style '").concat(name, "')"));
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      for (var results = [], matches; (matches = STYLE_REGEX.exec(style)) !== null; ) {
        var name = matches[1];
        if (matches[2]) {
          var args = parseArguments(name, matches[2]);
          results.push([
            name
          ].concat(args));
        } else
          results.push([
            name
          ]);
      }
      return results;
    }
    function buildStyle(chalk13, styles3) {
      var enabled = {}, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = styles3[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var layer = _step.value, _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = layer.styles[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var style = _step1.value;
              enabled[style[0]] = layer.inverse ? null : style.slice(1);
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      var current = chalk13, _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
      try {
        for (var _iterator2 = Object.entries(enabled)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
          var _step_value = _sliced_to_array15(_step2.value, 2), styleName = _step_value[0], _$styles = _step_value[1], _current;
          if (Array.isArray(_$styles)) {
            if (!(styleName in current))
              throw new Error("Unknown Chalk style: ".concat(styleName));
            current = _$styles.length > 0 ? (_current = current)[styleName].apply(_current, _to_consumable_array16(_$styles)) : current[styleName];
          }
        }
      } catch (err) {
        _didIteratorError22 = !0, _iteratorError22 = err;
      } finally {
        try {
          !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
        } finally {
          if (_didIteratorError22)
            throw _iteratorError22;
        }
      }
      return current;
    }
    module2.exports = function(chalk13, temporary) {
      var styles3 = [], chunks = [], chunk = [];
      if (temporary.replace(TEMPLATE_REGEX, function(m, escapeCharacter, inverse, style, close, character) {
        if (escapeCharacter)
          chunk.push(unescape2(escapeCharacter));
        else if (style) {
          var string = chunk.join("");
          chunk = [], chunks.push(styles3.length === 0 ? string : buildStyle(chalk13, styles3)(string)), styles3.push({
            inverse,
            styles: parseStyle(style)
          });
        } else if (close) {
          if (styles3.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          chunks.push(buildStyle(chalk13, styles3)(chunk.join(""))), chunk = [], styles3.pop();
        } else
          chunk.push(character);
      }), chunks.push(chunk.join("")), styles3.length > 0) {
        var errMessage = "Chalk template literal is missing ".concat(styles3.length, " closing bracket").concat(styles3.length === 1 ? "" : "s", " (`}`)");
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/chalk/source/index.js
var require_source = __commonJS({
  "../../node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var ansiStyles2 = require_ansi_styles(), _require = require_supports_color(), stdoutColor2 = _require.stdout, stderrColor2 = _require.stderr, _require1 = require_util(), stringReplaceAll2 = _require1.stringReplaceAll, stringEncaseCRLFWithFirstIndex2 = _require1.stringEncaseCRLFWithFirstIndex, isArray = Array.isArray, levelMapping2 = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ], styles3 = /* @__PURE__ */ Object.create(null), applyOptions2 = function(object) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
        throw new Error("The `level` option should be an integer from 0 to 3");
      var colorLevel = stdoutColor2 ? stdoutColor2.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    }, ChalkClass = function ChalkClass2(options) {
      return _class_call_check15(this, ChalkClass2), chalkFactory2(options);
    }, chalkFactory2 = function(options) {
      var chalk14 = {};
      return applyOptions2(chalk14, options), chalk14.template = function() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
          arguments_[_key] = arguments[_key];
        return chalkTag.apply(void 0, [
          chalk14.template
        ].concat(_to_consumable_array16(arguments_)));
      }, Object.setPrototypeOf(chalk14, Chalk.prototype), Object.setPrototypeOf(chalk14.template, chalk14), chalk14.template.constructor = function() {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      }, chalk14.template.Instance = ChalkClass, chalk14.template;
    };
    function Chalk(options) {
      return chalkFactory2(options);
    }
    var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
    try {
      for (_loop = function() {
        var _step_value = _sliced_to_array15(_step.value, 2), styleName = _step_value[0], style = _step_value[1];
        styles3[styleName] = {
          get: function() {
            var builder = createBuilder2(this, createStyler2(style.open, style.close, this._styler), this._isEmpty);
            return Object.defineProperty(this, styleName, {
              value: builder
            }), builder;
          }
        };
      }, _iterator = Object.entries(ansiStyles2)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0)
        _loop();
    } catch (err) {
      _didIteratorError2 = !0, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError2)
          throw _iteratorError2;
      }
    }
    var _loop, _iterator, _step;
    styles3.visible = {
      get: function() {
        var builder = createBuilder2(this, this._styler, !0);
        return Object.defineProperty(this, "visible", {
          value: builder
        }), builder;
      }
    };
    var usedModels2 = [
      "rgb",
      "hex",
      "keyword",
      "hsl",
      "hsv",
      "hwb",
      "ansi",
      "ansi256"
    ], _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
    try {
      for (_loop1 = function() {
        var model = _step1.value;
        styles3[model] = {
          get: function() {
            var level = this.level;
            return function() {
              for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
                arguments_[_key] = arguments[_key];
              var _ansiStyles_color_levelMapping_level, styler = createStyler2((_ansiStyles_color_levelMapping_level = ansiStyles2.color[levelMapping2[level]])[model].apply(_ansiStyles_color_levelMapping_level, _to_consumable_array16(arguments_)), ansiStyles2.color.close, this._styler);
              return createBuilder2(this, styler, this._isEmpty);
            };
          }
        };
      }, _iterator1 = usedModels2[Symbol.iterator](); !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0)
        _loop1();
    } catch (err) {
      _didIteratorError12 = !0, _iteratorError12 = err;
    } finally {
      try {
        !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
      } finally {
        if (_didIteratorError12)
          throw _iteratorError12;
      }
    }
    var _loop1, _iterator1, _step1, _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
    try {
      for (_loop2 = function() {
        var model = _step2.value, bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles3[bgModel] = {
          get: function() {
            var level = this.level;
            return function() {
              for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
                arguments_[_key] = arguments[_key];
              var _ansiStyles_bgColor_levelMapping_level, styler = createStyler2((_ansiStyles_bgColor_levelMapping_level = ansiStyles2.bgColor[levelMapping2[level]])[model].apply(_ansiStyles_bgColor_levelMapping_level, _to_consumable_array16(arguments_)), ansiStyles2.bgColor.close, this._styler);
              return createBuilder2(this, styler, this._isEmpty);
            };
          }
        };
      }, _iterator2 = usedModels2[Symbol.iterator](); !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0)
        _loop2();
    } catch (err) {
      _didIteratorError22 = !0, _iteratorError22 = err;
    } finally {
      try {
        !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
      } finally {
        if (_didIteratorError22)
          throw _iteratorError22;
      }
    }
    var _loop2, _iterator2, _step2, proto2 = Object.defineProperties(function() {
    }, _object_spread_props9(_object_spread13({}, styles3), {
      level: {
        enumerable: !0,
        get: function() {
          return this._generator.level;
        },
        set: function(level) {
          this._generator.level = level;
        }
      }
    })), createStyler2 = function(open3, close, parent) {
      var openAll, closeAll;
      return parent === void 0 ? (openAll = open3, closeAll = close) : (openAll = parent.openAll + open3, closeAll = close + parent.closeAll), {
        open: open3,
        close,
        openAll,
        closeAll,
        parent
      };
    }, createBuilder2 = function(self, _styler, _isEmpty) {
      var builder = function() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
          arguments_[_key] = arguments[_key];
        return isArray(arguments_[0]) && isArray(arguments_[0].raw) ? applyStyle2(builder, chalkTag.apply(void 0, [
          builder
        ].concat(_to_consumable_array16(arguments_)))) : applyStyle2(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      return Object.setPrototypeOf(builder, proto2), builder._generator = self, builder._styler = _styler, builder._isEmpty = _isEmpty, builder;
    }, applyStyle2 = function(self, string) {
      if (self.level <= 0 || !string)
        return self._isEmpty ? "" : string;
      var styler = self._styler;
      if (styler === void 0)
        return string;
      var openAll = styler.openAll, closeAll = styler.closeAll;
      if (string.indexOf("\x1B") !== -1)
        for (; styler !== void 0; )
          string = stringReplaceAll2(string, styler.close, styler.open), styler = styler.parent;
      var lfIndex = string.indexOf(`
`);
      return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex2(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
    }, template, chalkTag = function(chalk14) {
      for (var _len = arguments.length, strings = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        strings[_key - 1] = arguments[_key];
      var _strings = _sliced_to_array15(strings, 1), firstString = _strings[0];
      if (!isArray(firstString) || !isArray(firstString.raw))
        return strings.join(" ");
      for (var arguments_ = strings.slice(1), parts = [
        firstString.raw[0]
      ], i = 1; i < firstString.length; i++)
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      return template === void 0 && (template = require_templates()), template(chalk14, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles3);
    var chalk13 = Chalk();
    chalk13.supportsColor = stdoutColor2;
    chalk13.stderr = Chalk({
      level: stderrColor2 ? stderrColor2.level : 0
    });
    chalk13.stderr.supportsColor = stderrColor2;
    module2.exports = chalk13;
  }
});

// ../../node_modules/commander/index.js
var require_commander = __commonJS({
  "../../node_modules/commander/index.js"(exports2, module2) {
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var EventEmitter3 = require("events").EventEmitter, spawn2 = require("child_process").spawn, path6 = require("path"), dirname = path6.dirname, basename2 = path6.basename, fs7 = require("fs");
    require("util").inherits(Command, EventEmitter3);
    exports2 = module2.exports = new Command();
    exports2.Command = Command;
    exports2.Option = Option;
    function Option(flags, description) {
      this.flags = flags, this.required = flags.indexOf("<") >= 0, this.optional = flags.indexOf("[") >= 0, this.bool = flags.indexOf("-no-") === -1, flags = flags.split(/[ ,|]+/), flags.length > 1 && !/^[[<]/.test(flags[1]) && (this.short = flags.shift()), this.long = flags.shift(), this.description = description || "";
    }
    Option.prototype.name = function() {
      return this.long.replace("--", "").replace("no-", "");
    };
    Option.prototype.attributeName = function() {
      return camelcase(this.name());
    };
    Option.prototype.is = function(arg) {
      return this.short === arg || this.long === arg;
    };
    function Command(name) {
      this.commands = [], this.options = [], this._execs = {}, this._allowUnknownOption = !1, this._args = [], this._name = name || "";
    }
    Command.prototype.command = function(name, desc, opts) {
      typeof desc == "object" && desc !== null && (opts = desc, desc = null), opts = opts || {};
      var args = name.split(/ +/), cmd = new Command(args.shift());
      return desc && (cmd.description(desc), this.executables = !0, this._execs[cmd._name] = !0, opts.isDefault && (this.defaultExecutable = cmd._name)), cmd._noHelp = !!opts.noHelp, this.commands.push(cmd), cmd.parseExpectedArgs(args), cmd.parent = this, desc ? this : cmd;
    };
    Command.prototype.arguments = function(desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    };
    Command.prototype.addImplicitHelpCommand = function() {
      this.command("help [cmd]", "display help for [cmd]");
    };
    Command.prototype.parseExpectedArgs = function(args) {
      if (args.length) {
        var self = this;
        return args.forEach(function(arg) {
          var argDetails = {
            required: !1,
            name: "",
            variadic: !1
          };
          switch (arg[0]) {
            case "<":
              argDetails.required = !0, argDetails.name = arg.slice(1, -1);
              break;
            case "[":
              argDetails.name = arg.slice(1, -1);
              break;
          }
          argDetails.name.length > 3 && argDetails.name.slice(-3) === "..." && (argDetails.variadic = !0, argDetails.name = argDetails.name.slice(0, -3)), argDetails.name && self._args.push(argDetails);
        }), this;
      }
    };
    Command.prototype.action = function(fn) {
      var self = this, listener = function(args, unknown) {
        args = args || [], unknown = unknown || [];
        var parsed = self.parseOptions(unknown);
        outputHelpIfNecessary(self, parsed.unknown), parsed.unknown.length > 0 && self.unknownOption(parsed.unknown[0]), parsed.args.length && (args = parsed.args.concat(args)), self._args.forEach(function(arg, i) {
          arg.required && args[i] == null ? self.missingArgument(arg.name) : arg.variadic && (i !== self._args.length - 1 && self.variadicArgNotLast(arg.name), args[i] = args.splice(i));
        }), self._args.length ? args[self._args.length] = self : args.push(self), fn.apply(self, args);
      }, parent = this.parent || this, name = parent === this ? "*" : this._name;
      return parent.on("command:" + name, listener), this._alias && parent.on("command:" + this._alias, listener), this;
    };
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this, option = new Option(flags, description), oname = option.name(), name = option.attributeName();
      if (typeof fn != "function")
        if (_instanceof13(fn, RegExp)) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          };
        } else
          defaultValue = fn, fn = null;
      return (!option.bool || option.optional || option.required) && (option.bool || (defaultValue = !0), defaultValue !== void 0 && (self[name] = defaultValue, option.defaultValue = defaultValue)), this.options.push(option), this.on("option:" + oname, function(val) {
        val !== null && fn && (val = fn(val, self[name] === void 0 ? defaultValue : self[name])), typeof self[name] == "boolean" || typeof self[name] > "u" ? val == null ? self[name] = option.bool ? defaultValue || !0 : !1 : self[name] = val : val !== null && (self[name] = val);
      }), this;
    };
    Command.prototype.allowUnknownOption = function(arg) {
      return this._allowUnknownOption = arguments.length === 0 || arg, this;
    };
    Command.prototype.parse = function(argv2) {
      this.executables && this.addImplicitHelpCommand(), this.rawArgs = argv2, this._name = this._name || basename2(argv2[1], ".js"), this.executables && argv2.length < 3 && !this.defaultExecutable && argv2.push("--help");
      var parsed = this.parseOptions(this.normalize(argv2.slice(2))), args = this.args = parsed.args, result = this.parseArgs(this.args, parsed.unknown), name = result.args[0], aliasCommand = null;
      return name && (aliasCommand = this.commands.filter(function(command) {
        return command.alias() === name;
      })[0]), this._execs[name] && typeof this._execs[name] != "function" ? this.executeSubCommand(argv2, args, parsed.unknown) : aliasCommand ? (args[0] = aliasCommand._name, this.executeSubCommand(argv2, args, parsed.unknown)) : this.defaultExecutable ? (args.unshift(this.defaultExecutable), this.executeSubCommand(argv2, args, parsed.unknown)) : result;
    };
    Command.prototype.executeSubCommand = function(argv2, args, unknown) {
      args = args.concat(unknown), args.length || this.help(), args[0] === "help" && args.length === 1 && this.help(), args[0] === "help" && (args[0] = args[1], args[1] = "--help");
      var f = argv2[1], bin = basename2(f, path6.extname(f)) + "-" + args[0], baseDir, resolvedLink = fs7.realpathSync(f);
      baseDir = dirname(resolvedLink);
      var localBin = path6.join(baseDir, bin), isExplicitJS = !1;
      exists(localBin + ".js") ? (bin = localBin + ".js", isExplicitJS = !0) : exists(localBin + ".ts") ? (bin = localBin + ".ts", isExplicitJS = !0) : exists(localBin) && (bin = localBin), args = args.slice(1);
      var proc3;
      process.platform !== "win32" ? isExplicitJS ? (args.unshift(bin), args = (process.execArgv || []).concat(args), proc3 = spawn2(process.argv[0], args, {
        stdio: "inherit",
        customFds: [
          0,
          1,
          2
        ]
      })) : proc3 = spawn2(bin, args, {
        stdio: "inherit",
        customFds: [
          0,
          1,
          2
        ]
      }) : (args.unshift(bin), proc3 = spawn2(process.execPath, args, {
        stdio: "inherit"
      }));
      var signals = [
        "SIGUSR1",
        "SIGUSR2",
        "SIGTERM",
        "SIGINT",
        "SIGHUP"
      ];
      signals.forEach(function(signal) {
        process.on(signal, function() {
          proc3.killed === !1 && proc3.exitCode === null && proc3.kill(signal);
        });
      }), proc3.on("close", process.exit.bind(process)), proc3.on("error", function(err) {
        err.code === "ENOENT" ? console.error("error: %s(1) does not exist, try --help", bin) : err.code === "EACCES" && console.error("error: %s(1) not executable. try chmod or run with root", bin), process.exit(1);
      }), this.runningCommand = proc3;
    };
    Command.prototype.normalize = function(args) {
      for (var ret = [], arg, lastOpt, index, i = 0, len = args.length; i < len; ++i)
        if (arg = args[i], i > 0 && (lastOpt = this.optionFor(args[i - 1])), arg === "--") {
          ret = ret.concat(args.slice(i));
          break;
        } else
          lastOpt && lastOpt.required ? ret.push(arg) : arg.length > 1 && arg[0] === "-" && arg[1] !== "-" ? arg.slice(1).split("").forEach(function(c) {
            ret.push("-" + c);
          }) : /^--/.test(arg) && ~(index = arg.indexOf("=")) ? ret.push(arg.slice(0, index), arg.slice(index + 1)) : ret.push(arg);
      return ret;
    };
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
      return args.length ? (name = args[0], this.listeners("command:" + name).length ? this.emit("command:" + args.shift(), args, unknown) : this.emit("command:*", args)) : (outputHelpIfNecessary(this, unknown), unknown.length > 0 && this.unknownOption(unknown[0]), this.commands.length === 0 && this._args.filter(function(a) {
        return a.required;
      }).length === 0 && this.emit("command:*")), this;
    };
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i)
        if (this.options[i].is(arg))
          return this.options[i];
    };
    Command.prototype.parseOptions = function(argv2) {
      for (var args = [], len = argv2.length, literal, option, arg, unknownOptions = [], i = 0; i < len; ++i) {
        if (arg = argv2[i], literal) {
          args.push(arg);
          continue;
        }
        if (arg === "--") {
          literal = !0;
          continue;
        }
        if (option = this.optionFor(arg), option) {
          if (option.required) {
            if (arg = argv2[++i], arg == null)
              return this.optionMissingArgument(option);
            this.emit("option:" + option.name(), arg);
          } else
            option.optional ? (arg = argv2[i + 1], arg == null || arg[0] === "-" && arg !== "-" ? arg = null : ++i, this.emit("option:" + option.name(), arg)) : this.emit("option:" + option.name());
          continue;
        }
        if (arg.length > 1 && arg[0] === "-") {
          unknownOptions.push(arg), i + 1 < argv2.length && argv2[i + 1][0] !== "-" && unknownOptions.push(argv2[++i]);
          continue;
        }
        args.push(arg);
      }
      return {
        args,
        unknown: unknownOptions
      };
    };
    Command.prototype.opts = function() {
      for (var result = {}, len = this.options.length, i = 0; i < len; i++) {
        var key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    };
    Command.prototype.missingArgument = function(name) {
      console.error("error: missing required argument `%s'", name), process.exit(1);
    };
    Command.prototype.optionMissingArgument = function(option, flag) {
      flag ? console.error("error: option `%s' argument missing, got `%s'", option.flags, flag) : console.error("error: option `%s' argument missing", option.flags), process.exit(1);
    };
    Command.prototype.unknownOption = function(flag) {
      this._allowUnknownOption || (console.error("error: unknown option `%s'", flag), process.exit(1));
    };
    Command.prototype.variadicArgNotLast = function(name) {
      console.error("error: variadic arguments must be last `%s'", name), process.exit(1);
    };
    Command.prototype.version = function(str, flags) {
      if (arguments.length === 0)
        return this._version;
      this._version = str, flags = flags || "-V, --version";
      var versionOption = new Option(flags, "output the version number");
      return this._versionOptionName = versionOption.long.substr(2) || "version", this.options.push(versionOption), this.on("option:" + this._versionOptionName, function() {
        process.stdout.write(str + `
`), process.exit(0);
      }), this;
    };
    Command.prototype.description = function(str, argsDescription) {
      return arguments.length === 0 ? this._description : (this._description = str, this._argsDescription = argsDescription, this);
    };
    Command.prototype.alias = function(alias) {
      var command = this;
      if (this.commands.length !== 0 && (command = this.commands[this.commands.length - 1]), arguments.length === 0)
        return command._alias;
      if (alias === command._name)
        throw new Error("Command alias can't be the same as its name");
      return command._alias = alias, this;
    };
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      }), usage = "[options]" + (this.commands.length ? " [command]" : "") + (this._args.length ? " " + args.join(" ") : "");
      return arguments.length === 0 ? this._usage || usage : (this._usage = str, this);
    };
    Command.prototype.name = function(str) {
      return arguments.length === 0 ? this._name : (this._name = str, this);
    };
    Command.prototype.prepareCommands = function() {
      return this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(" ");
        return [
          cmd._name + (cmd._alias ? "|" + cmd._alias : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : ""),
          cmd._description
        ];
      });
    };
    Command.prototype.largestCommandLength = function() {
      var commands = this.prepareCommands();
      return commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    };
    Command.prototype.largestOptionLength = function() {
      var options = [].slice.call(this.options);
      return options.push({
        flags: "-h, --help"
      }), options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    Command.prototype.largestArgLength = function() {
      return this._args.reduce(function(max, arg) {
        return Math.max(max, arg.name.length);
      }, 0);
    };
    Command.prototype.padWidth = function() {
      var width = this.largestOptionLength();
      return this._argsDescription && this._args.length && this.largestArgLength() > width && (width = this.largestArgLength()), this.commands && this.commands.length && this.largestCommandLength() > width && (width = this.largestCommandLength()), width;
    };
    Command.prototype.optionHelp = function() {
      var width = this.padWidth();
      return this.options.map(function(option) {
        return pad(option.flags, width) + "  " + option.description + (option.bool && option.defaultValue !== void 0 ? " (default: " + JSON.stringify(option.defaultValue) + ")" : "");
      }).concat([
        pad("-h, --help", width) + "  output usage information"
      ]).join(`
`);
    };
    Command.prototype.commandHelp = function() {
      if (!this.commands.length)
        return "";
      var commands = this.prepareCommands(), width = this.padWidth();
      return [
        "Commands:",
        commands.map(function(cmd) {
          var desc = cmd[1] ? "  " + cmd[1] : "";
          return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
        }).join(`
`).replace(/^/gm, "  "),
        ""
      ].join(`
`);
    };
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          this._description,
          ""
        ];
        var argsDescription = this._argsDescription;
        if (argsDescription && this._args.length) {
          var width = this.padWidth();
          desc.push("Arguments:"), desc.push(""), this._args.forEach(function(arg) {
            desc.push("  " + pad(arg.name, width) + "  " + argsDescription[arg.name]);
          }), desc.push("");
        }
      }
      var cmdName = this._name;
      this._alias && (cmdName = cmdName + "|" + this._alias);
      var usage = [
        "Usage: " + cmdName + " " + this.usage(),
        ""
      ], cmds = [], commandHelp = this.commandHelp();
      commandHelp && (cmds = [
        commandHelp
      ]);
      var options = [
        "Options:",
        "" + this.optionHelp().replace(/^/gm, "  "),
        ""
      ];
      return usage.concat(desc).concat(options).concat(cmds).join(`
`);
    };
    Command.prototype.outputHelp = function(cb) {
      cb || (cb = function(passthru) {
        return passthru;
      }), process.stdout.write(cb(this.helpInformation())), this.emit("--help");
    };
    Command.prototype.help = function(cb) {
      this.outputHelp(cb), process.exit();
    };
    function camelcase(flag) {
      return flag.split("-").reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(" ");
    }
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++)
        (options[i] === "--help" || options[i] === "-h") && (cmd.outputHelp(), process.exit(0));
    }
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === !0 ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    function exists(file) {
      try {
        if (fs7.statSync(file).isFile())
          return !0;
      } catch {
        return !1;
      }
    }
  }
});

// ../../node_modules/isexe/windows.js
var require_windows = __commonJS({
  "../../node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs7 = require("fs");
    function checkPathExt(path6, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext || (pathext = pathext.split(";"), pathext.indexOf("") !== -1))
        return !0;
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path6.substr(-p.length).toLowerCase() === p)
          return !0;
      }
      return !1;
    }
    function checkStat(stat3, path6, options) {
      return !stat3.isSymbolicLink() && !stat3.isFile() ? !1 : checkPathExt(path6, options);
    }
    function isexe(path6, options, cb) {
      fs7.stat(path6, function(er, stat3) {
        cb(er, er ? !1 : checkStat(stat3, path6, options));
      });
    }
    function sync2(path6, options) {
      return checkStat(fs7.statSync(path6), path6, options);
    }
  }
});

// ../../node_modules/isexe/mode.js
var require_mode = __commonJS({
  "../../node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs7 = require("fs");
    function isexe(path6, options, cb) {
      fs7.stat(path6, function(er, stat3) {
        cb(er, er ? !1 : checkStat(stat3, options));
      });
    }
    function sync2(path6, options) {
      return checkStat(fs7.statSync(path6), options);
    }
    function checkStat(stat3, options) {
      return stat3.isFile() && checkMode(stat3, options);
    }
    function checkMode(stat3, options) {
      var mod = stat3.mode, uid = stat3.uid, gid = stat3.gid, myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid(), myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g, ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// ../../node_modules/isexe/index.js
var require_isexe = __commonJS({
  "../../node_modules/isexe/index.js"(exports2, module2) {
    var fs7 = require("fs"), core;
    process.platform === "win32" || global.TESTING_WINDOWS ? core = require_windows() : core = require_mode();
    module2.exports = isexe;
    isexe.sync = sync2;
    function isexe(path6, options, cb) {
      if (typeof options == "function" && (cb = options, options = {}), !cb) {
        if (typeof Promise != "function")
          throw new TypeError("callback not provided");
        return new Promise(function(resolve7, reject) {
          isexe(path6, options || {}, function(er, is) {
            er ? reject(er) : resolve7(is);
          });
        });
      }
      core(path6, options || {}, function(er, is) {
        er && (er.code === "EACCES" || options && options.ignoreErrors) && (er = null, is = !1), cb(er, is);
      });
    }
    function sync2(path6, options) {
      try {
        return core.sync(path6, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES")
          return !1;
        throw er;
      }
    }
  }
});

// ../../node_modules/execa/node_modules/which/which.js
var require_which = __commonJS({
  "../../node_modules/execa/node_modules/which/which.js"(exports2, module2) {
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path6 = require("path"), COLON = isWindows ? ";" : ":", isexe = require_isexe(), getNotFoundError = function(cmd) {
      return Object.assign(new Error("not found: ".concat(cmd)), {
        code: "ENOENT"
      });
    }, getPathInfo = function(cmd, opt) {
      var colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
        ""
      ] : (
        // windows always checks the cwd first
        _to_consumable_array16(isWindows ? [
          process.cwd()
        ] : []).concat(_to_consumable_array16((opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)))
      ), pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows ? pathExtExe.split(colon) : [
        ""
      ];
      return isWindows && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
        pathEnv,
        pathExt,
        pathExtExe
      };
    }, which2 = function(cmd, opt, cb) {
      typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
      var _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe, found = [], step = function(i) {
        return new Promise(function(resolve7, reject) {
          if (i === pathEnv.length)
            return opt.all && found.length ? resolve7(found) : reject(getNotFoundError(cmd));
          var ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          resolve7(subStep(p, i, 0));
        });
      }, subStep = function(p, i, ii) {
        return new Promise(function(resolve7, reject) {
          if (ii === pathExt.length)
            return resolve7(step(i + 1));
          var ext2 = pathExt[ii];
          isexe(p + ext2, {
            pathExt: pathExtExe
          }, function(er, is) {
            if (!er && is)
              if (opt.all)
                found.push(p + ext2);
              else
                return resolve7(p + ext2);
            return resolve7(subStep(p, i, ii + 1));
          });
        });
      };
      return cb ? step(0).then(function(res) {
        return cb(null, res);
      }, cb) : step(0);
    }, whichSync = function(cmd, opt) {
      opt = opt || {};
      for (var _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe, found = [], i = 0; i < pathEnv.length; i++)
        for (var ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd, j = 0; j < pathExt.length; j++) {
          var cur = p + pathExt[j];
          try {
            var is = isexe.sync(cur, {
              pathExt: pathExtExe
            });
            if (is)
              if (opt.all)
                found.push(cur);
              else
                return cur;
          } catch {
          }
        }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// ../../node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../../node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey = function() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, environment = options.env || process.env, platform = options.platform || process.platform;
      return platform !== "win32" ? "PATH" : Object.keys(environment).reverse().find(function(key) {
        return key.toUpperCase() === "PATH";
      }) || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), which2 = require_which(), getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      var env2 = parsed.options.env || process.env, cwd2 = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd)
        try {
          process.chdir(parsed.options.cwd);
        } catch {
        }
      var resolved;
      try {
        resolved = which2.sync(parsed.command, {
          path: env2[getPathKey({
            env: env2
          })],
          pathExt: withoutPathExt ? path6.delimiter : void 0
        });
      } catch {
      } finally {
        shouldSwitchCwd && process.chdir(cwd2);
      }
      return resolved && (resolved = path6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
    }
    module2.exports = resolveCommand;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      return arg = "".concat(arg), arg = arg.replace(/(\\*)"/g, '$1$1\\"'), arg = arg.replace(/(\\*)$/, "$1$1"), arg = '"'.concat(arg, '"'), arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// ../../node_modules/execa/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../../node_modules/execa/node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// ../../node_modules/execa/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../../node_modules/execa/node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var shebangRegex = require_shebang_regex();
    module2.exports = function() {
      var string = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", match2 = string.match(shebangRegex);
      if (!match2)
        return null;
      var _match__replace_split = _sliced_to_array15(match2[0].replace(/#! ?/, "").split(" "), 2), path6 = _match__replace_split[0], argument = _match__replace_split[1], binary = path6.split("/").pop();
      return binary === "env" ? argument : argument ? "".concat(binary, " ").concat(argument) : binary;
    };
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs7 = require("fs"), shebangCommand = require_shebang_command();
    function readShebang(command) {
      var size = 150, buffer = Buffer.alloc(size), fd;
      try {
        fd = fs7.openSync(command, "r"), fs7.readSync(fd, buffer, 0, size, 0), fs7.closeSync(fd);
      } catch {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), resolveCommand = require_resolveCommand(), escape2 = require_escape(), readShebang = require_readShebang(), isWin = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      var shebang = parsed.file && readShebang(parsed.file);
      return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin)
        return parsed;
      var commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        var needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path6.normalize(parsed.command), parsed.command = escape2.command(parsed.command), parsed.args = parsed.args.map(function(arg) {
          return escape2.argument(arg, needsDoubleEscapeMetaChars);
        });
        var shellCommand = [
          parsed.command
        ].concat(parsed.args).join(" ");
        parsed.args = [
          "/d",
          "/s",
          "/c",
          '"'.concat(shellCommand, '"')
        ], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
      }
      return parsed;
    }
    function parse6(command, args, options) {
      args && !Array.isArray(args) && (options = args, args = null), args = args ? args.slice(0) : [], options = Object.assign({}, options);
      var parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse6;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error("".concat(syscall, " ").concat(original.command, " ENOENT")), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: "".concat(syscall, " ").concat(original.command),
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (isWin) {
        var originalEmit = cp.emit;
        cp.emit = function(name, arg1) {
          if (name === "exit") {
            var err = verifyENOENT(arg1, parsed, "spawn");
            if (err)
              return originalEmit.call(cp, "error", err);
          }
          return originalEmit.apply(cp, arguments);
        };
      }
    }
    function verifyENOENT(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
    }
    function verifyENOENTSync(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process"), parse6 = require_parse(), enoent = require_enoent();
    function spawn2(command, args, options) {
      var parsed = parse6(command, args, options), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      return enoent.hookChildProcess(spawned, parsed), spawned;
    }
    function spawnSync(command, args, options) {
      var parsed = parse6(command, args, options), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      return result.error = result.error || enoent.verifyENOENTSync(result.status, parsed), result;
    }
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse6;
    module2.exports._enoent = enoent;
  }
});

// ../../node_modules/strip-final-newline/index.js
var require_strip_final_newline = __commonJS({
  "../../node_modules/strip-final-newline/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(input) {
      var LF = typeof input == "string" ? `
` : 10, CR = typeof input == "string" ? "\r" : 13;
      return input[input.length - 1] === LF && (input = input.slice(0, input.length - 1)), input[input.length - 1] === CR && (input = input.slice(0, input.length - 1)), input;
    };
  }
});

// ../../node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "../../node_modules/npm-run-path/index.js"(exports2, module2) {
    "use strict";
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    var path6 = require("path"), pathKey = require_path_key(), npmRunPath = function(options) {
      options = _object_spread13({
        cwd: process.cwd(),
        path: process.env[pathKey()],
        execPath: process.execPath
      }, options);
      for (var previous, cwdPath = path6.resolve(options.cwd), result = []; previous !== cwdPath; )
        result.push(path6.join(cwdPath, "node_modules/.bin")), previous = cwdPath, cwdPath = path6.resolve(cwdPath, "..");
      var execPathDir = path6.resolve(options.cwd, options.execPath, "..");
      return result.push(execPathDir), result.concat(options.path).join(path6.delimiter);
    };
    module2.exports = npmRunPath;
    module2.exports.default = npmRunPath;
    module2.exports.env = function(options) {
      options = _object_spread13({
        env: process.env
      }, options);
      var env2 = _object_spread13({}, options.env), path7 = pathKey({
        env: env2
      });
      return options.path = env2[path7], env2[path7] = module2.exports(options), env2;
    };
  }
});

// ../../node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "../../node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = function(to, from) {
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = Reflect.ownKeys(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var prop = _step.value;
          Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// ../../node_modules/onetime/index.js
var require_onetime = __commonJS({
  "../../node_modules/onetime/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn(), calledFunctions = /* @__PURE__ */ new WeakMap(), onetime = function(function_) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (typeof function_ != "function")
        throw new TypeError("Expected a function");
      var returnValue, callCount = 0, functionName = function_.displayName || function_.name || "<anonymous>", onetime2 = function() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
          arguments_[_key] = arguments[_key];
        if (calledFunctions.set(onetime2, ++callCount), callCount === 1)
          returnValue = function_.apply(this, arguments_), function_ = null;
        else if (options.throw === !0)
          throw new Error("Function `".concat(functionName, "` can only be called once"));
        return returnValue;
      };
      return mimicFn(onetime2, function_), calledFunctions.set(onetime2, callCount), onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = function(function_) {
      if (!calledFunctions.has(function_))
        throw new Error("The given function `".concat(function_.name, "` is not wrapped by the `onetime` package"));
      return calledFunctions.get(function_);
    };
  }
});

// ../../node_modules/human-signals/build/src/core.js
var require_core = __commonJS({
  "../../node_modules/human-signals/build/src/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.SIGNALS = void 0;
    var SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: !0
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: !0
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: !0
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports2.SIGNALS = SIGNALS;
  }
});

// ../../node_modules/human-signals/build/src/realtime.js
var require_realtime = __commonJS({
  "../../node_modules/human-signals/build/src/realtime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
    var getRealtimeSignals = function() {
      var length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({
        length
      }, getRealtimeSignal);
    };
    exports2.getRealtimeSignals = getRealtimeSignals;
    var getRealtimeSignal = function(value, index) {
      return {
        name: "SIGRT".concat(index + 1),
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    }, SIGRTMIN = 34, SIGRTMAX = 64;
    exports2.SIGRTMAX = SIGRTMAX;
  }
});

// ../../node_modules/human-signals/build/src/signals.js
var require_signals = __commonJS({
  "../../node_modules/human-signals/build/src/signals.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.getSignals = void 0;
    var _os = require("os"), _core = require_core(), _realtime = require_realtime(), getSignals = function() {
      var realtimeSignals = (0, _realtime.getRealtimeSignals)(), signals = _to_consumable_array16(_core.SIGNALS).concat(_to_consumable_array16(realtimeSignals)).map(normalizeSignal);
      return signals;
    };
    exports2.getSignals = getSignals;
    var normalizeSignal = function(param) {
      var name = param.name, defaultNumber = param.number, description = param.description, action = param.action, _param_forced = param.forced, forced = _param_forced === void 0 ? !1 : _param_forced, standard = param.standard, _os_constants = _os.constants, _os_constants_signals = _os_constants.signals, constantSignal = _os_constants_signals[name], supported = constantSignal !== void 0, number = supported ? constantSignal : defaultNumber;
      return {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
      };
    };
  }
});

// ../../node_modules/human-signals/build/src/main.js
var require_main = __commonJS({
  "../../node_modules/human-signals/build/src/main.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.signalsByNumber = exports2.signalsByName = void 0;
    var _os = require("os"), _signals = require_signals(), _realtime = require_realtime(), getSignalsByName = function() {
      var signals = (0, _signals.getSignals)();
      return signals.reduce(getSignalByName, {});
    }, getSignalByName = function(signalByNameMemo, param) {
      var name = param.name, number = param.number, description = param.description, supported = param.supported, action = param.action, forced = param.forced, standard = param.standard;
      return _object_spread_props9(_object_spread13({}, signalByNameMemo), _define_property21({}, name, {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
      }));
    }, signalsByName = getSignalsByName();
    exports2.signalsByName = signalsByName;
    var getSignalsByNumber = function() {
      var _Object, signals = (0, _signals.getSignals)(), length = _realtime.SIGRTMAX + 1, signalsA = Array.from({
        length
      }, function(value, number) {
        return getSignalByNumber(number, signals);
      });
      return (_Object = Object).assign.apply(_Object, [
        {}
      ].concat(_to_consumable_array16(signalsA)));
    }, getSignalByNumber = function(number, signals) {
      var signal = findSignalByNumber(number, signals);
      if (signal === void 0)
        return {};
      var name = signal.name, description = signal.description, supported = signal.supported, action = signal.action, forced = signal.forced, standard = signal.standard;
      return _define_property21({}, number, {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
      });
    }, findSignalByNumber = function(number, signals) {
      var signal = signals.find(function(param) {
        var name = param.name;
        return _os.constants.signals[name] === number;
      });
      return signal !== void 0 ? signal : signals.find(function(signalA) {
        return signalA.number === number;
      });
    }, signalsByNumber = getSignalsByNumber();
    exports2.signalsByNumber = signalsByNumber;
  }
});

// ../../node_modules/execa/lib/error.js
var require_error = __commonJS({
  "../../node_modules/execa/lib/error.js"(exports2, module2) {
    "use strict";
    var signalsByName = require_main().signalsByName, getErrorPrefix = function(param) {
      var timedOut = param.timedOut, timeout = param.timeout, errorCode = param.errorCode, signal = param.signal, signalDescription = param.signalDescription, exitCode = param.exitCode, isCanceled = param.isCanceled;
      return timedOut ? "timed out after ".concat(timeout, " milliseconds") : isCanceled ? "was canceled" : errorCode !== void 0 ? "failed with ".concat(errorCode) : signal !== void 0 ? "was killed with ".concat(signal, " (").concat(signalDescription, ")") : exitCode !== void 0 ? "failed with exit code ".concat(exitCode) : "failed";
    }, makeError = function(param) {
      var stdout = param.stdout, stderr = param.stderr, all = param.all, error = param.error, signal = param.signal, exitCode = param.exitCode, command = param.command, escapedCommand = param.escapedCommand, timedOut = param.timedOut, isCanceled = param.isCanceled, killed = param.killed, _param_parsed = param.parsed, timeout = _param_parsed.options.timeout;
      exitCode = exitCode === null ? void 0 : exitCode, signal = signal === null ? void 0 : signal;
      var signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description, errorCode = error && error.code, prefix = getErrorPrefix({
        timedOut,
        timeout,
        errorCode,
        signal,
        signalDescription,
        exitCode,
        isCanceled
      }), execaMessage = "Command ".concat(prefix, ": ").concat(command), isError = Object.prototype.toString.call(error) === "[object Error]", shortMessage = isError ? "".concat(execaMessage, `
`).concat(error.message) : execaMessage, message = [
        shortMessage,
        stderr,
        stdout
      ].filter(Boolean).join(`
`);
      return isError ? (error.originalMessage = error.message, error.message = message) : error = new Error(message), error.shortMessage = shortMessage, error.command = command, error.escapedCommand = escapedCommand, error.exitCode = exitCode, error.signal = signal, error.signalDescription = signalDescription, error.stdout = stdout, error.stderr = stderr, all !== void 0 && (error.all = all), "bufferedData" in error && delete error.bufferedData, error.failed = !0, error.timedOut = !!timedOut, error.isCanceled = isCanceled, error.killed = killed && !timedOut, error;
    };
    module2.exports = makeError;
  }
});

// ../../node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "../../node_modules/execa/lib/stdio.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var aliases = [
      "stdin",
      "stdout",
      "stderr"
    ], hasAlias = function(options) {
      return aliases.some(function(alias) {
        return options[alias] !== void 0;
      });
    }, normalizeStdio = function(options) {
      if (options) {
        var stdio = options.stdio;
        if (stdio === void 0)
          return aliases.map(function(alias) {
            return options[alias];
          });
        if (hasAlias(options))
          throw new Error("It's not possible to provide `stdio` in combination with one of ".concat(aliases.map(function(alias) {
            return "`".concat(alias, "`");
          }).join(", ")));
        if (typeof stdio == "string")
          return stdio;
        if (!Array.isArray(stdio))
          throw new TypeError("Expected `stdio` to be of type `string` or `Array`, got `".concat(typeof stdio > "u" ? "undefined" : _type_of12(stdio), "`"));
        var length = Math.max(stdio.length, aliases.length);
        return Array.from({
          length
        }, function(value, index) {
          return stdio[index];
        });
      }
    };
    module2.exports = normalizeStdio;
    module2.exports.node = function(options) {
      var stdio = normalizeStdio(options);
      return stdio === "ipc" ? "ipc" : stdio === void 0 || typeof stdio == "string" ? [
        stdio,
        stdio,
        stdio,
        "ipc"
      ] : stdio.includes("ipc") ? stdio : _to_consumable_array16(stdio).concat([
        "ipc"
      ]);
    };
  }
});

// ../../node_modules/signal-exit/signals.js
var require_signals2 = __commonJS({
  "../../node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    process.platform !== "win32" && module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    process.platform === "linux" && module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// ../../node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "../../node_modules/signal-exit/index.js"(exports2, module2) {
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    var process4 = global.process, processOk = function(process5) {
      return process5 && typeof process5 == "object" && typeof process5.removeListener == "function" && typeof process5.emit == "function" && typeof process5.reallyExit == "function" && typeof process5.listeners == "function" && typeof process5.kill == "function" && typeof process5.pid == "number" && typeof process5.on == "function";
    };
    processOk(process4) ? (assert2 = require("assert"), signals = require_signals2(), isWin = /^win/i.test(process4.platform), EE = require("events"), typeof EE != "function" && (EE = EE.EventEmitter), process4.__signal_exit_emitter__ ? emitter = process4.__signal_exit_emitter__ : (emitter = process4.__signal_exit_emitter__ = new EE(), emitter.count = 0, emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), module2.exports = function(cb, opts) {
      if (!processOk(global.process))
        return function() {
        };
      assert2.equal(typeof cb > "u" ? "undefined" : _type_of12(cb), "function", "a callback must be provided for exit handler"), loaded === !1 && load();
      var ev = "exit";
      opts && opts.alwaysLast && (ev = "afterexit");
      var remove2 = function() {
        emitter.removeListener(ev, cb), emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0 && unload();
      };
      return emitter.on(ev, cb), remove2;
    }, unload = function() {
      !loaded || !processOk(global.process) || (loaded = !1, signals.forEach(function(sig) {
        try {
          process4.removeListener(sig, sigListeners[sig]);
        } catch {
        }
      }), process4.emit = originalProcessEmit, process4.reallyExit = originalProcessReallyExit, emitter.count -= 1);
    }, module2.exports.unload = unload, emit = function(event, code, signal) {
      emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
    }, sigListeners = {}, signals.forEach(function(sig) {
      sigListeners[sig] = function() {
        if (processOk(global.process)) {
          var listeners = process4.listeners(sig);
          listeners.length === emitter.count && (unload(), emit("exit", null, sig), emit("afterexit", null, sig), isWin && sig === "SIGHUP" && (sig = "SIGINT"), process4.kill(process4.pid, sig));
        }
      };
    }), module2.exports.signals = function() {
      return signals;
    }, loaded = !1, load = function() {
      loaded || !processOk(global.process) || (loaded = !0, emitter.count += 1, signals = signals.filter(function(sig) {
        try {
          return process4.on(sig, sigListeners[sig]), !0;
        } catch {
          return !1;
        }
      }), process4.emit = processEmit, process4.reallyExit = processReallyExit);
    }, module2.exports.load = load, originalProcessReallyExit = process4.reallyExit, processReallyExit = function(code) {
      processOk(global.process) && (process4.exitCode = code || /* istanbul ignore next */
      0, emit("exit", process4.exitCode, null), emit("afterexit", process4.exitCode, null), originalProcessReallyExit.call(process4, process4.exitCode));
    }, originalProcessEmit = process4.emit, processEmit = function(ev, arg) {
      if (ev === "exit" && processOk(global.process)) {
        arg !== void 0 && (process4.exitCode = arg);
        var ret = originalProcessEmit.apply(this, arguments);
        return emit("exit", process4.exitCode, null), emit("afterexit", process4.exitCode, null), ret;
      } else
        return originalProcessEmit.apply(this, arguments);
    }) : module2.exports = function() {
      return function() {
      };
    };
    var assert2, signals, isWin, EE, emitter, unload, emit, sigListeners, loaded, load, originalProcessReallyExit, processReallyExit, originalProcessEmit, processEmit;
  }
});

// ../../node_modules/execa/lib/kill.js
var require_kill = __commonJS({
  "../../node_modules/execa/lib/kill.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var os2 = require("os"), onExit = require_signal_exit(), DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5, spawnedKill = function(kill) {
      var signal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "SIGTERM", options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, killResult = kill(signal);
      return setKillTimeout(kill, signal, options, killResult), killResult;
    }, setKillTimeout = function(kill, signal, options, killResult) {
      if (shouldForceKill(signal, options, killResult)) {
        var timeout = getForceKillAfterTimeout(options), t = setTimeout(function() {
          kill("SIGKILL");
        }, timeout);
        t.unref && t.unref();
      }
    }, shouldForceKill = function(signal, param, killResult) {
      var forceKillAfterTimeout = param.forceKillAfterTimeout;
      return isSigterm(signal) && forceKillAfterTimeout !== !1 && killResult;
    }, isSigterm = function(signal) {
      return signal === os2.constants.signals.SIGTERM || typeof signal == "string" && signal.toUpperCase() === "SIGTERM";
    }, getForceKillAfterTimeout = function(param) {
      var _param_forceKillAfterTimeout = param.forceKillAfterTimeout, forceKillAfterTimeout = _param_forceKillAfterTimeout === void 0 ? !0 : _param_forceKillAfterTimeout;
      if (forceKillAfterTimeout === !0)
        return DEFAULT_FORCE_KILL_TIMEOUT;
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0)
        throw new TypeError("Expected the `forceKillAfterTimeout` option to be a non-negative integer, got `".concat(forceKillAfterTimeout, "` (").concat(typeof forceKillAfterTimeout > "u" ? "undefined" : _type_of12(forceKillAfterTimeout), ")"));
      return forceKillAfterTimeout;
    }, spawnedCancel = function(spawned, context) {
      var killResult = spawned.kill();
      killResult && (context.isCanceled = !0);
    }, timeoutKill = function(spawned, signal, reject) {
      spawned.kill(signal), reject(Object.assign(new Error("Timed out"), {
        timedOut: !0,
        signal
      }));
    }, setupTimeout = function(spawned, param, spawnedPromise) {
      var timeout = param.timeout, _param_killSignal = param.killSignal, killSignal = _param_killSignal === void 0 ? "SIGTERM" : _param_killSignal;
      if (timeout === 0 || timeout === void 0)
        return spawnedPromise;
      var timeoutId, timeoutPromise = new Promise(function(resolve7, reject) {
        timeoutId = setTimeout(function() {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      }), safeSpawnedPromise = spawnedPromise.finally(function() {
        clearTimeout(timeoutId);
      });
      return Promise.race([
        timeoutPromise,
        safeSpawnedPromise
      ]);
    }, validateTimeout = function(param) {
      var timeout = param.timeout;
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0))
        throw new TypeError("Expected the `timeout` option to be a non-negative integer, got `".concat(timeout, "` (").concat(typeof timeout > "u" ? "undefined" : _type_of12(timeout), ")"));
    }, setExitHandler = function() {
      var _ref = _async_to_generator31(function(spawned, param, timedPromise) {
        var cleanup, detached, removeExitHandler;
        return _ts_generator31(this, function(_state) {
          return cleanup = param.cleanup, detached = param.detached, !cleanup || detached ? [
            2,
            timedPromise
          ] : (removeExitHandler = onExit(function() {
            spawned.kill();
          }), [
            2,
            timedPromise.finally(function() {
              removeExitHandler();
            })
          ]);
        });
      });
      return function(spawned, _, timedPromise) {
        return _ref.apply(this, arguments);
      };
    }();
    module2.exports = {
      spawnedKill,
      spawnedCancel,
      setupTimeout,
      validateTimeout,
      setExitHandler
    };
  }
});

// ../../node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../../node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream3 = function(stream2) {
      return stream2 !== null && typeof stream2 == "object" && typeof stream2.pipe == "function";
    };
    isStream3.writable = function(stream2) {
      return isStream3(stream2) && stream2.writable !== !1 && typeof stream2._write == "function" && typeof stream2._writableState == "object";
    };
    isStream3.readable = function(stream2) {
      return isStream3(stream2) && stream2.readable !== !1 && typeof stream2._read == "function" && typeof stream2._readableState == "object";
    };
    isStream3.duplex = function(stream2) {
      return isStream3.writable(stream2) && isStream3.readable(stream2);
    };
    isStream3.transform = function(stream2) {
      return isStream3.duplex(stream2) && typeof stream2._transform == "function";
    };
    module2.exports = isStream3;
  }
});

// ../../node_modules/execa/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../../node_modules/execa/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    var _require = require("stream"), PassThroughStream = _require.PassThrough;
    module2.exports = function(options) {
      options = _object_spread13({}, options);
      var array = options.array, encoding = options.encoding, isBuffer = encoding === "buffer", objectMode = !1;
      array ? objectMode = !(encoding || isBuffer) : encoding = encoding || "utf8", isBuffer && (encoding = null);
      var stream2 = new PassThroughStream({
        objectMode
      });
      encoding && stream2.setEncoding(encoding);
      var length = 0, chunks = [];
      return stream2.on("data", function(chunk) {
        chunks.push(chunk), objectMode ? length = chunks.length : length += chunk.length;
      }), stream2.getBufferedValue = function() {
        return array ? chunks : isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      }, stream2.getBufferedLength = function() {
        return length;
      }, stream2;
    };
  }
});

// ../../node_modules/execa/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "../../node_modules/execa/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _construct4(Parent, args, Class) {
      return _is_native_reflect_construct10() ? _construct4 = Reflect.construct : _construct4 = function(Parent2, args2, Class2) {
        var a = [
          null
        ];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
        return Class2 && _set_prototype_of10(instance, Class2.prototype), instance;
      }, _construct4.apply(null, arguments);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _is_native_function4(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _wrap_native_super4(Class) {
      var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return _wrap_native_super4 = function(Class2) {
        if (Class2 === null || !_is_native_function4(Class2))
          return Class2;
        if (typeof Class2 != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache < "u") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct4(Class2, arguments, _get_prototype_of10(this).constructor);
        }
        return Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), _set_prototype_of10(Wrapper, Class2);
      }, _wrap_native_super4(Class);
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var _require = require("buffer"), BufferConstants = _require.constants, stream2 = require("stream"), promisify2 = require("util").promisify, bufferStream = require_buffer_stream(), streamPipelinePromisified = promisify2(stream2.pipeline), MaxBufferError = /* @__PURE__ */ function(Error1) {
      _inherits10(MaxBufferError2, Error1);
      var _super = _create_super10(MaxBufferError2);
      function MaxBufferError2() {
        _class_call_check15(this, MaxBufferError2);
        var _this;
        return _this = _super.call(this, "maxBuffer exceeded"), _this.name = "MaxBufferError", _this;
      }
      return MaxBufferError2;
    }(_wrap_native_super4(Error));
    function getStream(inputStream, options) {
      return _getStream.apply(this, arguments);
    }
    function _getStream() {
      return _getStream = _async_to_generator31(function(inputStream, options) {
        var maxBuffer, stream3;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (!inputStream)
                throw new Error("Expected a stream");
              return options = _object_spread13({
                maxBuffer: 1 / 0
              }, options), maxBuffer = options.maxBuffer, stream3 = bufferStream(options), [
                4,
                new Promise(function(resolve7, reject) {
                  var rejectPromise = function(error) {
                    error && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH && (error.bufferedData = stream3.getBufferedValue()), reject(error);
                  };
                  _async_to_generator31(function() {
                    var error;
                    return _ts_generator31(this, function(_state2) {
                      switch (_state2.label) {
                        case 0:
                          return _state2.trys.push([
                            0,
                            2,
                            ,
                            3
                          ]), [
                            4,
                            streamPipelinePromisified(inputStream, stream3)
                          ];
                        case 1:
                          return _state2.sent(), resolve7(), [
                            3,
                            3
                          ];
                        case 2:
                          return error = _state2.sent(), rejectPromise(error), [
                            3,
                            3
                          ];
                        case 3:
                          return [
                            2
                          ];
                      }
                    });
                  })(), stream3.on("data", function() {
                    stream3.getBufferedLength() > maxBuffer && rejectPromise(new MaxBufferError());
                  });
                })
              ];
            case 1:
              return _state.sent(), [
                2,
                stream3.getBufferedValue()
              ];
          }
        });
      }), _getStream.apply(this, arguments);
    }
    module2.exports = getStream;
    module2.exports.buffer = function(stream3, options) {
      return getStream(stream3, _object_spread_props9(_object_spread13({}, options), {
        encoding: "buffer"
      }));
    };
    module2.exports.array = function(stream3, options) {
      return getStream(stream3, _object_spread_props9(_object_spread13({}, options), {
        array: !0
      }));
    };
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// ../../node_modules/merge-stream/index.js
var require_merge_stream = __commonJS({
  "../../node_modules/merge-stream/index.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    module2.exports = function() {
      var sources = [], output = new PassThrough({
        objectMode: !0
      });
      return output.setMaxListeners(0), output.add = add, output.isEmpty = isEmpty, output.on("unpipe", remove2), Array.prototype.slice.call(arguments).forEach(add), output;
      function add(source) {
        return Array.isArray(source) ? (source.forEach(add), this) : (sources.push(source), source.once("end", remove2.bind(null, source)), source.once("error", output.emit.bind(output, "error")), source.pipe(output, {
          end: !1
        }), this);
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove2(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        }), !sources.length && output.readable && output.end();
      }
    };
  }
});

// ../../node_modules/execa/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/execa/lib/stream.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var isStream3 = require_is_stream(), getStream = require_get_stream(), mergeStream = require_merge_stream(), handleInput = function(spawned, input) {
      input === void 0 || spawned.stdin === void 0 || (isStream3(input) ? input.pipe(spawned.stdin) : spawned.stdin.end(input));
    }, makeAllStream = function(spawned, param) {
      var all = param.all;
      if (!(!all || !spawned.stdout && !spawned.stderr)) {
        var mixed = mergeStream();
        return spawned.stdout && mixed.add(spawned.stdout), spawned.stderr && mixed.add(spawned.stderr), mixed;
      }
    }, getBufferedData = function() {
      var _ref = _async_to_generator31(function(stream2, streamPromise) {
        var error;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (!stream2)
                return [
                  2
                ];
              stream2.destroy(), _state.label = 1;
            case 1:
              return _state.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                streamPromise
              ];
            case 2:
              return [
                2,
                _state.sent()
              ];
            case 3:
              return error = _state.sent(), [
                2,
                error.bufferedData
              ];
            case 4:
              return [
                2
              ];
          }
        });
      });
      return function(stream2, streamPromise) {
        return _ref.apply(this, arguments);
      };
    }(), getStreamPromise = function(stream2, param) {
      var encoding = param.encoding, buffer = param.buffer, maxBuffer = param.maxBuffer;
      if (!(!stream2 || !buffer))
        return encoding ? getStream(stream2, {
          encoding,
          maxBuffer
        }) : getStream.buffer(stream2, {
          maxBuffer
        });
    }, getSpawnedResult = function() {
      var _ref = _async_to_generator31(function(param, param1, processDone) {
        var stdout, stderr, all, encoding, buffer, maxBuffer, stdoutPromise, stderrPromise, allPromise, error;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              stdout = param.stdout, stderr = param.stderr, all = param.all, encoding = param1.encoding, buffer = param1.buffer, maxBuffer = param1.maxBuffer, stdoutPromise = getStreamPromise(stdout, {
                encoding,
                buffer,
                maxBuffer
              }), stderrPromise = getStreamPromise(stderr, {
                encoding,
                buffer,
                maxBuffer
              }), allPromise = getStreamPromise(all, {
                encoding,
                buffer,
                maxBuffer: maxBuffer * 2
              }), _state.label = 1;
            case 1:
              return _state.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                Promise.all([
                  processDone,
                  stdoutPromise,
                  stderrPromise,
                  allPromise
                ])
              ];
            case 2:
              return [
                2,
                _state.sent()
              ];
            case 3:
              return error = _state.sent(), [
                2,
                Promise.all([
                  {
                    error,
                    signal: error.signal,
                    timedOut: error.timedOut
                  },
                  getBufferedData(stdout, stdoutPromise),
                  getBufferedData(stderr, stderrPromise),
                  getBufferedData(all, allPromise)
                ])
              ];
            case 4:
              return [
                2
              ];
          }
        });
      });
      return function(_, _1, processDone) {
        return _ref.apply(this, arguments);
      };
    }(), validateInputSync = function(param) {
      var input = param.input;
      if (isStream3(input))
        throw new TypeError("The `input` option cannot be a stream in sync mode");
    };
    module2.exports = {
      handleInput,
      makeAllStream,
      getSpawnedResult,
      validateInputSync
    };
  }
});

// ../../node_modules/execa/lib/promise.js
var require_promise = __commonJS({
  "../../node_modules/execa/lib/promise.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var nativePromisePrototype = _async_to_generator31(function() {
      return _ts_generator31(this, function(_state) {
        return [
          2
        ];
      });
    })().constructor.prototype, descriptors = [
      "then",
      "catch",
      "finally"
    ].map(function(property) {
      return [
        property,
        Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
      ];
    }), mergePromise = function(spawned, promise) {
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _loop = function() {
          var _step_value = _sliced_to_array15(_step.value, 2), property = _step_value[0], descriptor = _step_value[1], value = typeof promise == "function" ? function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
              args[_key] = arguments[_key];
            return Reflect.apply(descriptor.value, promise(), args);
          } : descriptor.value.bind(promise);
          Reflect.defineProperty(spawned, property, _object_spread_props9(_object_spread13({}, descriptor), {
            value
          }));
        }, _iterator = descriptors[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0)
          _loop();
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return spawned;
    }, getSpawnedPromise = function(spawned) {
      return new Promise(function(resolve7, reject) {
        spawned.on("exit", function(exitCode, signal) {
          resolve7({
            exitCode,
            signal
          });
        }), spawned.on("error", function(error) {
          reject(error);
        }), spawned.stdin && spawned.stdin.on("error", function(error) {
          reject(error);
        });
      });
    };
    module2.exports = {
      mergePromise,
      getSpawnedPromise
    };
  }
});

// ../../node_modules/execa/lib/command.js
var require_command = __commonJS({
  "../../node_modules/execa/lib/command.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var normalizeArgs = function(file) {
      var args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return Array.isArray(args) ? [
        file
      ].concat(_to_consumable_array16(args)) : [
        file
      ];
    }, NO_ESCAPE_REGEXP = /^[\w.-]+$/, DOUBLE_QUOTES_REGEXP = /"/g, escapeArg = function(arg) {
      return typeof arg != "string" || NO_ESCAPE_REGEXP.test(arg) ? arg : '"'.concat(arg.replace(DOUBLE_QUOTES_REGEXP, '\\"'), '"');
    }, joinCommand = function(file, args) {
      return normalizeArgs(file, args).join(" ");
    }, getEscapedCommand = function(file, args) {
      return normalizeArgs(file, args).map(function(arg) {
        return escapeArg(arg);
      }).join(" ");
    }, SPACES_REGEXP = / +/g, parseCommand = function(command) {
      var tokens = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = command.trim().split(SPACES_REGEXP)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var token = _step.value, previousToken = tokens[tokens.length - 1];
          previousToken && previousToken.endsWith("\\") ? tokens[tokens.length - 1] = "".concat(previousToken.slice(0, -1), " ").concat(token) : tokens.push(token);
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return tokens;
    };
    module2.exports = {
      joinCommand,
      getEscapedCommand,
      parseCommand
    };
  }
});

// ../../node_modules/execa/index.js
var require_execa = __commonJS({
  "../../node_modules/execa/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _to_array2(arr) {
      return _array_with_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_rest16();
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var path6 = require("path"), childProcess = require("child_process"), crossSpawn = require_cross_spawn(), stripFinalNewline = require_strip_final_newline(), npmRunPath = require_npm_run_path(), onetime = require_onetime(), makeError = require_error(), normalizeStdio = require_stdio(), _require = require_kill(), spawnedKill = _require.spawnedKill, spawnedCancel = _require.spawnedCancel, setupTimeout = _require.setupTimeout, validateTimeout = _require.validateTimeout, setExitHandler = _require.setExitHandler, _require1 = require_stream(), handleInput = _require1.handleInput, getSpawnedResult = _require1.getSpawnedResult, makeAllStream = _require1.makeAllStream, validateInputSync = _require1.validateInputSync, _require2 = require_promise(), mergePromise = _require2.mergePromise, getSpawnedPromise = _require2.getSpawnedPromise, _require3 = require_command(), joinCommand = _require3.joinCommand, parseCommand = _require3.parseCommand, getEscapedCommand = _require3.getEscapedCommand, DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100, getEnv = function(param) {
      var envOption = param.env, extendEnv = param.extendEnv, preferLocal = param.preferLocal, localDir = param.localDir, execPath = param.execPath, env2 = extendEnv ? _object_spread13({}, process.env, envOption) : envOption;
      return preferLocal ? npmRunPath.env({
        env: env2,
        cwd: localDir,
        execPath
      }) : env2;
    }, handleArguments = function(file, args) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, parsed = crossSpawn._parse(file, args, options);
      return file = parsed.command, args = parsed.args, options = parsed.options, options = _object_spread13({
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: !0,
        stripFinalNewline: !0,
        extendEnv: !0,
        preferLocal: !1,
        localDir: options.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: !0,
        cleanup: !0,
        all: !1,
        windowsHide: !0
      }, options), options.env = getEnv(options), options.stdio = normalizeStdio(options), process.platform === "win32" && path6.basename(file, ".exe") === "cmd" && args.unshift("/q"), {
        file,
        args,
        options,
        parsed
      };
    }, handleOutput = function(options, value, error) {
      return typeof value != "string" && !Buffer.isBuffer(value) ? error === void 0 ? void 0 : "" : options.stripFinalNewline ? stripFinalNewline(value) : value;
    }, execa2 = function(file, args, options) {
      var parsed = handleArguments(file, args, options), command = joinCommand(file, args), escapedCommand = getEscapedCommand(file, args);
      validateTimeout(parsed.options);
      var spawned;
      try {
        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        var dummySpawned = new childProcess.ChildProcess(), errorPromise = Promise.reject(makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: !1,
          isCanceled: !1,
          killed: !1
        }));
        return mergePromise(dummySpawned, errorPromise);
      }
      var spawnedPromise = getSpawnedPromise(spawned), timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise), processDone = setExitHandler(spawned, parsed.options, timedPromise), context = {
        isCanceled: !1
      };
      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned)), spawned.cancel = spawnedCancel.bind(null, spawned, context);
      var handlePromise = function() {
        var _ref = _async_to_generator31(function() {
          var _ref2, _ref_, _$error, exitCode, signal, timedOut, stdoutResult, stderrResult, allResult, stdout, stderr, all, returnedError;
          return _ts_generator31(this, function(_state) {
            switch (_state.label) {
              case 0:
                return [
                  4,
                  getSpawnedResult(spawned, parsed.options, processDone)
                ];
              case 1:
                if (_ref2 = _sliced_to_array15.apply(void 0, [
                  _state.sent(),
                  4
                ]), _ref_ = _ref2[0], _$error = _ref_.error, exitCode = _ref_.exitCode, signal = _ref_.signal, timedOut = _ref_.timedOut, stdoutResult = _ref2[1], stderrResult = _ref2[2], allResult = _ref2[3], stdout = handleOutput(parsed.options, stdoutResult), stderr = handleOutput(parsed.options, stderrResult), all = handleOutput(parsed.options, allResult), _$error || exitCode !== 0 || signal !== null) {
                  if (returnedError = makeError({
                    error: _$error,
                    exitCode,
                    signal,
                    stdout,
                    stderr,
                    all,
                    command,
                    escapedCommand,
                    parsed,
                    timedOut,
                    isCanceled: context.isCanceled,
                    killed: spawned.killed
                  }), !parsed.options.reject)
                    return [
                      2,
                      returnedError
                    ];
                  throw returnedError;
                }
                return [
                  2,
                  {
                    command,
                    escapedCommand,
                    exitCode: 0,
                    stdout,
                    stderr,
                    all,
                    failed: !1,
                    timedOut: !1,
                    isCanceled: !1,
                    killed: !1
                  }
                ];
            }
          });
        });
        return function() {
          return _ref.apply(this, arguments);
        };
      }(), handlePromiseOnce = onetime(handlePromise);
      return handleInput(spawned, parsed.options.input), spawned.all = makeAllStream(spawned, parsed.options), mergePromise(spawned, handlePromiseOnce);
    };
    module2.exports = execa2;
    module2.exports.sync = function(file, args, options) {
      var parsed = handleArguments(file, args, options), command = joinCommand(file, args), escapedCommand = getEscapedCommand(file, args);
      validateInputSync(parsed.options);
      var result;
      try {
        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        throw makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: !1,
          isCanceled: !1,
          killed: !1
        });
      }
      var stdout = handleOutput(parsed.options, result.stdout, result.error), stderr = handleOutput(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        var _$error = makeError({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          escapedCommand,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: !1,
          killed: result.signal !== null
        });
        if (!parsed.options.reject)
          return _$error;
        throw _$error;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: !1,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      };
    };
    module2.exports.command = function(command, options) {
      var _parseCommand = _to_array2(parseCommand(command)), file = _parseCommand[0], args = _parseCommand.slice(1);
      return execa2(file, args, options);
    };
    module2.exports.commandSync = function(command, options) {
      var _parseCommand = _to_array2(parseCommand(command)), file = _parseCommand[0], args = _parseCommand.slice(1);
      return execa2.sync(file, args, options);
    };
    module2.exports.node = function(scriptPath, args) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      args && !Array.isArray(args) && typeof args == "object" && (options = args, args = []);
      var stdio = normalizeStdio.node(options), defaultExecArgv = process.execArgv.filter(function(arg) {
        return !arg.startsWith("--inspect");
      }), _options_nodePath = options.nodePath, nodePath2 = _options_nodePath === void 0 ? process.execPath : _options_nodePath, _options_nodeOptions = options.nodeOptions, nodeOptions = _options_nodeOptions === void 0 ? defaultExecArgv : _options_nodeOptions;
      return execa2(nodePath2, _to_consumable_array16(nodeOptions).concat([
        scriptPath
      ], _to_consumable_array16(Array.isArray(args) ? args : [])), _object_spread_props9(_object_spread13({}, options), {
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio,
        shell: !1
      }));
    };
  }
});

// ../../node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/universalify/index.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        for (var _this = this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        if (typeof args[args.length - 1] == "function")
          fn.apply(this, args);
        else
          return new Promise(function(resolve7, reject) {
            var _fn;
            (_fn = fn).call.apply(_fn, [
              _this
            ].concat(_to_consumable_array16(args), [
              function(err, res) {
                return err != null ? reject(err) : resolve7(res);
              }
            ]));
          });
      }, "name", {
        value: fn.name
      });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        var cb = args[args.length - 1];
        if (typeof cb != "function")
          return fn.apply(this, args);
        fn.apply(this, args.slice(0, -1)).then(function(r) {
          return cb(null, r);
        }, cb);
      }, "name", {
        value: fn.name
      });
    };
  }
});

// ../../node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants"), origCwd = process.cwd, cwd2 = null, platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      return cwd2 || (cwd2 = origCwd.call(process)), cwd2;
    };
    try {
      process.cwd();
    } catch {
    }
    typeof process.chdir == "function" && (chdir = process.chdir, process.chdir = function(d) {
      cwd2 = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir));
    var chdir;
    module2.exports = patch;
    function patch(fs7) {
      constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs7), fs7.lutimes || patchLutimes(fs7), fs7.chown = chownFix(fs7.chown), fs7.fchown = chownFix(fs7.fchown), fs7.lchown = chownFix(fs7.lchown), fs7.chmod = chmodFix(fs7.chmod), fs7.fchmod = chmodFix(fs7.fchmod), fs7.lchmod = chmodFix(fs7.lchmod), fs7.chownSync = chownFixSync(fs7.chownSync), fs7.fchownSync = chownFixSync(fs7.fchownSync), fs7.lchownSync = chownFixSync(fs7.lchownSync), fs7.chmodSync = chmodFixSync(fs7.chmodSync), fs7.fchmodSync = chmodFixSync(fs7.fchmodSync), fs7.lchmodSync = chmodFixSync(fs7.lchmodSync), fs7.stat = statFix(fs7.stat), fs7.fstat = statFix(fs7.fstat), fs7.lstat = statFix(fs7.lstat), fs7.statSync = statFixSync(fs7.statSync), fs7.fstatSync = statFixSync(fs7.fstatSync), fs7.lstatSync = statFixSync(fs7.lstatSync), fs7.chmod && !fs7.lchmod && (fs7.lchmod = function(path6, mode, cb) {
        cb && process.nextTick(cb);
      }, fs7.lchmodSync = function() {
      }), fs7.chown && !fs7.lchown && (fs7.lchown = function(path6, uid, gid, cb) {
        cb && process.nextTick(cb);
      }, fs7.lchownSync = function() {
      }), platform === "win32" && (fs7.rename = typeof fs7.rename != "function" ? fs7.rename : function(fs$rename) {
        function rename3(from, to, cb) {
          var start = Date.now(), backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs7.stat(to, function(stater, st) {
                  stater && stater.code === "ENOENT" ? fs$rename(from, to, CB) : cb(er);
                });
              }, backoff), backoff < 100 && (backoff += 10);
              return;
            }
            cb && cb(er);
          });
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(rename3, fs$rename), rename3;
      }(fs7.rename)), fs7.read = typeof fs7.read != "function" ? fs7.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ == "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10)
                return eagCounter++, fs$read.call(fs7, fd, buffer, offset, length, position, callback);
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs7, fd, buffer, offset, length, position, callback);
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(read, fs$read), read;
      }(fs7.read), fs7.readSync = typeof fs7.readSync != "function" ? fs7.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          for (var eagCounter = 0; ; )
            try {
              return fs$readSync.call(fs7, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
        };
      }(fs7.readSync);
      function patchLchmod(fs8) {
        fs8.lchmod = function(path6, mode, callback) {
          fs8.open(path6, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              callback && callback(err);
              return;
            }
            fs8.fchmod(fd, mode, function(err2) {
              fs8.close(fd, function(err22) {
                callback && callback(err2 || err22);
              });
            });
          });
        }, fs8.lchmodSync = function(path6, mode) {
          var fd = fs8.openSync(path6, constants.O_WRONLY | constants.O_SYMLINK, mode), threw = !0, ret;
          try {
            ret = fs8.fchmodSync(fd, mode), threw = !1;
          } finally {
            if (threw)
              try {
                fs8.closeSync(fd);
              } catch {
              }
            else
              fs8.closeSync(fd);
          }
          return ret;
        };
      }
      function patchLutimes(fs8) {
        constants.hasOwnProperty("O_SYMLINK") && fs8.futimes ? (fs8.lutimes = function(path6, at, mt, cb) {
          fs8.open(path6, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              cb && cb(er);
              return;
            }
            fs8.futimes(fd, at, mt, function(er2) {
              fs8.close(fd, function(er22) {
                cb && cb(er2 || er22);
              });
            });
          });
        }, fs8.lutimesSync = function(path6, at, mt) {
          var fd = fs8.openSync(path6, constants.O_SYMLINK), ret, threw = !0;
          try {
            ret = fs8.futimesSync(fd, at, mt), threw = !1;
          } finally {
            if (threw)
              try {
                fs8.closeSync(fd);
              } catch {
              }
            else
              fs8.closeSync(fd);
          }
          return ret;
        }) : fs8.futimes && (fs8.lutimes = function(_a, _b, _c, cb) {
          cb && process.nextTick(cb);
        }, fs8.lutimesSync = function() {
        });
      }
      function chmodFix(orig) {
        return orig && function(target, mode, cb) {
          return orig.call(fs7, target, mode, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        return orig && function(target, mode) {
          try {
            return orig.call(fs7, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        return orig && function(target, uid, gid, cb) {
          return orig.call(fs7, target, uid, gid, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        return orig && function(target, uid, gid) {
          try {
            return orig.call(fs7, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        return orig && function(target, options, cb) {
          typeof options == "function" && (cb = options, options = null);
          function callback(er, stats) {
            stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
          }
          return options ? orig.call(fs7, target, options, callback) : orig.call(fs7, target, callback);
        };
      }
      function statFixSync(orig) {
        return orig && function(target, options) {
          var stats = options ? orig.call(fs7, target, options) : orig.call(fs7, target);
          return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
        };
      }
      function chownErOk(er) {
        if (!er || er.code === "ENOSYS")
          return !0;
        var nonroot = !process.getuid || process.getuid() !== 0;
        return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
      }
    }
  }
});

// ../../node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var Stream3 = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs7) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path6, options) {
        if (!_instanceof13(this, ReadStream))
          return new ReadStream(path6, options);
        Stream3.call(this);
        var self = this;
        this.path = path6, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.end === void 0)
            this.end = 1 / 0;
          else if (typeof this.end != "number")
            throw TypeError("end must be a Number");
          if (this.start > this.end)
            throw new Error("start must be <= end");
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs7.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err), self.readable = !1;
            return;
          }
          self.fd = fd, self.emit("open", fd), self._read();
        });
      }
      function WriteStream(path6, options) {
        if (!_instanceof13(this, WriteStream))
          return new WriteStream(path6, options);
        Stream3.call(this), this.path = path6, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.start < 0)
            throw new Error("start must be >= zero");
          this.pos = this.start;
        }
        this.busy = !1, this._queue = [], this.fd === null && (this._open = fs7.open, this._queue.push([
          this._open,
          this.path,
          this.flags,
          this.mode,
          void 0
        ]), this.flush());
      }
    }
  }
});

// ../../node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj != "object")
        return obj;
      if (_instanceof13(obj, Object))
        var copy2 = {
          __proto__: getPrototypeOf(obj)
        };
      else
        var copy2 = /* @__PURE__ */ Object.create(null);
      return Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
      }), copy2;
    }
  }
});

// ../../node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var fs7 = require("fs"), polyfills = require_polyfills(), legacy = require_legacy_streams(), clone = require_clone(), util = require("util"), gracefulQueue, previousSymbol;
    typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
    function noop2() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop2;
    util.debuglog ? debug = util.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
    });
    fs7[gracefulQueue] || (queue = global[gracefulQueue] || [], publishQueue(fs7, queue), fs7.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs7, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs7.close), fs7.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs7, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs7.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug(fs7[gracefulQueue]), require("assert").equal(fs7[gracefulQueue].length, 0);
    }));
    var queue;
    global[gracefulQueue] || publishQueue(global, fs7[gracefulQueue]);
    module2.exports = patch(clone(fs7));
    process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs7.__patched && (module2.exports = patch(fs7), fs7.__patched = !0);
    function patch(fs8) {
      polyfills(fs8), fs8.gracefulify = patch, fs8.createReadStream = createReadStream, fs8.createWriteStream = createWriteStream;
      var fs$readFile = fs8.readFile;
      fs8.readFile = readFile;
      function readFile(path6, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$readFile(path6, options, cb);
        function go$readFile(path7, options2, cb2, startTime) {
          return fs$readFile(path7, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$readFile,
              [
                path7,
                options2,
                cb2
              ],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$writeFile = fs8.writeFile;
      fs8.writeFile = writeFile;
      function writeFile(path6, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$writeFile(path6, data, options, cb);
        function go$writeFile(path7, data2, options2, cb2, startTime) {
          return fs$writeFile(path7, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$writeFile,
              [
                path7,
                data2,
                options2,
                cb2
              ],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$appendFile = fs8.appendFile;
      fs$appendFile && (fs8.appendFile = appendFile);
      function appendFile(path6, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$appendFile(path6, data, options, cb);
        function go$appendFile(path7, data2, options2, cb2, startTime) {
          return fs$appendFile(path7, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$appendFile,
              [
                path7,
                data2,
                options2,
                cb2
              ],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$copyFile = fs8.copyFile;
      fs$copyFile && (fs8.copyFile = copyFile);
      function copyFile(src, dest, flags, cb) {
        return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$copyFile,
              [
                src2,
                dest2,
                flags2,
                cb2
              ],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$readdir = fs8.readdir;
      fs8.readdir = readdir4;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir4(path6, options, cb) {
        typeof options == "function" && (cb = options, options = null);
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path7, options2, cb2, startTime) {
          return fs$readdir(path7, fs$readdirCallback(path7, options2, cb2, startTime));
        } : function(path7, options2, cb2, startTime) {
          return fs$readdir(path7, options2, fs$readdirCallback(path7, options2, cb2, startTime));
        };
        return go$readdir(path6, options, cb);
        function fs$readdirCallback(path7, options2, cb2, startTime) {
          return function(err, files) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$readdir,
              [
                path7,
                options2,
                cb2
              ],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs8);
        ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs8.ReadStream;
      fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
      var fs$WriteStream = fs8.WriteStream;
      fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs8, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(fs8, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs8, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs8, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      function ReadStream(path6, options) {
        return _instanceof13(this, ReadStream) ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
        });
      }
      function WriteStream(path6, options) {
        return _instanceof13(this, WriteStream) ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
        });
      }
      function createReadStream(path6, options) {
        return new fs8.ReadStream(path6, options);
      }
      function createWriteStream(path6, options) {
        return new fs8.WriteStream(path6, options);
      }
      var fs$open = fs8.open;
      fs8.open = open3;
      function open3(path6, flags, mode, cb) {
        return typeof mode == "function" && (cb = mode, mode = null), go$open(path6, flags, mode, cb);
        function go$open(path7, flags2, mode2, cb2, startTime) {
          return fs$open(path7, flags2, mode2, function(err, fd) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$open,
              [
                path7,
                flags2,
                mode2,
                cb2
              ],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      return fs8;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]), fs7[gracefulQueue].push(elem), retry();
    }
    var retryTimer;
    function resetQueue() {
      for (var now = Date.now(), i = 0; i < fs7[gracefulQueue].length; ++i)
        fs7[gracefulQueue][i].length > 2 && (fs7[gracefulQueue][i][3] = now, fs7[gracefulQueue][i][4] = now);
      retry();
    }
    function retry() {
      if (clearTimeout(retryTimer), retryTimer = void 0, fs7[gracefulQueue].length !== 0) {
        var elem = fs7[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
        if (startTime === void 0)
          debug("RETRY", fn.name, args), fn.apply(null, args);
        else if (Date.now() - startTime >= 6e4) {
          debug("TIMEOUT", fn.name, args);
          var cb = args.pop();
          typeof cb == "function" && cb.call(null, err);
        } else {
          var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
          sinceAttempt >= desiredDelay ? (debug("RETRY", fn.name, args), fn.apply(null, args.concat([
            startTime
          ]))) : fs7[gracefulQueue].push(elem);
        }
        retryTimer === void 0 && (retryTimer = setTimeout(retry, 0));
      }
    }
  }
});

// ../../node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var u = require_universalify().fromCallback, fs7 = require_graceful_fs(), api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter(function(key) {
      return typeof fs7[key] == "function";
    });
    Object.assign(exports2, fs7);
    api.forEach(function(method) {
      exports2[method] = u(fs7[method]);
    });
    exports2.exists = function(filename, callback) {
      return typeof callback == "function" ? fs7.exists(filename, callback) : new Promise(function(resolve7) {
        return fs7.exists(filename, resolve7);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      return typeof callback == "function" ? fs7.read(fd, buffer, offset, length, position, callback) : new Promise(function(resolve7, reject) {
        fs7.read(fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          if (err)
            return reject(err);
          resolve7({
            bytesRead,
            buffer: buffer2
          });
        });
      });
    };
    exports2.write = function(fd, buffer) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
        args[_key - 2] = arguments[_key];
      if (typeof args[args.length - 1] == "function") {
        var _fs2;
        return (_fs2 = fs7).write.apply(_fs2, [
          fd,
          buffer
        ].concat(_to_consumable_array16(args)));
      }
      return new Promise(function(resolve7, reject) {
        var _fs3;
        (_fs3 = fs7).write.apply(_fs3, [
          fd,
          buffer
        ].concat(_to_consumable_array16(args), [
          function(err, bytesWritten, buffer2) {
            if (err)
              return reject(err);
            resolve7({
              bytesWritten,
              buffer: buffer2
            });
          }
        ]));
      });
    };
    exports2.readv = function(fd, buffers) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
        args[_key - 2] = arguments[_key];
      if (typeof args[args.length - 1] == "function") {
        var _fs2;
        return (_fs2 = fs7).readv.apply(_fs2, [
          fd,
          buffers
        ].concat(_to_consumable_array16(args)));
      }
      return new Promise(function(resolve7, reject) {
        var _fs3;
        (_fs3 = fs7).readv.apply(_fs3, [
          fd,
          buffers
        ].concat(_to_consumable_array16(args), [
          function(err, bytesRead, buffers2) {
            if (err)
              return reject(err);
            resolve7({
              bytesRead,
              buffers: buffers2
            });
          }
        ]));
      });
    };
    exports2.writev = function(fd, buffers) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
        args[_key - 2] = arguments[_key];
      if (typeof args[args.length - 1] == "function") {
        var _fs2;
        return (_fs2 = fs7).writev.apply(_fs2, [
          fd,
          buffers
        ].concat(_to_consumable_array16(args)));
      }
      return new Promise(function(resolve7, reject) {
        var _fs3;
        (_fs3 = fs7).writev.apply(_fs3, [
          fd,
          buffers
        ].concat(_to_consumable_array16(args), [
          function(err, bytesWritten, buffers2) {
            if (err)
              return reject(err);
            resolve7({
              bytesWritten,
              buffers: buffers2
            });
          }
        ]));
      });
    };
    typeof fs7.realpath.native == "function" ? exports2.realpath.native = u(fs7.realpath.native) : process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/utils.js"(exports2, module2) {
    "use strict";
    var path6 = require("path");
    module2.exports.checkPath = function(pth) {
      if (process.platform === "win32") {
        var pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path6.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          var error = new Error("Path contains invalid characters: ".concat(pth));
          throw error.code = "EINVAL", error;
        }
      }
    };
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var fs7 = require_fs(), checkPath = require_utils().checkPath, getMode = function(options) {
      var defaults3 = {
        mode: 511
      };
      return typeof options == "number" ? options : _object_spread13({}, defaults3, options).mode;
    };
    module2.exports.makeDir = function() {
      var _ref = _async_to_generator31(function(dir, options) {
        return _ts_generator31(this, function(_state) {
          return checkPath(dir), [
            2,
            fs7.mkdir(dir, {
              mode: getMode(options),
              recursive: !0
            })
          ];
        });
      });
      return function(dir, options) {
        return _ref.apply(this, arguments);
      };
    }();
    module2.exports.makeDirSync = function(dir, options) {
      return checkPath(dir), fs7.mkdirSync(dir, {
        mode: getMode(options),
        recursive: !0
      });
    };
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, _require = require_make_dir(), _makeDir = _require.makeDir, makeDirSync = _require.makeDirSync, makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, fs7 = require_fs();
    function pathExists3(path6) {
      return fs7.access(path6).then(function() {
        return !0;
      }).catch(function() {
        return !1;
      });
    }
    module2.exports = {
      pathExists: u(pathExists3),
      pathExistsSync: fs7.existsSync
    };
  }
});

// ../../node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var fs7 = require_fs(), u = require_universalify().fromPromise;
    function utimesMillis(path6, atime, mtime) {
      return _utimesMillis.apply(this, arguments);
    }
    function _utimesMillis() {
      return _utimesMillis = _async_to_generator31(function(path6, atime, mtime) {
        var fd, closeErr, e;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                fs7.open(path6, "r+")
              ];
            case 1:
              fd = _state.sent(), closeErr = null, _state.label = 2;
            case 2:
              return _state.trys.push([
                2,
                ,
                4,
                8
              ]), [
                4,
                fs7.futimes(fd, atime, mtime)
              ];
            case 3:
              return _state.sent(), [
                3,
                8
              ];
            case 4:
              return _state.trys.push([
                4,
                6,
                ,
                7
              ]), [
                4,
                fs7.close(fd)
              ];
            case 5:
              return _state.sent(), [
                3,
                7
              ];
            case 6:
              return e = _state.sent(), closeErr = e, [
                3,
                7
              ];
            case 7:
              return [
                7
              ];
            case 8:
              if (closeErr)
                throw closeErr;
              return [
                2
              ];
          }
        });
      }), _utimesMillis.apply(this, arguments);
    }
    function utimesMillisSync(path6, atime, mtime) {
      var fd = fs7.openSync(path6, "r+");
      return fs7.futimesSync(fd, atime, mtime), fs7.closeSync(fd);
    }
    module2.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// ../../node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../../node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var fs7 = require_fs(), path6 = require("path"), u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      var statFunc = opts.dereference ? function(file) {
        return fs7.stat(file, {
          bigint: !0
        });
      } : function(file) {
        return fs7.lstat(file, {
          bigint: !0
        });
      };
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch(function(err) {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(function(param) {
        var _param = _sliced_to_array15(param, 2), srcStat = _param[0], destStat = _param[1];
        return {
          srcStat,
          destStat
        };
      });
    }
    function getStatsSync(src, dest, opts) {
      var destStat, statFunc = opts.dereference ? function(file) {
        return fs7.statSync(file, {
          bigint: !0
        });
      } : function(file) {
        return fs7.lstatSync(file, {
          bigint: !0
        });
      }, srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return {
            srcStat,
            destStat: null
          };
        throw err;
      }
      return {
        srcStat,
        destStat
      };
    }
    function checkPaths(src, dest, funcName, opts) {
      return _checkPaths.apply(this, arguments);
    }
    function _checkPaths() {
      return _checkPaths = _async_to_generator31(function(src, dest, funcName, opts) {
        var _ref, srcStat, destStat, srcBaseName, destBaseName;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                getStats(src, dest, opts)
              ];
            case 1:
              if (_ref = _state.sent(), srcStat = _ref.srcStat, destStat = _ref.destStat, destStat) {
                if (areIdentical(srcStat, destStat)) {
                  if (srcBaseName = path6.basename(src), destBaseName = path6.basename(dest), funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase())
                    return [
                      2,
                      {
                        srcStat,
                        destStat,
                        isChangingCase: !0
                      }
                    ];
                  throw new Error("Source and destination must not be the same.");
                }
                if (srcStat.isDirectory() && !destStat.isDirectory())
                  throw new Error("Cannot overwrite non-directory '".concat(dest, "' with directory '").concat(src, "'."));
                if (!srcStat.isDirectory() && destStat.isDirectory())
                  throw new Error("Cannot overwrite directory '".concat(dest, "' with non-directory '").concat(src, "'."));
              }
              if (srcStat.isDirectory() && isSrcSubdir(src, dest))
                throw new Error(errMsg(src, dest, funcName));
              return [
                2,
                {
                  srcStat,
                  destStat
                }
              ];
          }
        });
      }), _checkPaths.apply(this, arguments);
    }
    function checkPathsSync(src, dest, funcName, opts) {
      var _getStatsSync = getStatsSync(src, dest, opts), srcStat = _getStatsSync.srcStat, destStat = _getStatsSync.destStat;
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          var srcBaseName = path6.basename(src), destBaseName = path6.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase())
            return {
              srcStat,
              destStat,
              isChangingCase: !0
            };
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory())
          throw new Error("Cannot overwrite non-directory '".concat(dest, "' with directory '").concat(src, "'."));
        if (!srcStat.isDirectory() && destStat.isDirectory())
          throw new Error("Cannot overwrite directory '".concat(dest, "' with non-directory '").concat(src, "'."));
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest))
        throw new Error(errMsg(src, dest, funcName));
      return {
        srcStat,
        destStat
      };
    }
    function checkParentPaths(src, srcStat, dest, funcName) {
      return _checkParentPaths.apply(this, arguments);
    }
    function _checkParentPaths() {
      return _checkParentPaths = // recursively check if dest parent is a subdirectory of src.
      // It works for all file types including symlinks since it
      // checks the src and dest inodes. It starts from the deepest
      // parent and stops once it reaches the src parent or the root path.
      _async_to_generator31(function(src, srcStat, dest, funcName) {
        var srcParent, destParent, destStat, err;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (srcParent = path6.resolve(path6.dirname(src)), destParent = path6.resolve(path6.dirname(dest)), destParent === srcParent || destParent === path6.parse(destParent).root)
                return [
                  2
                ];
              _state.label = 1;
            case 1:
              return _state.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                fs7.stat(destParent, {
                  bigint: !0
                })
              ];
            case 2:
              return destStat = _state.sent(), [
                3,
                4
              ];
            case 3:
              if (err = _state.sent(), err.code === "ENOENT")
                return [
                  2
                ];
              throw err;
            case 4:
              if (areIdentical(srcStat, destStat))
                throw new Error(errMsg(src, dest, funcName));
              return [
                2,
                checkParentPaths(src, srcStat, destParent, funcName)
              ];
          }
        });
      }), _checkParentPaths.apply(this, arguments);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      var srcParent = path6.resolve(path6.dirname(src)), destParent = path6.resolve(path6.dirname(dest));
      if (!(destParent === srcParent || destParent === path6.parse(destParent).root)) {
        var destStat;
        try {
          destStat = fs7.statSync(destParent, {
            bigint: !0
          });
        } catch (err) {
          if (err.code === "ENOENT")
            return;
          throw err;
        }
        if (areIdentical(srcStat, destStat))
          throw new Error(errMsg(src, dest, funcName));
        return checkParentPathsSync(src, srcStat, destParent, funcName);
      }
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      var srcArr = path6.resolve(src).split(path6.sep).filter(function(i) {
        return i;
      }), destArr = path6.resolve(dest).split(path6.sep).filter(function(i) {
        return i;
      });
      return srcArr.every(function(cur, i) {
        return destArr[i] === cur;
      });
    }
    function errMsg(src, dest, funcName) {
      return "Cannot ".concat(funcName, " '").concat(src, "' to a subdirectory of itself, '").concat(dest, "'.");
    }
    module2.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var fs7 = require_fs(), path6 = require("path"), mkdirs = require_mkdirs().mkdirs, pathExists3 = require_path_exists().pathExists, utimesMillis = require_utimes().utimesMillis, stat3 = require_stat();
    function copy2(src, dest) {
      return _copy.apply(this, arguments);
    }
    function _copy() {
      return _copy = _async_to_generator31(function(src, dest) {
        var opts, _ref, srcStat, destStat, include, destParent, dirExists, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return opts = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {}, typeof opts == "function" && (opts = {
                filter: opts
              }), opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`, "Warning", "fs-extra-WARN0001"), [
                4,
                stat3.checkPaths(src, dest, "copy", opts)
              ];
            case 1:
              return _ref = _state.sent(), srcStat = _ref.srcStat, destStat = _ref.destStat, [
                4,
                stat3.checkParentPaths(src, srcStat, dest, "copy")
              ];
            case 2:
              return _state.sent(), [
                4,
                runFilter(src, dest, opts)
              ];
            case 3:
              return include = _state.sent(), include ? (destParent = path6.dirname(dest), [
                4,
                pathExists3(destParent)
              ]) : [
                2
              ];
            case 4:
              return dirExists = _state.sent(), dirExists ? [
                3,
                6
              ] : [
                4,
                mkdirs(destParent)
              ];
            case 5:
              _state.sent(), _state.label = 6;
            case 6:
              return [
                4,
                getStatsAndPerformCopy(destStat, src, dest, opts)
              ];
            case 7:
              return _state.sent(), [
                2
              ];
          }
        });
      }), _copy.apply(this, arguments);
    }
    function runFilter(src, dest, opts) {
      return _runFilter.apply(this, arguments);
    }
    function _runFilter() {
      return _runFilter = _async_to_generator31(function(src, dest, opts) {
        return _ts_generator31(this, function(_state) {
          return opts.filter ? [
            2,
            opts.filter(src, dest)
          ] : [
            2,
            !0
          ];
        });
      }), _runFilter.apply(this, arguments);
    }
    function getStatsAndPerformCopy(destStat, src, dest, opts) {
      return _getStatsAndPerformCopy.apply(this, arguments);
    }
    function _getStatsAndPerformCopy() {
      return _getStatsAndPerformCopy = _async_to_generator31(function(destStat, src, dest, opts) {
        var statFn, srcStat;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return statFn = opts.dereference ? fs7.stat : fs7.lstat, [
                4,
                statFn(src)
              ];
            case 1:
              if (srcStat = _state.sent(), srcStat.isDirectory())
                return [
                  2,
                  onDir(srcStat, destStat, src, dest, opts)
                ];
              if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
                return [
                  2,
                  onFile(srcStat, destStat, src, dest, opts)
                ];
              if (srcStat.isSymbolicLink())
                return [
                  2,
                  onLink(destStat, src, dest, opts)
                ];
              throw srcStat.isSocket() ? new Error("Cannot copy a socket file: ".concat(src)) : srcStat.isFIFO() ? new Error("Cannot copy a FIFO pipe: ".concat(src)) : new Error("Unknown file: ".concat(src));
          }
        });
      }), _getStatsAndPerformCopy.apply(this, arguments);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      return _onFile.apply(this, arguments);
    }
    function _onFile() {
      return _onFile = _async_to_generator31(function(srcStat, destStat, src, dest, opts) {
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return destStat ? opts.overwrite ? [
                4,
                fs7.unlink(dest)
              ] : [
                3,
                2
              ] : [
                2,
                copyFile(srcStat, src, dest, opts)
              ];
            case 1:
              return _state.sent(), [
                2,
                copyFile(srcStat, src, dest, opts)
              ];
            case 2:
              if (opts.errorOnExist)
                throw new Error("'".concat(dest, "' already exists"));
              return [
                2
              ];
          }
        });
      }), _onFile.apply(this, arguments);
    }
    function copyFile(srcStat, src, dest, opts) {
      return _copyFile.apply(this, arguments);
    }
    function _copyFile() {
      return _copyFile = _async_to_generator31(function(srcStat, src, dest, opts) {
        var updatedSrcStat;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                fs7.copyFile(src, dest)
              ];
            case 1:
              return _state.sent(), opts.preserveTimestamps ? (
                // Make sure the file is writable before setting the timestamp
                // otherwise open fails with EPERM when invoked with 'r+'
                // (through utimes call)
                fileIsNotWritable(srcStat.mode) ? [
                  4,
                  makeFileWritable(dest, srcStat.mode)
                ] : [
                  3,
                  3
                ]
              ) : [
                3,
                6
              ];
            case 2:
              _state.sent(), _state.label = 3;
            case 3:
              return [
                4,
                fs7.stat(src)
              ];
            case 4:
              return updatedSrcStat = _state.sent(), [
                4,
                utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
              ];
            case 5:
              _state.sent(), _state.label = 6;
            case 6:
              return [
                2,
                fs7.chmod(dest, srcStat.mode)
              ];
          }
        });
      }), _copyFile.apply(this, arguments);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs7.chmod(dest, srcMode | 128);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      return _onDir.apply(this, arguments);
    }
    function _onDir() {
      return _onDir = _async_to_generator31(function(srcStat, destStat, src, dest, opts) {
        var items;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return destStat ? [
                3,
                2
              ] : [
                4,
                fs7.mkdir(dest)
              ];
            case 1:
              _state.sent(), _state.label = 2;
            case 2:
              return [
                4,
                fs7.readdir(src)
              ];
            case 3:
              return items = _state.sent(), [
                4,
                Promise.all(items.map(function() {
                  var _ref = _async_to_generator31(function(item) {
                    var srcItem, destItem, include, _$destStat;
                    return _ts_generator31(this, function(_state2) {
                      switch (_state2.label) {
                        case 0:
                          return srcItem = path6.join(src, item), destItem = path6.join(dest, item), [
                            4,
                            runFilter(srcItem, destItem, opts)
                          ];
                        case 1:
                          return include = _state2.sent(), include ? [
                            4,
                            stat3.checkPaths(srcItem, destItem, "copy", opts)
                          ] : [
                            2
                          ];
                        case 2:
                          return _$destStat = _state2.sent().destStat, [
                            2,
                            getStatsAndPerformCopy(_$destStat, srcItem, destItem, opts)
                          ];
                      }
                    });
                  });
                  return function(item) {
                    return _ref.apply(this, arguments);
                  };
                }()))
              ];
            case 4:
              return _state.sent(), destStat ? [
                3,
                6
              ] : [
                4,
                fs7.chmod(dest, srcStat.mode)
              ];
            case 5:
              _state.sent(), _state.label = 6;
            case 6:
              return [
                2
              ];
          }
        });
      }), _onDir.apply(this, arguments);
    }
    function onLink(destStat, src, dest, opts) {
      return _onLink.apply(this, arguments);
    }
    function _onLink() {
      return _onLink = _async_to_generator31(function(destStat, src, dest, opts) {
        var resolvedSrc, resolvedDest, e;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                fs7.readlink(src)
              ];
            case 1:
              if (resolvedSrc = _state.sent(), opts.dereference && (resolvedSrc = path6.resolve(process.cwd(), resolvedSrc)), !destStat)
                return [
                  2,
                  fs7.symlink(resolvedSrc, dest)
                ];
              resolvedDest = null, _state.label = 2;
            case 2:
              return _state.trys.push([
                2,
                4,
                ,
                5
              ]), [
                4,
                fs7.readlink(dest)
              ];
            case 3:
              return resolvedDest = _state.sent(), [
                3,
                5
              ];
            case 4:
              if (e = _state.sent(), e.code === "EINVAL" || e.code === "UNKNOWN")
                return [
                  2,
                  fs7.symlink(resolvedSrc, dest)
                ];
              throw e;
            case 5:
              if (opts.dereference && (resolvedDest = path6.resolve(process.cwd(), resolvedDest)), stat3.isSrcSubdir(resolvedSrc, resolvedDest))
                throw new Error("Cannot copy '".concat(resolvedSrc, "' to a subdirectory of itself, '").concat(resolvedDest, "'."));
              if (stat3.isSrcSubdir(resolvedDest, resolvedSrc))
                throw new Error("Cannot overwrite '".concat(resolvedDest, "' with '").concat(resolvedSrc, "'."));
              return [
                4,
                fs7.unlink(dest)
              ];
            case 6:
              return _state.sent(), [
                2,
                fs7.symlink(resolvedSrc, dest)
              ];
          }
        });
      }), _onLink.apply(this, arguments);
    }
    module2.exports = copy2;
  }
});

// ../../node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/fs-extra/lib/copy/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), path6 = require("path"), mkdirsSync = require_mkdirs().mkdirsSync, utimesMillisSync = require_utimes().utimesMillisSync, stat3 = require_stat();
    function copySync(src, dest, opts) {
      typeof opts == "function" && (opts = {
        filter: opts
      }), opts = opts || {}, opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`, "Warning", "fs-extra-WARN0002");
      var _stat_checkPathsSync = stat3.checkPathsSync(src, dest, "copy", opts), srcStat = _stat_checkPathsSync.srcStat, destStat = _stat_checkPathsSync.destStat;
      if (stat3.checkParentPathsSync(src, srcStat, dest, "copy"), !(opts.filter && !opts.filter(src, dest))) {
        var destParent = path6.dirname(dest);
        return fs7.existsSync(destParent) || mkdirsSync(destParent), getStats(destStat, src, dest, opts);
      }
    }
    function getStats(destStat, src, dest, opts) {
      var statSync2 = opts.dereference ? fs7.statSync : fs7.lstatSync, srcStat = statSync2(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      throw srcStat.isSocket() ? new Error("Cannot copy a socket file: ".concat(src)) : srcStat.isFIFO() ? new Error("Cannot copy a FIFO pipe: ".concat(src)) : new Error("Unknown file: ".concat(src));
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      return destStat ? mayCopyFile(srcStat, src, dest, opts) : copyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite)
        return fs7.unlinkSync(dest), copyFile(srcStat, src, dest, opts);
      if (opts.errorOnExist)
        throw new Error("'".concat(dest, "' already exists"));
    }
    function copyFile(srcStat, src, dest, opts) {
      return fs7.copyFileSync(src, dest), opts.preserveTimestamps && handleTimestamps(srcStat.mode, src, dest), setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      return fileIsNotWritable(srcMode) && makeFileWritable(dest, srcMode), setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs7.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      var updatedSrcStat = fs7.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      return destStat ? copyDir(src, dest, opts) : mkDirAndCopy(srcStat.mode, src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      return fs7.mkdirSync(dest), copyDir(src, dest, opts), setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs7.readdirSync(src).forEach(function(item) {
        return copyDirItem(item, src, dest, opts);
      });
    }
    function copyDirItem(item, src, dest, opts) {
      var srcItem = path6.join(src, item), destItem = path6.join(dest, item);
      if (!(opts.filter && !opts.filter(srcItem, destItem))) {
        var destStat = stat3.checkPathsSync(srcItem, destItem, "copy", opts).destStat;
        return getStats(destStat, srcItem, destItem, opts);
      }
    }
    function onLink(destStat, src, dest, opts) {
      var resolvedSrc = fs7.readlinkSync(src);
      if (opts.dereference && (resolvedSrc = path6.resolve(process.cwd(), resolvedSrc)), destStat) {
        var resolvedDest;
        try {
          resolvedDest = fs7.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs7.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference && (resolvedDest = path6.resolve(process.cwd(), resolvedDest)), stat3.isSrcSubdir(resolvedSrc, resolvedDest))
          throw new Error("Cannot copy '".concat(resolvedSrc, "' to a subdirectory of itself, '").concat(resolvedDest, "'."));
        if (stat3.isSrcSubdir(resolvedDest, resolvedSrc))
          throw new Error("Cannot overwrite '".concat(resolvedDest, "' with '").concat(resolvedSrc, "'."));
        return copyLink(resolvedSrc, dest);
      } else
        return fs7.symlinkSync(resolvedSrc, dest);
    }
    function copyLink(resolvedSrc, dest) {
      return fs7.unlinkSync(dest), fs7.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), u = require_universalify().fromCallback;
    function remove2(path6, callback) {
      fs7.rm(path6, {
        recursive: !0,
        force: !0
      }, callback);
    }
    function removeSync(path6) {
      fs7.rmSync(path6, {
        recursive: !0,
        force: !0
      });
    }
    module2.exports = {
      remove: u(remove2),
      removeSync
    };
  }
});

// ../../node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var u = require_universalify().fromPromise, fs7 = require_fs(), path6 = require("path"), mkdir2 = require_mkdirs(), remove2 = require_remove(), emptyDir = u(function() {
      var _emptyDir = _async_to_generator31(function(dir) {
        var items, e;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return _state.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                fs7.readdir(dir)
              ];
            case 1:
              return items = _state.sent(), [
                3,
                3
              ];
            case 2:
              return e = _state.sent(), [
                2,
                mkdir2.mkdirs(dir)
              ];
            case 3:
              return [
                2,
                Promise.all(items.map(function(item) {
                  return remove2.remove(path6.join(dir, item));
                }))
              ];
          }
        });
      });
      function emptyDir2(dir) {
        return _emptyDir.apply(this, arguments);
      }
      return emptyDir2;
    }());
    function emptyDirSync(dir) {
      var items;
      try {
        items = fs7.readdirSync(dir);
      } catch {
        return mkdir2.mkdirsSync(dir);
      }
      items.forEach(function(item) {
        item = path6.join(dir, item), remove2.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var u = require_universalify().fromPromise, path6 = require("path"), fs7 = require_fs(), mkdir2 = require_mkdirs();
    function createFile(file) {
      return _createFile.apply(this, arguments);
    }
    function _createFile() {
      return _createFile = _async_to_generator31(function(file) {
        var stats, e, dir, dirStats, err;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return _state.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                fs7.stat(file)
              ];
            case 1:
              return stats = _state.sent(), [
                3,
                3
              ];
            case 2:
              return e = _state.sent(), [
                3,
                3
              ];
            case 3:
              if (stats && stats.isFile())
                return [
                  2
                ];
              dir = path6.dirname(file), dirStats = null, _state.label = 4;
            case 4:
              return _state.trys.push([
                4,
                6,
                ,
                11
              ]), [
                4,
                fs7.stat(dir)
              ];
            case 5:
              return dirStats = _state.sent(), [
                3,
                11
              ];
            case 6:
              return err = _state.sent(), // if the directory doesn't exist, make it
              err.code !== "ENOENT" ? [
                3,
                9
              ] : [
                4,
                mkdir2.mkdirs(dir)
              ];
            case 7:
              return _state.sent(), [
                4,
                fs7.writeFile(file, "")
              ];
            case 8:
              return _state.sent(), [
                2
              ];
            case 9:
              throw err;
            case 10:
              return [
                3,
                11
              ];
            case 11:
              return dirStats.isDirectory() ? [
                4,
                fs7.writeFile(file, "")
              ] : [
                3,
                13
              ];
            case 12:
              return _state.sent(), [
                3,
                15
              ];
            case 13:
              return [
                4,
                fs7.readdir(dir)
              ];
            case 14:
              _state.sent(), _state.label = 15;
            case 15:
              return [
                2
              ];
          }
        });
      }), _createFile.apply(this, arguments);
    }
    function createFileSync(file) {
      var stats;
      try {
        stats = fs7.statSync(file);
      } catch {
      }
      if (!(stats && stats.isFile())) {
        var dir = path6.dirname(file);
        try {
          fs7.statSync(dir).isDirectory() || fs7.readdirSync(dir);
        } catch (err) {
          if (err && err.code === "ENOENT")
            mkdir2.mkdirsSync(dir);
          else
            throw err;
        }
        fs7.writeFileSync(file, "");
      }
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var u = require_universalify().fromPromise, path6 = require("path"), fs7 = require_fs(), mkdir2 = require_mkdirs(), pathExists3 = require_path_exists().pathExists, areIdentical = require_stat().areIdentical;
    function createLink(srcpath, dstpath) {
      return _createLink.apply(this, arguments);
    }
    function _createLink() {
      return _createLink = _async_to_generator31(function(srcpath, dstpath) {
        var dstStat, e, srcStat, err, dir, dirExists;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return _state.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                fs7.lstat(dstpath)
              ];
            case 1:
              return dstStat = _state.sent(), [
                3,
                3
              ];
            case 2:
              return e = _state.sent(), [
                3,
                3
              ];
            case 3:
              return _state.trys.push([
                3,
                5,
                ,
                6
              ]), [
                4,
                fs7.lstat(srcpath)
              ];
            case 4:
              return srcStat = _state.sent(), [
                3,
                6
              ];
            case 5:
              throw err = _state.sent(), err.message = err.message.replace("lstat", "ensureLink"), err;
            case 6:
              return dstStat && areIdentical(srcStat, dstStat) ? [
                2
              ] : (dir = path6.dirname(dstpath), [
                4,
                pathExists3(dir)
              ]);
            case 7:
              return dirExists = _state.sent(), dirExists ? [
                3,
                9
              ] : [
                4,
                mkdir2.mkdirs(dir)
              ];
            case 8:
              _state.sent(), _state.label = 9;
            case 9:
              return [
                4,
                fs7.link(srcpath, dstpath)
              ];
            case 10:
              return _state.sent(), [
                2
              ];
          }
        });
      }), _createLink.apply(this, arguments);
    }
    function createLinkSync(srcpath, dstpath) {
      var dstStat;
      try {
        dstStat = fs7.lstatSync(dstpath);
      } catch {
      }
      try {
        var srcStat = fs7.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        throw err.message = err.message.replace("lstat", "ensureLink"), err;
      }
      var dir = path6.dirname(dstpath), dirExists = fs7.existsSync(dir);
      return dirExists || mkdir2.mkdirsSync(dir), fs7.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var path6 = require("path"), fs7 = require_fs(), pathExists3 = require_path_exists().pathExists, u = require_universalify().fromPromise;
    function symlinkPaths(srcpath, dstpath) {
      return _symlinkPaths.apply(this, arguments);
    }
    function _symlinkPaths() {
      return _symlinkPaths = /**
      * Function that returns two types of paths, one relative to symlink, and one
      * relative to the current working directory. Checks if path is absolute or
      * relative. If the path is relative, this function checks if the path is
      * relative to symlink or relative to current working directory. This is an
      * initiative to find a smarter `srcpath` to supply when building symlinks.
      * This allows you to determine which path to use out of one of three possible
      * types of source paths. The first is an absolute path. This is detected by
      * `path.isAbsolute()`. When an absolute path is provided, it is checked to
      * see if it exists. If it does it's used, if not an error is returned
      * (callback)/ thrown (sync). The other two options for `srcpath` are a
      * relative url. By default Node's `fs.symlink` works by creating a symlink
      * using `dstpath` and expects the `srcpath` to be relative to the newly
      * created symlink. If you provide a `srcpath` that does not exist on the file
      * system it results in a broken symlink. To minimize this, the function
      * checks to see if the 'relative to symlink' source file exists, and if it
      * does it will use it. If it does not, it checks if there's a file that
      * exists that is relative to the current working directory, if does its used.
      * This preserves the expectations of the original fs.symlink spec and adds
      * the ability to pass in `relative to current working direcotry` paths.
      */
      _async_to_generator31(function(srcpath, dstpath) {
        var err, dstdir, relativeToDst, exists, err1;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (!path6.isAbsolute(srcpath))
                return [
                  3,
                  5
                ];
              _state.label = 1;
            case 1:
              return _state.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                fs7.lstat(srcpath)
              ];
            case 2:
              return _state.sent(), [
                3,
                4
              ];
            case 3:
              throw err = _state.sent(), err.message = err.message.replace("lstat", "ensureSymlink"), err;
            case 4:
              return [
                2,
                {
                  toCwd: srcpath,
                  toDst: srcpath
                }
              ];
            case 5:
              return dstdir = path6.dirname(dstpath), relativeToDst = path6.join(dstdir, srcpath), [
                4,
                pathExists3(relativeToDst)
              ];
            case 6:
              if (exists = _state.sent(), exists)
                return [
                  2,
                  {
                    toCwd: relativeToDst,
                    toDst: srcpath
                  }
                ];
              _state.label = 7;
            case 7:
              return _state.trys.push([
                7,
                9,
                ,
                10
              ]), [
                4,
                fs7.lstat(srcpath)
              ];
            case 8:
              return _state.sent(), [
                3,
                10
              ];
            case 9:
              throw err1 = _state.sent(), err1.message = err1.message.replace("lstat", "ensureSymlink"), err1;
            case 10:
              return [
                2,
                {
                  toCwd: srcpath,
                  toDst: path6.relative(dstdir, srcpath)
                }
              ];
          }
        });
      }), _symlinkPaths.apply(this, arguments);
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path6.isAbsolute(srcpath)) {
        var exists = fs7.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      var dstdir = path6.dirname(dstpath), relativeToDst = path6.join(dstdir, srcpath), exists1 = fs7.existsSync(relativeToDst);
      if (exists1)
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      var srcExists = fs7.existsSync(srcpath);
      if (!srcExists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path6.relative(dstdir, srcpath)
      };
    }
    module2.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var fs7 = require_fs(), u = require_universalify().fromPromise;
    function symlinkType(srcpath, type) {
      return _symlinkType.apply(this, arguments);
    }
    function _symlinkType() {
      return _symlinkType = _async_to_generator31(function(srcpath, type) {
        var stats, e;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (type)
                return [
                  2,
                  type
                ];
              _state.label = 1;
            case 1:
              return _state.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                fs7.lstat(srcpath)
              ];
            case 2:
              return stats = _state.sent(), [
                3,
                4
              ];
            case 3:
              return e = _state.sent(), [
                2,
                "file"
              ];
            case 4:
              return [
                2,
                stats && stats.isDirectory() ? "dir" : "file"
              ];
          }
        });
      }), _symlinkType.apply(this, arguments);
    }
    function symlinkTypeSync(srcpath, type) {
      if (type)
        return type;
      var stats;
      try {
        stats = fs7.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var u = require_universalify().fromPromise, path6 = require("path"), fs7 = require_fs(), _require = require_mkdirs(), mkdirs = _require.mkdirs, mkdirsSync = _require.mkdirsSync, _require1 = require_symlink_paths(), symlinkPaths = _require1.symlinkPaths, symlinkPathsSync = _require1.symlinkPathsSync, _require2 = require_symlink_type(), symlinkType = _require2.symlinkType, symlinkTypeSync = _require2.symlinkTypeSync, pathExists3 = require_path_exists().pathExists, areIdentical = require_stat().areIdentical;
    function createSymlink(srcpath, dstpath, type) {
      return _createSymlink.apply(this, arguments);
    }
    function _createSymlink() {
      return _createSymlink = _async_to_generator31(function(srcpath, dstpath, type) {
        var stats, e, _ref, srcStat, dstStat, relative, toType, dir;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return _state.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                fs7.lstat(dstpath)
              ];
            case 1:
              return stats = _state.sent(), [
                3,
                3
              ];
            case 2:
              return e = _state.sent(), [
                3,
                3
              ];
            case 3:
              return stats && stats.isSymbolicLink() ? [
                4,
                Promise.all([
                  fs7.stat(srcpath),
                  fs7.stat(dstpath)
                ])
              ] : [
                3,
                5
              ];
            case 4:
              if (_ref = _sliced_to_array15.apply(void 0, [
                _state.sent(),
                2
              ]), srcStat = _ref[0], dstStat = _ref[1], areIdentical(srcStat, dstStat))
                return [
                  2
                ];
              _state.label = 5;
            case 5:
              return [
                4,
                symlinkPaths(srcpath, dstpath)
              ];
            case 6:
              return relative = _state.sent(), srcpath = relative.toDst, [
                4,
                symlinkType(relative.toCwd, type)
              ];
            case 7:
              return toType = _state.sent(), dir = path6.dirname(dstpath), [
                4,
                pathExists3(dir)
              ];
            case 8:
              return _state.sent() ? [
                3,
                10
              ] : [
                4,
                mkdirs(dir)
              ];
            case 9:
              _state.sent(), _state.label = 10;
            case 10:
              return [
                2,
                fs7.symlink(srcpath, dstpath, toType)
              ];
          }
        });
      }), _createSymlink.apply(this, arguments);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      var stats;
      try {
        stats = fs7.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        var srcStat = fs7.statSync(srcpath), dstStat = fs7.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      var relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst, type = symlinkTypeSync(relative.toCwd, type);
      var dir = path6.dirname(dstpath), exists = fs7.existsSync(dir);
      return exists || mkdirsSync(dir), fs7.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var _require = require_file(), createFile = _require.createFile, createFileSync = _require.createFileSync, _require1 = require_link(), createLink = _require1.createLink, createLinkSync = _require1.createLinkSync, _require2 = require_symlink(), createSymlink = _require2.createSymlink, createSymlinkSync = _require2.createSymlinkSync;
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify(obj) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref_EOL = _ref.EOL, EOL = _ref_EOL === void 0 ? `
` : _ref_EOL, _ref_finalEOL = _ref.finalEOL, finalEOL = _ref_finalEOL === void 0 ? !0 : _ref_finalEOL, _ref_replacer = _ref.replacer, replacer = _ref_replacer === void 0 ? null : _ref_replacer, spaces = _ref.spaces, EOF3 = finalEOL ? EOL : "", str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF3;
    }
    function stripBom(content) {
      return Buffer.isBuffer(content) && (content = content.toString("utf8")), content.replace(/^\uFEFF/, "");
    }
    module2.exports = {
      stringify,
      stripBom
    };
  }
});

// ../../node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/jsonfile/index.js"(exports2, module2) {
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var _fs2;
    try {
      _fs2 = require_graceful_fs();
    } catch {
      _fs2 = require("fs");
    }
    var universalify = require_universalify(), _require = require_utils2(), stringify = _require.stringify, stripBom = _require.stripBom;
    function _readFile(file) {
      return __readFile.apply(this, arguments);
    }
    function __readFile() {
      return __readFile = _async_to_generator31(function(file) {
        var options, fs7, shouldThrow, data, obj, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return options = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, typeof options == "string" && (options = {
                encoding: options
              }), fs7 = options.fs || _fs2, shouldThrow = "throws" in options ? options.throws : !0, [
                4,
                universalify.fromCallback(fs7.readFile)(file, options)
              ];
            case 1:
              data = _state.sent(), data = stripBom(data);
              try {
                obj = JSON.parse(data, options ? options.reviver : null);
              } catch (err) {
                if (shouldThrow)
                  throw err.message = "".concat(file, ": ").concat(err.message), err;
                return [
                  2,
                  null
                ];
              }
              return [
                2,
                obj
              ];
          }
        });
      }), __readFile.apply(this, arguments);
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync3(file) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      typeof options == "string" && (options = {
        encoding: options
      });
      var fs7 = options.fs || _fs2, shouldThrow = "throws" in options ? options.throws : !0;
      try {
        var content = fs7.readFileSync(file, options);
        return content = stripBom(content), JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow)
          throw err.message = "".concat(file, ": ").concat(err.message), err;
        return null;
      }
    }
    function _writeFile(file, obj) {
      return __writeFile.apply(this, arguments);
    }
    function __writeFile() {
      return __writeFile = _async_to_generator31(function(file, obj) {
        var options, fs7, str, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {}, fs7 = options.fs || _fs2, str = stringify(obj, options), [
                4,
                universalify.fromCallback(fs7.writeFile)(file, str, options)
              ];
            case 1:
              return _state.sent(), [
                2
              ];
          }
        });
      }), __writeFile.apply(this, arguments);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, fs7 = options.fs || _fs2, str = stringify(obj, options);
      return fs7.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync: readFileSync3,
      writeFile,
      writeFileSync: writeFileSync2
    };
    module2.exports = jsonfile;
  }
});

// ../../node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../../node_modules/fs-extra/lib/output-file/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var u = require_universalify().fromPromise, fs7 = require_fs(), path6 = require("path"), mkdir2 = require_mkdirs(), pathExists3 = require_path_exists().pathExists;
    function outputFile(file, data) {
      return _outputFile.apply(this, arguments);
    }
    function _outputFile() {
      return _outputFile = _async_to_generator31(function(file, data) {
        var encoding, dir, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return encoding = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : "utf-8", dir = path6.dirname(file), [
                4,
                pathExists3(dir)
              ];
            case 1:
              return _state.sent() ? [
                3,
                3
              ] : [
                4,
                mkdir2.mkdirs(dir)
              ];
            case 2:
              _state.sent(), _state.label = 3;
            case 3:
              return [
                2,
                fs7.writeFile(file, data, encoding)
              ];
          }
        });
      }), _outputFile.apply(this, arguments);
    }
    function outputFileSync(file) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        args[_key - 1] = arguments[_key];
      var _fs2, dir = path6.dirname(file);
      fs7.existsSync(dir) || mkdir2.mkdirsSync(dir), (_fs2 = fs7).writeFileSync.apply(_fs2, [
        file
      ].concat(_to_consumable_array16(args)));
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var stringify = require_utils2().stringify, outputFile = require_output_file().outputFile;
    function outputJson(file, data) {
      return _outputJson.apply(this, arguments);
    }
    function _outputJson() {
      return _outputJson = _async_to_generator31(function(file, data) {
        var options, str, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {}, str = stringify(data, options), [
                4,
                outputFile(file, str, options)
              ];
            case 1:
              return _state.sent(), [
                2
              ];
          }
        });
      }), _outputJson.apply(this, arguments);
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var stringify = require_utils2().stringify, outputFileSync = require_output_file().outputFileSync;
    function outputJsonSync(file, data, options) {
      var str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../../node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var fs7 = require_fs(), path6 = require("path"), copy2 = require_copy2().copy, remove2 = require_remove().remove, mkdirp = require_mkdirs().mkdirp, pathExists3 = require_path_exists().pathExists, stat3 = require_stat();
    function move(src, dest) {
      return _move.apply(this, arguments);
    }
    function _move() {
      return _move = _async_to_generator31(function(src, dest) {
        var opts, overwrite, _ref, srcStat, _ref_isChangingCase, isChangingCase, destParent, parsedParentPath, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return opts = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {}, overwrite = opts.overwrite || opts.clobber || !1, [
                4,
                stat3.checkPaths(src, dest, "move", opts)
              ];
            case 1:
              return _ref = _state.sent(), srcStat = _ref.srcStat, _ref_isChangingCase = _ref.isChangingCase, isChangingCase = _ref_isChangingCase === void 0 ? !1 : _ref_isChangingCase, [
                4,
                stat3.checkParentPaths(src, srcStat, dest, "move")
              ];
            case 2:
              return _state.sent(), destParent = path6.dirname(dest), parsedParentPath = path6.parse(destParent), parsedParentPath.root === destParent ? [
                3,
                4
              ] : [
                4,
                mkdirp(destParent)
              ];
            case 3:
              _state.sent(), _state.label = 4;
            case 4:
              return [
                2,
                doRename(src, dest, overwrite, isChangingCase)
              ];
          }
        });
      }), _move.apply(this, arguments);
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      return _doRename.apply(this, arguments);
    }
    function _doRename() {
      return _doRename = _async_to_generator31(function(src, dest, overwrite, isChangingCase) {
        var err;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return isChangingCase ? [
                3,
                4
              ] : overwrite ? [
                4,
                remove2(dest)
              ] : [
                3,
                2
              ];
            case 1:
              return _state.sent(), [
                3,
                4
              ];
            case 2:
              return [
                4,
                pathExists3(dest)
              ];
            case 3:
              if (_state.sent())
                throw new Error("dest already exists.");
              _state.label = 4;
            case 4:
              return _state.trys.push([
                4,
                6,
                ,
                8
              ]), [
                4,
                fs7.rename(src, dest)
              ];
            case 5:
              return _state.sent(), [
                3,
                8
              ];
            case 6:
              if (err = _state.sent(), err.code !== "EXDEV")
                throw err;
              return [
                4,
                moveAcrossDevice(src, dest, overwrite)
              ];
            case 7:
              return _state.sent(), [
                3,
                8
              ];
            case 8:
              return [
                2
              ];
          }
        });
      }), _doRename.apply(this, arguments);
    }
    function moveAcrossDevice(src, dest, overwrite) {
      return _moveAcrossDevice.apply(this, arguments);
    }
    function _moveAcrossDevice() {
      return _moveAcrossDevice = _async_to_generator31(function(src, dest, overwrite) {
        var opts;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return opts = {
                overwrite,
                errorOnExist: !0,
                preserveTimestamps: !0
              }, [
                4,
                copy2(src, dest, opts)
              ];
            case 1:
              return _state.sent(), [
                2,
                remove2(src)
              ];
          }
        });
      }), _moveAcrossDevice.apply(this, arguments);
    }
    module2.exports = move;
  }
});

// ../../node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../../node_modules/fs-extra/lib/move/move-sync.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), path6 = require("path"), copySync = require_copy2().copySync, removeSync = require_remove().removeSync, mkdirpSync = require_mkdirs().mkdirpSync, stat3 = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      var overwrite = opts.overwrite || opts.clobber || !1, _stat_checkPathsSync = stat3.checkPathsSync(src, dest, "move", opts), srcStat = _stat_checkPathsSync.srcStat, _stat_checkPathsSync_isChangingCase = _stat_checkPathsSync.isChangingCase, isChangingCase = _stat_checkPathsSync_isChangingCase === void 0 ? !1 : _stat_checkPathsSync_isChangingCase;
      return stat3.checkParentPathsSync(src, srcStat, dest, "move"), isParentRoot(dest) || mkdirpSync(path6.dirname(dest)), doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      var parent = path6.dirname(dest), parsedPath = path6.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename3(src, dest, overwrite);
      if (overwrite)
        return removeSync(dest), rename3(src, dest, overwrite);
      if (fs7.existsSync(dest))
        throw new Error("dest already exists.");
      return rename3(src, dest, overwrite);
    }
    function rename3(src, dest, overwrite) {
      try {
        fs7.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      var opts = {
        overwrite,
        errorOnExist: !0,
        preserveTimestamps: !0
      };
      return copySync(src, dest, opts), removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../../node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../../node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    module2.exports = _object_spread13(
      {},
      // Export promiseified graceful-fs:
      require_fs(),
      // Export extra methods:
      require_copy2(),
      require_empty(),
      require_ensure(),
      require_json(),
      require_mkdirs(),
      require_move2(),
      require_output_file(),
      require_path_exists(),
      require_remove()
    );
  }
});

// ../../node_modules/opener/lib/opener.js
var require_opener = __commonJS({
  "../../node_modules/opener/lib/opener.js"(exports2, module2) {
    "use strict";
    var childProcess = require("child_process"), os2 = require("os");
    module2.exports = function(args, options, callback) {
      var platform = process.platform;
      platform === "linux" && os2.release().indexOf("Microsoft") !== -1 && (platform = "win32");
      var command;
      switch (platform) {
        case "win32": {
          command = "cmd.exe";
          break;
        }
        case "darwin": {
          command = "open";
          break;
        }
        default: {
          command = "xdg-open";
          break;
        }
      }
      return typeof args == "string" && (args = [
        args
      ]), typeof options == "function" && (callback = options, options = {}), options && typeof options == "object" && options.command && (platform === "win32" ? args = [
        options.command
      ].concat(args) : command = options.command), platform === "win32" && (args = args.map(function(value) {
        return value.replace(/[&^]/g, "^$&");
      }), args = [
        "/c",
        "start",
        '""'
      ].concat(args)), childProcess.execFile(command, args, options, callback);
    };
  }
});

// ../../node_modules/kleur/index.js
var require_kleur = __commonJS({
  "../../node_modules/kleur/index.js"(exports2, module2) {
    "use strict";
    var _process_env = process.env, FORCE_COLOR = _process_env.FORCE_COLOR, NODE_DISABLE_COLORS = _process_env.NODE_DISABLE_COLORS, TERM = _process_env.TERM, $2 = {
      enabled: !NODE_DISABLE_COLORS && TERM !== "dumb" && FORCE_COLOR !== "0",
      // modifiers
      reset: init(0, 0),
      bold: init(1, 22),
      dim: init(2, 22),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      // colors
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      grey: init(90, 39),
      // background colors
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49)
    };
    function run2(arr, str) {
      for (var i = 0, tmp, beg = "", end = ""; i < arr.length; i++)
        tmp = arr[i], beg += tmp.open, end += tmp.close, str.includes(tmp.close) && (str = str.replace(tmp.rgx, tmp.close + tmp.open));
      return beg + str + end;
    }
    function chain(has, keys) {
      var ctx = {
        has,
        keys
      };
      return ctx.reset = $2.reset.bind(ctx), ctx.bold = $2.bold.bind(ctx), ctx.dim = $2.dim.bind(ctx), ctx.italic = $2.italic.bind(ctx), ctx.underline = $2.underline.bind(ctx), ctx.inverse = $2.inverse.bind(ctx), ctx.hidden = $2.hidden.bind(ctx), ctx.strikethrough = $2.strikethrough.bind(ctx), ctx.black = $2.black.bind(ctx), ctx.red = $2.red.bind(ctx), ctx.green = $2.green.bind(ctx), ctx.yellow = $2.yellow.bind(ctx), ctx.blue = $2.blue.bind(ctx), ctx.magenta = $2.magenta.bind(ctx), ctx.cyan = $2.cyan.bind(ctx), ctx.white = $2.white.bind(ctx), ctx.gray = $2.gray.bind(ctx), ctx.grey = $2.grey.bind(ctx), ctx.bgBlack = $2.bgBlack.bind(ctx), ctx.bgRed = $2.bgRed.bind(ctx), ctx.bgGreen = $2.bgGreen.bind(ctx), ctx.bgYellow = $2.bgYellow.bind(ctx), ctx.bgBlue = $2.bgBlue.bind(ctx), ctx.bgMagenta = $2.bgMagenta.bind(ctx), ctx.bgCyan = $2.bgCyan.bind(ctx), ctx.bgWhite = $2.bgWhite.bind(ctx), ctx;
    }
    function init(open3, close) {
      var blk = {
        open: "\x1B[".concat(open3, "m"),
        close: "\x1B[".concat(close, "m"),
        rgx: new RegExp("\\x1b\\[".concat(close, "m"), "g")
      };
      return function(txt) {
        return this !== void 0 && this.has !== void 0 ? (this.has.includes(open3) || (this.has.push(open3), this.keys.push(blk)), txt === void 0 ? this : $2.enabled ? run2(this.keys, txt + "") : txt + "") : txt === void 0 ? chain([
          open3
        ], [
          blk
        ]) : $2.enabled ? run2([
          blk
        ], txt + "") : txt + "";
      };
    }
    module2.exports = $2;
  }
});

// ../../node_modules/prompts/dist/util/action.js
var require_action = __commonJS({
  "../../node_modules/prompts/dist/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = function(key) {
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c" || key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      return key.name === "return" || key.name === "enter" ? "submit" : key.name === "backspace" ? "delete" : key.name === "delete" ? "deleteForward" : key.name === "abort" || key.name === "escape" ? "abort" : key.name === "tab" ? "next" : key.name === "pagedown" ? "nextPage" : key.name === "pageup" ? "prevPage" : key.name === "up" ? "up" : key.name === "down" ? "down" : key.name === "right" ? "right" : key.name === "left" ? "left" : !1;
    };
  }
});

// ../../node_modules/prompts/dist/util/strip.js
var require_strip = __commonJS({
  "../../node_modules/prompts/dist/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str) {
      var pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
      ].join("|"), RGX = new RegExp(pattern, "g");
      return typeof str == "string" ? str.replace(RGX, "") : str;
    };
  }
});

// ../../node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  "../../node_modules/sisteransi/src/index.js"(exports2, module2) {
    "use strict";
    var ESC = "\x1B", CSI = "".concat(ESC, "["), beep = "\x07", cursor = {
      to: function(x, y) {
        return y ? "".concat(CSI).concat(y + 1, ";").concat(x + 1, "H") : "".concat(CSI).concat(x + 1, "G");
      },
      move: function(x, y) {
        var ret = "";
        return x < 0 ? ret += "".concat(CSI).concat(-x, "D") : x > 0 && (ret += "".concat(CSI).concat(x, "C")), y < 0 ? ret += "".concat(CSI).concat(-y, "A") : y > 0 && (ret += "".concat(CSI).concat(y, "B")), ret;
      },
      up: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI).concat(count, "A");
      },
      down: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI).concat(count, "B");
      },
      forward: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI).concat(count, "C");
      },
      backward: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI).concat(count, "D");
      },
      nextLine: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI, "E").repeat(count);
      },
      prevLine: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI, "F").repeat(count);
      },
      left: "".concat(CSI, "G"),
      hide: "".concat(CSI, "?25l"),
      show: "".concat(CSI, "?25h"),
      save: "".concat(ESC, "7"),
      restore: "".concat(ESC, "8")
    }, scroll = {
      up: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI, "S").repeat(count);
      },
      down: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI, "T").repeat(count);
      }
    }, erase = {
      screen: "".concat(CSI, "2J"),
      up: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI, "1J").repeat(count);
      },
      down: function() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return "".concat(CSI, "J").repeat(count);
      },
      line: "".concat(CSI, "2K"),
      lineEnd: "".concat(CSI, "K"),
      lineStart: "".concat(CSI, "1K"),
      lines: function(count) {
        for (var clear = "", i = 0; i < count; i++)
          clear += this.line + (i < count - 1 ? cursor.up() : "");
        return count && (clear += cursor.left), clear;
      }
    };
    module2.exports = {
      cursor,
      scroll,
      erase,
      beep
    };
  }
});

// ../../node_modules/prompts/dist/util/clear.js
var require_clear = __commonJS({
  "../../node_modules/prompts/dist/util/clear.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var strip = require_strip(), _require = require_src(), erase = _require.erase, cursor = _require.cursor, width = function(str) {
      return _to_consumable_array16(strip(str)).length;
    };
    module2.exports = function(prompt) {
      var perLine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : process.stdout.columns;
      if (!perLine)
        return erase.line + cursor.to(0);
      var rows = 0, lines = prompt.split(/\r?\n/), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var line = _step.value;
          rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
    };
  }
});

// ../../node_modules/prompts/dist/util/figures.js
var require_figures = __commonJS({
  "../../node_modules/prompts/dist/util/figures.js"(exports2, module2) {
    "use strict";
    var main6 = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    }, win = {
      arrowUp: main6.arrowUp,
      arrowDown: main6.arrowDown,
      arrowLeft: main6.arrowLeft,
      arrowRight: main6.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    }, figures = process.platform === "win32" ? win : main6;
    module2.exports = figures;
  }
});

// ../../node_modules/prompts/dist/util/style.js
var require_style = __commonJS({
  "../../node_modules/prompts/dist/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur(), figures = require_figures(), styles3 = Object.freeze({
      password: {
        scale: 1,
        render: function(input) {
          return "*".repeat(input.length);
        }
      },
      emoji: {
        scale: 2,
        render: function(input) {
          return "\u{1F603}".repeat(input.length);
        }
      },
      invisible: {
        scale: 0,
        render: function(input) {
          return "";
        }
      },
      default: {
        scale: 1,
        render: function(input) {
          return "".concat(input);
        }
      }
    }), render = function(type) {
      return styles3[type] || styles3.default;
    }, symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      default: c.cyan("?")
    }), symbol = function(done, aborted) {
      return aborted ? symbols.aborted : done ? symbols.done : symbols.default;
    }, delimiter = function(completing) {
      return c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    }, item = function(expandable, expanded) {
      return c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    };
    module2.exports = {
      styles: styles3,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// ../../node_modules/prompts/dist/util/index.js
var require_util2 = __commonJS({
  "../../node_modules/prompts/dist/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action(),
      clear: require_clear(),
      style: require_style(),
      strip: require_strip(),
      figures: require_figures()
    };
  }
});

// ../../node_modules/prompts/dist/elements/prompt.js
var require_prompt = __commonJS({
  "../../node_modules/prompts/dist/elements/prompt.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var readline = require("readline"), _require = require_util2(), action = _require.action, EventEmitter3 = require("events"), _require2 = require_src(), beep = _require2.beep, cursor = _require2.cursor, color = require_kleur(), Prompt = /* @__PURE__ */ function(EventEmitter4) {
      _inherits10(Prompt2, EventEmitter4);
      var _super = _create_super10(Prompt2);
      function Prompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, Prompt2);
        var _this;
        _this = _super.call(this), _this.firstRender = !0, _this.in = opts.in || process.stdin, _this.out = opts.out || process.stdout, _this.onRender = (opts.onRender || function() {
        }).bind(_assert_this_initialized10(_this));
        var rl = readline.createInterface(_this.in);
        readline.emitKeypressEvents(_this.in, rl), _this.in.isTTY && _this.in.setRawMode(!0);
        var keypress = function(str, key) {
          var a = action(key);
          a === !1 ? _this._ && _this._(str, key) : typeof _this[a] == "function" ? _this[a](key) : _this.bell();
        };
        return _this.close = function() {
          _this.out.write(cursor.show), _this.in.removeListener("keypress", keypress), _this.in.isTTY && _this.in.setRawMode(!1), rl.close(), _this.emit(_this.aborted ? "abort" : "submit", _this.value), _this.closed = !0;
        }, _this.in.on("keypress", keypress), _this;
      }
      return _create_class13(Prompt2, [
        {
          key: "fire",
          value: function() {
            this.emit("state", {
              value: this.value,
              aborted: !!this.aborted
            });
          }
        },
        {
          key: "bell",
          value: function() {
            this.out.write(beep);
          }
        },
        {
          key: "render",
          value: function() {
            this.onRender(color), this.firstRender && (this.firstRender = !1);
          }
        }
      ]), Prompt2;
    }(EventEmitter3);
    module2.exports = Prompt;
  }
});

// ../../node_modules/prompts/dist/elements/text.js
var require_text = __commonJS({
  "../../node_modules/prompts/dist/elements/text.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_src(), cursor = _require.cursor, _require2 = require_util2(), style = _require2.style, clear = _require2.clear, strip = _require2.strip, figures = _require2.figures, TextPrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(TextPrompt2, Prompt2);
      var _super = _create_super10(TextPrompt2);
      function TextPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, TextPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.transform = style.render(opts.style), _this.scale = _this.transform.scale, _this.msg = opts.message, _this.initial = opts.initial || "", _this.validator = opts.validate || function() {
          return !0;
        }, _this.value = "", _this.errorMsg = opts.error || "Please Enter A Valid Value", _this.cursor = +!!_this.initial, _this.clear = clear(""), _this.render(), _this;
      }
      return _create_class13(TextPrompt2, [
        {
          key: "value",
          get: function() {
            return this._value;
          },
          set: function(v) {
            !v && this.initial ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.rendered = this.transform.render(v)), this._value = v, this.fire();
          }
        },
        {
          key: "reset",
          value: function() {
            this.value = "", this.cursor = +!!this.initial, this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "validate",
          value: function() {
            var _this = this;
            return _asyncToGenerator(function() {
              var valid;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validator(_this.value)
                    ];
                  case 1:
                    return valid = _state.sent(), typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid, [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "submit",
          value: function() {
            var _this2 = this;
            return _asyncToGenerator(function() {
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return _this2.value = _this2.value || _this2.initial, [
                      4,
                      _this2.validate()
                    ];
                  case 1:
                    return _state.sent(), _this2.error ? (_this2.red = !0, _this2.fire(), _this2.render(), [
                      2
                    ]) : (_this2.done = !0, _this2.aborted = !1, _this2.fire(), _this2.render(), _this2.out.write(`
`), _this2.close(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "next",
          value: function() {
            if (!this.placeholder)
              return this.bell();
            this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
          }
        },
        {
          key: "moveCursor",
          value: function(n) {
            this.placeholder || (this.cursor = this.cursor + n);
          }
        },
        {
          key: "_",
          value: function(c, key) {
            var s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor);
            this.value = "".concat(s1).concat(c).concat(s2), this.red = !1, this.cursor = this.placeholder ? 0 : s1.length + 1, this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            if (this.cursor === 0)
              return this.bell();
            var s1 = this.value.slice(0, this.cursor - 1), s2 = this.value.slice(this.cursor);
            this.value = "".concat(s1).concat(s2), this.red = !1, this.moveCursor(-1), this.render();
          }
        },
        {
          key: "deleteForward",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
              return this.bell();
            var s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor + 1);
            this.value = "".concat(s1).concat(s2), this.red = !1, this.render();
          }
        },
        {
          key: "first",
          value: function() {
            this.cursor = 0, this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.cursor = this.value.length, this.render();
          }
        },
        {
          key: "left",
          value: function() {
            if (this.cursor <= 0 || this.placeholder)
              return this.bell();
            this.moveCursor(-1), this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
              return this.bell();
            this.moveCursor(1), this.render();
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              _get4(_get_prototype_of10(TextPrompt2.prototype), "render", this).call(this);
              var erase = (this.lines ? cursor.down(this.lines) : "") + this.clear;
              this.lines = 0;
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(this.done),
                this.red ? color.red(this.rendered) : this.rendered
              ].join(" "), error = "";
              if (this.error) {
                var lines = this.errorMsg.split(`
`);
                error += lines.reduce(function(a, l, i) {
                  return a += `
`.concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l));
                }, ""), this.lines = lines.length;
              }
              var position = "";
              this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), position += cursor.move(this.placeholder ? -this.initial.length * this.scale : -this.rendered.length + this.cursor * this.scale), this.out.write(erase + prompt + error + position), this.clear = clear(prompt + error);
            }
          }
        }
      ]), TextPrompt2;
    }(Prompt);
    module2.exports = TextPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/select.js
var require_select = __commonJS({
  "../../node_modules/prompts/dist/elements/select.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, clear = _require.clear, figures = _require.figures, _require2 = require_src(), erase = _require2.erase, cursor = _require2.cursor, SelectPrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(SelectPrompt2, Prompt2);
      var _super = _create_super10(SelectPrompt2);
      function SelectPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, SelectPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.hint = opts.hint || "- Use arrow-keys. Return to submit.", _this.warn = opts.warn || "- This option is disabled", _this.cursor = opts.initial || 0, _this.choices = opts.choices.map(function(ch, idx) {
          return typeof ch == "string" && (ch = {
            title: ch,
            value: idx
          }), {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value || idx),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        }), _this.value = (_this.choices[_this.cursor] || {}).value, _this.clear = clear(""), _this.render(), _this;
      }
      return _create_class13(SelectPrompt2, [
        {
          key: "moveCursor",
          value: function(n) {
            this.cursor = n, this.value = this.choices[n].value, this.fire();
          }
        },
        {
          key: "reset",
          value: function() {
            this.moveCursor(0), this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
          }
        },
        {
          key: "first",
          value: function() {
            this.moveCursor(0), this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.moveCursor(this.choices.length - 1), this.render();
          }
        },
        {
          key: "up",
          value: function() {
            if (this.cursor === 0)
              return this.bell();
            this.moveCursor(this.cursor - 1), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            if (this.cursor === this.choices.length - 1)
              return this.bell();
            this.moveCursor(this.cursor + 1), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (c === " ")
              return this.submit();
          }
        },
        {
          key: "selection",
          get: function() {
            return this.choices[this.cursor];
          }
        },
        {
          key: "render",
          value: function() {
            var _this = this;
            this.closed || (this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(this.choices.length + 1)), _get4(_get_prototype_of10(SelectPrompt2.prototype), "render", this).call(this), this.out.write([
              style.symbol(this.done, this.aborted),
              color.bold(this.msg),
              style.delimiter(!1),
              this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
            ].join(" ")), this.done || this.out.write(`
` + this.choices.map(function(v, i) {
              var title, prefix;
              return v.disabled ? (title = _this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title), prefix = _this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") : (title = _this.cursor === i ? color.cyan().underline(v.title) : v.title, prefix = _this.cursor === i ? color.cyan(figures.pointer) + " " : "  "), "".concat(prefix, " ").concat(title);
            }).join(`
`)));
          }
        }
      ]), SelectPrompt2;
    }(Prompt);
    module2.exports = SelectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/toggle.js
var require_toggle = __commonJS({
  "../../node_modules/prompts/dist/elements/toggle.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, clear = _require.clear, _require2 = require_src(), cursor = _require2.cursor, erase = _require2.erase, TogglePrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(TogglePrompt2, Prompt2);
      var _super = _create_super10(TogglePrompt2);
      function TogglePrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, TogglePrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.value = !!opts.initial, _this.active = opts.active || "on", _this.inactive = opts.inactive || "off", _this.initialValue = _this.value, _this.render(), _this;
      }
      return _create_class13(TogglePrompt2, [
        {
          key: "reset",
          value: function() {
            this.value = this.initialValue, this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "deactivate",
          value: function() {
            if (this.value === !1)
              return this.bell();
            this.value = !1, this.render();
          }
        },
        {
          key: "activate",
          value: function() {
            if (this.value === !0)
              return this.bell();
            this.value = !0, this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            this.deactivate();
          }
        },
        {
          key: "left",
          value: function() {
            this.deactivate();
          }
        },
        {
          key: "right",
          value: function() {
            this.activate();
          }
        },
        {
          key: "down",
          value: function() {
            this.deactivate();
          }
        },
        {
          key: "up",
          value: function() {
            this.activate();
          }
        },
        {
          key: "next",
          value: function() {
            this.value = !this.value, this.fire(), this.render();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (c === " ")
              this.value = !this.value;
            else if (c === "1")
              this.value = !0;
            else if (c === "0")
              this.value = !1;
            else
              return this.bell();
            this.render();
          }
        },
        {
          key: "render",
          value: function() {
            this.closed || (this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(TogglePrompt2.prototype), "render", this).call(this), this.out.write(erase.lines(this.first ? 1 : this.msg.split(/\n/g).length) + cursor.to(0) + [
              style.symbol(this.done, this.aborted),
              color.bold(this.msg),
              style.delimiter(this.done),
              this.value ? this.inactive : color.cyan().underline(this.inactive),
              color.gray("/"),
              this.value ? color.cyan().underline(this.active) : this.active
            ].join(" ")));
          }
        }
      ]), TogglePrompt2;
    }(Prompt);
    module2.exports = TogglePrompt;
  }
});

// ../../node_modules/prompts/dist/dateparts/datepart.js
var require_datepart = __commonJS({
  "../../node_modules/prompts/dist/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var DatePart = /* @__PURE__ */ function() {
      function DatePart2(param) {
        var token = param.token, date = param.date, parts = param.parts, locales = param.locales;
        _class_call_check15(this, DatePart2), this.token = token, this.date = date || /* @__PURE__ */ new Date(), this.parts = parts || [
          this
        ], this.locales = locales || {};
      }
      return _create_class13(DatePart2, [
        {
          key: "up",
          value: function() {
          }
        },
        {
          key: "down",
          value: function() {
          }
        },
        {
          key: "next",
          value: function() {
            var currentIdx = this.parts.indexOf(this);
            return this.parts.find(function(part, idx) {
              return idx > currentIdx && _instanceof13(part, DatePart2);
            });
          }
        },
        {
          key: "setTo",
          value: function(val) {
          }
        },
        {
          key: "prev",
          value: function() {
            var parts = [].concat(this.parts).reverse(), currentIdx = parts.indexOf(this);
            return parts.find(function(part, idx) {
              return idx > currentIdx && _instanceof13(part, DatePart2);
            });
          }
        },
        {
          key: "toString",
          value: function() {
            return String(this.date);
          }
        }
      ]), DatePart2;
    }();
    module2.exports = DatePart;
  }
});

// ../../node_modules/prompts/dist/dateparts/meridiem.js
var require_meridiem = __commonJS({
  "../../node_modules/prompts/dist/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), Meridiem = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Meridiem2, DatePart2);
      var _super = _create_super10(Meridiem2);
      function Meridiem2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Meridiem2), _super.call(this, opts);
      }
      return _create_class13(Meridiem2, [
        {
          key: "up",
          value: function() {
            this.date.setHours((this.date.getHours() + 12) % 24);
          }
        },
        {
          key: "down",
          value: function() {
            this.up();
          }
        },
        {
          key: "toString",
          value: function() {
            var meridiem = this.date.getHours() > 12 ? "pm" : "am";
            return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
          }
        }
      ]), Meridiem2;
    }(DatePart);
    module2.exports = Meridiem;
  }
});

// ../../node_modules/prompts/dist/dateparts/day.js
var require_day = __commonJS({
  "../../node_modules/prompts/dist/dateparts/day.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), pos = function(n) {
      return n = n % 10, n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    }, Day = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Day2, DatePart2);
      var _super = _create_super10(Day2);
      function Day2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Day2), _super.call(this, opts);
      }
      return _create_class13(Day2, [
        {
          key: "up",
          value: function() {
            this.date.setDate(this.date.getDate() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setDate(this.date.getDate() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setDate(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var date = this.date.getDate(), day = this.date.getDay();
            return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
          }
        }
      ]), Day2;
    }(DatePart);
    module2.exports = Day;
  }
});

// ../../node_modules/prompts/dist/dateparts/hours.js
var require_hours = __commonJS({
  "../../node_modules/prompts/dist/dateparts/hours.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), Hours = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Hours2, DatePart2);
      var _super = _create_super10(Hours2);
      function Hours2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Hours2), _super.call(this, opts);
      }
      return _create_class13(Hours2, [
        {
          key: "up",
          value: function() {
            this.date.setHours(this.date.getHours() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setHours(this.date.getHours() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setHours(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var hours = this.date.getHours();
            return /h/.test(this.token) && (hours = hours % 12 || 12), this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
          }
        }
      ]), Hours2;
    }(DatePart);
    module2.exports = Hours;
  }
});

// ../../node_modules/prompts/dist/dateparts/milliseconds.js
var require_milliseconds = __commonJS({
  "../../node_modules/prompts/dist/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), Milliseconds = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Milliseconds2, DatePart2);
      var _super = _create_super10(Milliseconds2);
      function Milliseconds2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Milliseconds2), _super.call(this, opts);
      }
      return _create_class13(Milliseconds2, [
        {
          key: "up",
          value: function() {
            this.date.setMilliseconds(this.date.getMilliseconds() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setMilliseconds(this.date.getMilliseconds() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
          }
        },
        {
          key: "toString",
          value: function() {
            return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
          }
        }
      ]), Milliseconds2;
    }(DatePart);
    module2.exports = Milliseconds;
  }
});

// ../../node_modules/prompts/dist/dateparts/minutes.js
var require_minutes = __commonJS({
  "../../node_modules/prompts/dist/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), Minutes = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Minutes2, DatePart2);
      var _super = _create_super10(Minutes2);
      function Minutes2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Minutes2), _super.call(this, opts);
      }
      return _create_class13(Minutes2, [
        {
          key: "up",
          value: function() {
            this.date.setMinutes(this.date.getMinutes() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setMinutes(this.date.getMinutes() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setMinutes(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var m = this.date.getMinutes();
            return this.token.length > 1 ? String(m).padStart(2, "0") : m;
          }
        }
      ]), Minutes2;
    }(DatePart);
    module2.exports = Minutes;
  }
});

// ../../node_modules/prompts/dist/dateparts/month.js
var require_month = __commonJS({
  "../../node_modules/prompts/dist/dateparts/month.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), Month = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Month2, DatePart2);
      var _super = _create_super10(Month2);
      function Month2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Month2), _super.call(this, opts);
      }
      return _create_class13(Month2, [
        {
          key: "up",
          value: function() {
            this.date.setMonth(this.date.getMonth() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setMonth(this.date.getMonth() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            val = parseInt(val.substr(-2)) - 1, this.date.setMonth(val < 0 ? 0 : val);
          }
        },
        {
          key: "toString",
          value: function() {
            var month = this.date.getMonth(), tl = this.token.length;
            return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
          }
        }
      ]), Month2;
    }(DatePart);
    module2.exports = Month;
  }
});

// ../../node_modules/prompts/dist/dateparts/seconds.js
var require_seconds = __commonJS({
  "../../node_modules/prompts/dist/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), Seconds = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Seconds2, DatePart2);
      var _super = _create_super10(Seconds2);
      function Seconds2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Seconds2), _super.call(this, opts);
      }
      return _create_class13(Seconds2, [
        {
          key: "up",
          value: function() {
            this.date.setSeconds(this.date.getSeconds() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setSeconds(this.date.getSeconds() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setSeconds(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var s = this.date.getSeconds();
            return this.token.length > 1 ? String(s).padStart(2, "0") : s;
          }
        }
      ]), Seconds2;
    }(DatePart);
    module2.exports = Seconds;
  }
});

// ../../node_modules/prompts/dist/dateparts/year.js
var require_year = __commonJS({
  "../../node_modules/prompts/dist/dateparts/year.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart(), Year = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Year2, DatePart2);
      var _super = _create_super10(Year2);
      function Year2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Year2), _super.call(this, opts);
      }
      return _create_class13(Year2, [
        {
          key: "up",
          value: function() {
            this.date.setFullYear(this.date.getFullYear() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setFullYear(this.date.getFullYear() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setFullYear(val.substr(-4));
          }
        },
        {
          key: "toString",
          value: function() {
            var year = String(this.date.getFullYear()).padStart(4, "0");
            return this.token.length === 2 ? year.substr(-2) : year;
          }
        }
      ]), Year2;
    }(DatePart);
    module2.exports = Year;
  }
});

// ../../node_modules/prompts/dist/dateparts/index.js
var require_dateparts = __commonJS({
  "../../node_modules/prompts/dist/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart(),
      Meridiem: require_meridiem(),
      Day: require_day(),
      Hours: require_hours(),
      Milliseconds: require_milliseconds(),
      Minutes: require_minutes(),
      Month: require_month(),
      Seconds: require_seconds(),
      Year: require_year()
    };
  }
});

// ../../node_modules/prompts/dist/elements/date.js
var require_date = __commonJS({
  "../../node_modules/prompts/dist/elements/date.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, clear = _require.clear, figures = _require.figures, strip = _require.strip, _require2 = require_src(), erase = _require2.erase, cursor = _require2.cursor, _require3 = require_dateparts(), DatePart = _require3.DatePart, Meridiem = _require3.Meridiem, Day = _require3.Day, Hours = _require3.Hours, Milliseconds = _require3.Milliseconds, Minutes = _require3.Minutes, Month = _require3.Month, Seconds = _require3.Seconds, Year = _require3.Year, regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, regexGroups = {
      1: function(param) {
        var token = param.token;
        return token.replace(/\\(.)/g, "$1");
      },
      2: function(opts) {
        return new Day(opts);
      },
      // Day // TODO
      3: function(opts) {
        return new Month(opts);
      },
      // Month
      4: function(opts) {
        return new Year(opts);
      },
      // Year
      5: function(opts) {
        return new Meridiem(opts);
      },
      // AM/PM // TODO (special)
      6: function(opts) {
        return new Hours(opts);
      },
      // Hours
      7: function(opts) {
        return new Minutes(opts);
      },
      // Minutes
      8: function(opts) {
        return new Seconds(opts);
      },
      // Seconds
      9: function(opts) {
        return new Milliseconds(opts);
      }
    }, dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    }, DatePrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(DatePrompt2, Prompt2);
      var _super = _create_super10(DatePrompt2);
      function DatePrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, DatePrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.cursor = 0, _this.typed = "", _this.locales = Object.assign(dfltLocales, opts.locales), _this._date = opts.initial || /* @__PURE__ */ new Date(), _this.errorMsg = opts.error || "Please Enter A Valid Value", _this.validator = opts.validate || function() {
          return !0;
        }, _this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss", _this.clear = clear(""), _this.render(), _this;
      }
      return _create_class13(DatePrompt2, [
        {
          key: "value",
          get: function() {
            return this.date;
          }
        },
        {
          key: "date",
          get: function() {
            return this._date;
          },
          set: function(date) {
            date && this._date.setTime(date.getTime());
          }
        },
        {
          key: "mask",
          set: function(mask) {
            var _this_parts, result;
            for (this.parts = []; result = regex.exec(mask); ) {
              var match2 = result.shift(), idx = result.findIndex(function(gr) {
                return gr != null;
              });
              this.parts.push(idx in regexGroups ? regexGroups[idx]({
                token: result[idx] || match2,
                date: this.date,
                parts: this.parts,
                locales: this.locales
              }) : result[idx] || match2);
            }
            var parts = this.parts.reduce(function(arr, i) {
              return typeof i == "string" && typeof arr[arr.length - 1] == "string" ? arr[arr.length - 1] += i : arr.push(i), arr;
            }, []);
            this.parts.splice(0), (_this_parts = this.parts).push.apply(_this_parts, _to_consumable_array16(parts)), this.reset();
          }
        },
        {
          key: "moveCursor",
          value: function(n) {
            this.typed = "", this.cursor = n, this.fire();
          }
        },
        {
          key: "reset",
          value: function() {
            this.moveCursor(this.parts.findIndex(function(p) {
              return _instanceof13(p, DatePart);
            })), this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "validate",
          value: function() {
            var _this = this;
            return _asyncToGenerator(function() {
              var valid;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validator(_this.value)
                    ];
                  case 1:
                    return valid = _state.sent(), typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid, [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "submit",
          value: function() {
            var _this2 = this;
            return _asyncToGenerator(function() {
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this2.validate()
                    ];
                  case 1:
                    return _state.sent(), _this2.error ? (_this2.color = "red", _this2.fire(), _this2.render(), [
                      2
                    ]) : (_this2.done = !0, _this2.aborted = !1, _this2.fire(), _this2.render(), _this2.out.write(`
`), _this2.close(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "up",
          value: function() {
            this.typed = "", this.parts[this.cursor].up(), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            this.typed = "", this.parts[this.cursor].down(), this.render();
          }
        },
        {
          key: "left",
          value: function() {
            var prev = this.parts[this.cursor].prev();
            if (prev == null)
              return this.bell();
            this.moveCursor(this.parts.indexOf(prev)), this.render();
          }
        },
        {
          key: "right",
          value: function() {
            var next = this.parts[this.cursor].next();
            if (next == null)
              return this.bell();
            this.moveCursor(this.parts.indexOf(next)), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            var next2 = this.parts[this.cursor].next();
            this.moveCursor(next2 ? this.parts.indexOf(next2) : this.parts.findIndex(function(part) {
              return _instanceof13(part, DatePart);
            })), this.render();
          }
        },
        {
          key: "_",
          value: function(c) {
            /\d/.test(c) && (this.typed += c, this.parts[this.cursor].setTo(this.typed), this.render());
          }
        },
        {
          key: "render",
          value: function() {
            var _this = this;
            if (!this.closed) {
              this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(1)), _get4(_get_prototype_of10(DatePrompt2.prototype), "render", this).call(this);
              var clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
              this.lines = 0;
              var error = "";
              if (this.error) {
                var lines = this.errorMsg.split(`
`);
                error = lines.reduce(function(a, l, i) {
                  return a + `
`.concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l));
                }, ""), this.lines = lines.length;
              }
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(!1),
                this.parts.reduce(function(arr, p, idx) {
                  return arr.concat(idx === _this.cursor && !_this.done ? color.cyan().underline(p.toString()) : p);
                }, []).join("")
              ].join(" "), position = "";
              this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
            }
          }
        }
      ]), DatePrompt2;
    }(Prompt);
    module2.exports = DatePrompt;
  }
});

// ../../node_modules/prompts/dist/elements/number.js
var require_number = __commonJS({
  "../../node_modules/prompts/dist/elements/number.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_src(), cursor = _require.cursor, erase = _require.erase, _require2 = require_util2(), style = _require2.style, clear = _require2.clear, figures = _require2.figures, strip = _require2.strip, isNumber = /[0-9]/, isDef = function(any) {
      return any !== void 0;
    }, round = function(number, precision) {
      var factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    }, NumberPrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(NumberPrompt2, Prompt2);
      var _super = _create_super10(NumberPrompt2);
      function NumberPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, NumberPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.transform = style.render(opts.style), _this.msg = opts.message, _this.initial = isDef(opts.initial) ? opts.initial : "", _this.float = !!opts.float, _this.round = opts.round || 2, _this.inc = opts.increment || 1, _this.min = isDef(opts.min) ? opts.min : -1 / 0, _this.max = isDef(opts.max) ? opts.max : 1 / 0, _this.errorMsg = opts.error || "Please Enter A Valid Value", _this.validator = opts.validate || function() {
          return !0;
        }, _this.color = "cyan", _this.value = "", _this.typed = "", _this.lastHit = 0, _this.render(), _this;
      }
      return _create_class13(NumberPrompt2, [
        {
          key: "value",
          get: function() {
            return this._value;
          },
          set: function(v) {
            !v && v !== 0 ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render("".concat(this.initial))), this._value = "") : (this.placeholder = !1, this.rendered = this.transform.render("".concat(round(v, this.round))), this._value = round(v, this.round)), this.fire();
          }
        },
        {
          key: "parse",
          value: function(x) {
            return this.float ? parseFloat(x) : parseInt(x);
          }
        },
        {
          key: "valid",
          value: function(c) {
            return c === "-" || c === "." && this.float || isNumber.test(c);
          }
        },
        {
          key: "reset",
          value: function() {
            this.typed = "", this.value = "", this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            var x = this.value;
            this.value = x !== "" ? x : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "validate",
          value: function() {
            var _this = this;
            return _asyncToGenerator(function() {
              var valid;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validator(_this.value)
                    ];
                  case 1:
                    return valid = _state.sent(), typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid, [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "submit",
          value: function() {
            var _this2 = this;
            return _asyncToGenerator(function() {
              var x;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this2.validate()
                    ];
                  case 1:
                    return _state.sent(), _this2.error ? (_this2.color = "red", _this2.fire(), _this2.render(), [
                      2
                    ]) : (x = _this2.value, _this2.value = x !== "" ? x : _this2.initial, _this2.done = !0, _this2.aborted = !1, _this2.error = !1, _this2.fire(), _this2.render(), _this2.out.write(`
`), _this2.close(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "up",
          value: function() {
            if (this.typed = "", this.value >= this.max)
              return this.bell();
            this.value += this.inc, this.color = "cyan", this.fire(), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            if (this.typed = "", this.value <= this.min)
              return this.bell();
            this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            var val = this.value.toString();
            if (val.length === 0)
              return this.bell();
            this.value = this.parse(val = val.slice(0, -1)) || "", this.color = "cyan", this.fire(), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.value = this.initial, this.fire(), this.render();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (!this.valid(c))
              return this.bell();
            var now = Date.now();
            if (now - this.lastHit > 1e3 && (this.typed = ""), this.typed += c, this.lastHit = now, this.color = "cyan", c === ".")
              return this.fire();
            this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.value = this.min), this.fire(), this.render();
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              _get4(_get_prototype_of10(NumberPrompt2.prototype), "render", this).call(this);
              var clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
              this.lines = 0;
              var error = "";
              if (this.error) {
                var lines = this.errorMsg.split(`
`);
                error += lines.reduce(function(a, l, i) {
                  return a + `
`.concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l));
                }, ""), this.lines = lines.length;
              }
              var underline = !this.done || !this.done && !this.placeholder, prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(this.done),
                underline ? color[this.color]().underline(this.rendered) : this.rendered
              ].join(" "), position = "";
              this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
            }
          }
        }
      ]), NumberPrompt2;
    }(Prompt);
    module2.exports = NumberPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/multiselect.js
var require_multiselect = __commonJS({
  "../../node_modules/prompts/dist/elements/multiselect.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), _require = require_src(), cursor = _require.cursor, Prompt = require_prompt(), _require2 = require_util2(), clear = _require2.clear, figures = _require2.figures, style = _require2.style, MultiselectPrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(MultiselectPrompt2, Prompt2);
      var _super = _create_super10(MultiselectPrompt2);
      function MultiselectPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, MultiselectPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.cursor = opts.cursor || 0, _this.scrollIndex = opts.cursor || 0, _this.hint = opts.hint || "", _this.warn = opts.warn || "- This option is disabled -", _this.minSelected = opts.min, _this.showMinError = !1, _this.maxChoices = opts.max, _this.value = opts.choices.map(function(ch, idx) {
          return typeof ch == "string" && (ch = {
            title: ch,
            value: idx
          }), {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value || idx),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        }), _this.clear = clear(""), opts.overrideRender || _this.render(), _this;
      }
      return _create_class13(MultiselectPrompt2, [
        {
          key: "reset",
          value: function() {
            this.value.map(function(v) {
              return !v.selected;
            }), this.cursor = 0, this.fire(), this.render();
          }
        },
        {
          key: "selected",
          value: function() {
            return this.value.filter(function(v) {
              return v.selected;
            });
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            var selected = this.value.filter(function(e) {
              return e.selected;
            });
            this.minSelected && selected.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
          }
        },
        {
          key: "first",
          value: function() {
            this.cursor = 0, this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.cursor = this.value.length - 1, this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.cursor = (this.cursor + 1) % this.value.length, this.render();
          }
        },
        {
          key: "up",
          value: function() {
            this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
          }
        },
        {
          key: "down",
          value: function() {
            this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
          }
        },
        {
          key: "left",
          value: function() {
            this.value[this.cursor].selected = !1, this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.value.filter(function(e) {
              return e.selected;
            }).length >= this.maxChoices)
              return this.bell();
            this.value[this.cursor].selected = !0, this.render();
          }
        },
        {
          key: "handleSpaceToggle",
          value: function() {
            var v = this.value[this.cursor];
            if (v.selected)
              v.selected = !1, this.render();
            else {
              if (v.disabled || this.value.filter(function(e) {
                return e.selected;
              }).length >= this.maxChoices)
                return this.bell();
              v.selected = !0, this.render();
            }
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (c === " ")
              this.handleSpaceToggle();
            else
              return this.bell();
          }
        },
        {
          key: "renderInstructions",
          value: function() {
            return `
Instructions:
    `.concat(figures.arrowUp, "/").concat(figures.arrowDown, `: Highlight option
    `).concat(figures.arrowLeft, "/").concat(figures.arrowRight, `/[space]: Toggle selection
    enter/return: Complete answer
    `);
          }
        },
        {
          key: "renderOption",
          value: function(cursor2, v, i) {
            var title;
            return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
          }
        },
        {
          // shared with autocompleteMultiselect
          key: "paginateOptions",
          value: function(options) {
            var _this = this, c = this.cursor, styledOptions = options.map(function(v, i) {
              return _this.renderOption(c, v, i);
            }), numOfOptionsToRender = 10, scopedOptions = styledOptions, hint = "";
            if (styledOptions.length === 0)
              return color.red("No matches for this query.");
            if (styledOptions.length > numOfOptionsToRender) {
              var startIndex = c - numOfOptionsToRender / 2, endIndex = c + numOfOptionsToRender / 2;
              startIndex < 0 ? (startIndex = 0, endIndex = numOfOptionsToRender) : endIndex > options.length && (endIndex = options.length, startIndex = endIndex - numOfOptionsToRender), scopedOptions = styledOptions.slice(startIndex, endIndex), hint = color.dim("(Move up and down to reveal more choices)");
            }
            return `
` + scopedOptions.join(`
`) + `
` + hint;
          }
        },
        {
          // shared with autocomleteMultiselect
          key: "renderOptions",
          value: function(options) {
            return this.done ? "" : this.paginateOptions(options);
          }
        },
        {
          key: "renderDoneOrInstructions",
          value: function() {
            if (this.done) {
              var selected = this.value.filter(function(e) {
                return e.selected;
              }).map(function(v) {
                return v.title;
              }).join(", ");
              return selected;
            }
            var output = [
              color.gray(this.hint),
              this.renderInstructions()
            ];
            return this.value[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(MultiselectPrompt2.prototype), "render", this).call(this);
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(!1),
                this.renderDoneOrInstructions()
              ].join(" ");
              this.showMinError && (prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices.")), this.showMinError = !1), prompt += this.renderOptions(this.value), this.out.write(this.clear + prompt), this.clear = clear(prompt);
            }
          }
        }
      ]), MultiselectPrompt2;
    }(Prompt);
    module2.exports = MultiselectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/autocomplete.js
var require_autocomplete = __commonJS({
  "../../node_modules/prompts/dist/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_src(), cursor = _require.cursor, _require2 = require_util2(), style = _require2.style, clear = _require2.clear, figures = _require2.figures, strip = _require2.strip, getVal = function(arr, i) {
      return arr[i] && (arr[i].value || arr[i].title || arr[i]);
    }, getTitle = function(arr, i) {
      return arr[i] && (arr[i].title || arr[i].value || arr[i]);
    }, getIndex = function(arr, valOrTitle) {
      var index = arr.findIndex(function(el) {
        return el.value === valOrTitle || el.title === valOrTitle;
      });
      return index > -1 ? index : void 0;
    }, AutocompletePrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(AutocompletePrompt2, Prompt2);
      var _super = _create_super10(AutocompletePrompt2);
      function AutocompletePrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, AutocompletePrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.suggest = opts.suggest, _this.choices = opts.choices, _this.initial = typeof opts.initial == "number" ? opts.initial : getIndex(opts.choices, opts.initial), _this.select = _this.initial || opts.cursor || 0, _this.fallback = opts.fallback || (opts.initial !== void 0 ? "".concat(figures.pointerSmall, " ").concat(getTitle(_this.choices, _this.initial)) : "".concat(figures.pointerSmall, " ").concat(opts.noMatches || "no matches found")), _this.suggestions = [
          []
        ], _this.page = 0, _this.input = "", _this.limit = opts.limit || 10, _this.cursor = 0, _this.transform = style.render(opts.style), _this.scale = _this.transform.scale, _this.render = _this.render.bind(_assert_this_initialized10(_this)), _this.complete = _this.complete.bind(_assert_this_initialized10(_this)), _this.clear = clear(""), _this.complete(_this.render), _this.render(), _this;
      }
      return _create_class13(AutocompletePrompt2, [
        {
          key: "moveSelect",
          value: function(i) {
            this.select = i, this.suggestions[this.page].length > 0 ? this.value = getVal(this.suggestions[this.page], i) : this.value = this.initial !== void 0 ? getVal(this.choices, this.initial) : null, this.fire();
          }
        },
        {
          key: "complete",
          value: function(cb) {
            var _this = this;
            return _asyncToGenerator(function() {
              var p, suggestions, index, l;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return p = _this.completing = _this.suggest(_this.input, _this.choices), [
                      4,
                      p
                    ];
                  case 1:
                    return suggestions = _state.sent(), _this.completing !== p ? [
                      2
                    ] : (_this.suggestions = suggestions.map(function(s, i, arr) {
                      return {
                        title: getTitle(arr, i),
                        value: getVal(arr, i)
                      };
                    }).reduce(function(arr, sug) {
                      return arr[arr.length - 1].length < _this.limit ? arr[arr.length - 1].push(sug) : arr.push([
                        sug
                      ]), arr;
                    }, [
                      []
                    ]), _this.isFallback = !1, _this.completing = !1, _this.suggestions[_this.page] || (_this.page = 0), !_this.suggestions.length && _this.fallback && (index = getIndex(_this.choices, _this.fallback), _this.suggestions = [
                      []
                    ], index !== void 0 && _this.suggestions[0].push({
                      title: getTitle(_this.choices, index),
                      value: getVal(_this.choices, index)
                    }), _this.isFallback = !0), l = Math.max(suggestions.length - 1, 0), _this.moveSelect(Math.min(l, _this.select)), cb && cb(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "reset",
          value: function() {
            var _this = this;
            this.input = "", this.complete(function() {
              _this.moveSelect(_this.initial !== void 0 ? _this.initial : 0), _this.render();
            }), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            var s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor);
            this.input = "".concat(s1).concat(c).concat(s2), this.cursor = s1.length + 1, this.complete(this.render), this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            if (this.cursor === 0)
              return this.bell();
            var s1 = this.input.slice(0, this.cursor - 1), s2 = this.input.slice(this.cursor);
            this.input = "".concat(s1).concat(s2), this.complete(this.render), this.cursor = this.cursor - 1, this.render();
          }
        },
        {
          key: "deleteForward",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length)
              return this.bell();
            var s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor + 1);
            this.input = "".concat(s1).concat(s2), this.complete(this.render), this.render();
          }
        },
        {
          key: "first",
          value: function() {
            this.moveSelect(0), this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.moveSelect(this.suggestions[this.page].length - 1), this.render();
          }
        },
        {
          key: "up",
          value: function() {
            if (this.select <= 0)
              return this.bell();
            this.moveSelect(this.select - 1), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            if (this.select >= this.suggestions[this.page].length - 1)
              return this.bell();
            this.moveSelect(this.select + 1), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.select === this.suggestions[this.page].length - 1 ? (this.page = (this.page + 1) % this.suggestions.length, this.moveSelect(0)) : this.moveSelect(this.select + 1), this.render();
          }
        },
        {
          key: "nextPage",
          value: function() {
            if (this.page >= this.suggestions.length - 1)
              return this.bell();
            this.page++, this.moveSelect(0), this.render();
          }
        },
        {
          key: "prevPage",
          value: function() {
            if (this.page <= 0)
              return this.bell();
            this.page--, this.moveSelect(0), this.render();
          }
        },
        {
          key: "left",
          value: function() {
            if (this.cursor <= 0)
              return this.bell();
            this.cursor = this.cursor - 1, this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length)
              return this.bell();
            this.cursor = this.cursor + 1, this.render();
          }
        },
        {
          key: "render",
          value: function() {
            var _this = this;
            if (!this.closed) {
              _get4(_get_prototype_of10(AutocompletePrompt2.prototype), "render", this).call(this), this.lineCount && this.out.write(cursor.down(this.lineCount));
              var prompt = color.bold("".concat(style.symbol(this.done, this.aborted), " ").concat(this.msg, " ")) + "".concat(style.delimiter(this.completing), " "), length = strip(prompt).length;
              if (this.done && this.suggestions[this.page][this.select] ? prompt += "".concat(this.suggestions[this.page][this.select].title) : (this.rendered = "".concat(this.transform.render(this.input)), length += this.rendered.length, prompt += this.rendered), !this.done) {
                this.lineCount = this.suggestions[this.page].length;
                var suggestions = this.suggestions[this.page].reduce(function(acc, item, i) {
                  return acc + `
`.concat(i === _this.select ? color.cyan(item.title) : item.title);
                }, "");
                if (suggestions && !this.isFallback)
                  prompt += suggestions, this.suggestions.length > 1 && (this.lineCount++, prompt += color.blue(`
Page `.concat(this.page + 1, "/").concat(this.suggestions.length)));
                else {
                  var fallbackIndex = getIndex(this.choices, this.fallback), fallbackTitle = fallbackIndex !== void 0 ? getTitle(this.choices, fallbackIndex) : this.fallback;
                  prompt += `
`.concat(color.gray(fallbackTitle)), this.lineCount++;
                }
              }
              if (this.out.write(this.clear + prompt), this.clear = clear(prompt), this.lineCount && !this.done) {
                var pos = cursor.up(this.lineCount);
                pos += cursor.left + cursor.to(length), pos += cursor.move(-this.rendered.length + this.cursor * this.scale), this.out.write(pos);
              }
            }
          }
        }
      ]), AutocompletePrompt2;
    }(Prompt);
    module2.exports = AutocompletePrompt;
  }
});

// ../../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect = __commonJS({
  "../../node_modules/prompts/dist/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), _require = require_src(), cursor = _require.cursor, MultiselectPrompt = require_multiselect(), _require2 = require_util2(), clear = _require2.clear, style = _require2.style, figures = _require2.figures, AutocompleteMultiselectPrompt = /* @__PURE__ */ function(MultiselectPrompt2) {
      _inherits10(AutocompleteMultiselectPrompt2, MultiselectPrompt2);
      var _super = _create_super10(AutocompleteMultiselectPrompt2);
      function AutocompleteMultiselectPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, AutocompleteMultiselectPrompt2);
        var _this;
        return opts.overrideRender = !0, _this = _super.call(this, opts), _this.inputValue = "", _this.clear = clear(""), _this.filteredOptions = _this.value, _this.render(), _this;
      }
      return _create_class13(AutocompleteMultiselectPrompt2, [
        {
          key: "last",
          value: function() {
            this.cursor = this.filteredOptions.length - 1, this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
          }
        },
        {
          key: "up",
          value: function() {
            this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
          }
        },
        {
          key: "down",
          value: function() {
            this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
          }
        },
        {
          key: "left",
          value: function() {
            this.filteredOptions[this.cursor].selected = !1, this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.value.filter(function(e) {
              return e.selected;
            }).length >= this.maxChoices)
              return this.bell();
            this.filteredOptions[this.cursor].selected = !0, this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
          }
        },
        {
          key: "updateFilteredOptions",
          value: function() {
            var _this = this, currentHighlight = this.filteredOptions[this.cursor];
            this.filteredOptions = this.value.filter(function(v) {
              return _this.inputValue ? !!(typeof v.title == "string" && v.title.toLowerCase().includes(_this.inputValue.toLowerCase()) || typeof v.value == "string" && v.value.toLowerCase().includes(_this.inputValue.toLowerCase())) : !0;
            });
            var newHighlightIndex = this.filteredOptions.findIndex(function(v) {
              return v === currentHighlight;
            });
            this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex, this.render();
          }
        },
        {
          key: "handleSpaceToggle",
          value: function() {
            var v = this.filteredOptions[this.cursor];
            if (v.selected)
              v.selected = !1, this.render();
            else {
              if (v.disabled || this.value.filter(function(e) {
                return e.selected;
              }).length >= this.maxChoices)
                return this.bell();
              v.selected = !0, this.render();
            }
          }
        },
        {
          key: "handleInputChange",
          value: function(c) {
            this.inputValue = this.inputValue + c, this.updateFilteredOptions();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            c === " " ? this.handleSpaceToggle() : this.handleInputChange(c);
          }
        },
        {
          key: "renderInstructions",
          value: function() {
            return `
Instructions:
    `.concat(figures.arrowUp, "/").concat(figures.arrowDown, `: Highlight option
    `).concat(figures.arrowLeft, "/").concat(figures.arrowRight, `/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
    `);
          }
        },
        {
          key: "renderCurrentInput",
          value: function() {
            return `
Filtered results for: `.concat(this.inputValue ? this.inputValue : color.gray("Enter something to filter"), `
`);
          }
        },
        {
          key: "renderOption",
          value: function(cursor2, v, i) {
            var title;
            return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
          }
        },
        {
          key: "renderDoneOrInstructions",
          value: function() {
            if (this.done) {
              var selected = this.value.filter(function(e) {
                return e.selected;
              }).map(function(v) {
                return v.title;
              }).join(", ");
              return selected;
            }
            var output = [
              color.gray(this.hint),
              this.renderInstructions(),
              this.renderCurrentInput()
            ];
            return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(AutocompleteMultiselectPrompt2.prototype), "render", this).call(this);
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(!1),
                this.renderDoneOrInstructions()
              ].join(" ");
              this.showMinError && (prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices.")), this.showMinError = !1), prompt += this.renderOptions(this.filteredOptions), this.out.write(this.clear + prompt), this.clear = clear(prompt);
            }
          }
        }
      ]), AutocompleteMultiselectPrompt2;
    }(MultiselectPrompt);
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/confirm.js
var require_confirm = __commonJS({
  "../../node_modules/prompts/dist/elements/confirm.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, _require2 = require_src(), erase = _require2.erase, cursor = _require2.cursor, ConfirmPrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(ConfirmPrompt2, Prompt2);
      var _super = _create_super10(ConfirmPrompt2);
      function ConfirmPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, ConfirmPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.value = opts.initial, _this.initialValue = !!opts.initial, _this.yesMsg = opts.yes || "yes", _this.yesOption = opts.yesOption || "(Y/n)", _this.noMsg = opts.no || "no", _this.noOption = opts.noOption || "(y/N)", _this.render(), _this;
      }
      return _create_class13(ConfirmPrompt2, [
        {
          key: "reset",
          value: function() {
            this.value = this.initialValue, this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            return c.toLowerCase() === "y" ? (this.value = !0, this.submit()) : c.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.bell();
          }
        },
        {
          key: "render",
          value: function() {
            this.closed || (this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(ConfirmPrompt2.prototype), "render", this).call(this), this.out.write(erase.line + cursor.to(0) + [
              style.symbol(this.done, this.aborted),
              color.bold(this.msg),
              style.delimiter(this.done),
              this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
            ].join(" ")));
          }
        }
      ]), ConfirmPrompt2;
    }(Prompt);
    module2.exports = ConfirmPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/index.js
var require_elements = __commonJS({
  "../../node_modules/prompts/dist/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text(),
      SelectPrompt: require_select(),
      TogglePrompt: require_toggle(),
      DatePrompt: require_date(),
      NumberPrompt: require_number(),
      MultiselectPrompt: require_multiselect(),
      AutocompletePrompt: require_autocomplete(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
      ConfirmPrompt: require_confirm()
    };
  }
});

// ../../node_modules/prompts/dist/prompts.js
var require_prompts = __commonJS({
  "../../node_modules/prompts/dist/prompts.js"(exports2) {
    "use strict";
    var $2 = exports2, el = require_elements(), noop2 = function(v) {
      return v;
    };
    function toPrompt(type, args) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return new Promise(function(res, rej) {
        var p = new el[type](args), onAbort = opts.onAbort || noop2, onSubmit = opts.onSubmit || noop2;
        p.on("state", args.onState || noop2), p.on("submit", function(x) {
          return res(onSubmit(x));
        }), p.on("abort", function(x) {
          return rej(onAbort(x));
        });
      });
    }
    $2.text = function(args) {
      return toPrompt("TextPrompt", args);
    };
    $2.password = function(args) {
      return args.style = "password", $2.text(args);
    };
    $2.invisible = function(args) {
      return args.style = "invisible", $2.text(args);
    };
    $2.number = function(args) {
      return toPrompt("NumberPrompt", args);
    };
    $2.date = function(args) {
      return toPrompt("DatePrompt", args);
    };
    $2.confirm = function(args) {
      return toPrompt("ConfirmPrompt", args);
    };
    $2.list = function(args) {
      var sep2 = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: function(str) {
          return str.split(sep2).map(function(s) {
            return s.trim();
          });
        }
      });
    };
    $2.toggle = function(args) {
      return toPrompt("TogglePrompt", args);
    };
    $2.select = function(args) {
      return toPrompt("SelectPrompt", args);
    };
    $2.multiselect = function(args) {
      args.choices = [].concat(args.choices || []);
      var toSelected = function(items) {
        return items.filter(function(item) {
          return item.selected;
        }).map(function(item) {
          return item.value;
        });
      };
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $2.autocompleteMultiselect = function(args) {
      args.choices = [].concat(args.choices || []);
      var toSelected = function(items) {
        return items.filter(function(item) {
          return item.selected;
        }).map(function(item) {
          return item.value;
        });
      };
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = function(input, choices) {
      return Promise.resolve(choices.filter(function(item) {
        return item.title.slice(0, input.length).toLowerCase() === input.toLowerCase();
      }));
    };
    $2.autocomplete = function(args) {
      return args.suggest = args.suggest || byTitle, args.choices = [].concat(args.choices || []), toPrompt("AutocompletePrompt", args);
    };
  }
});

// ../../node_modules/prompts/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/prompts/dist/index.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    var prompts5 = require_prompts(), passOn = [
      "suggest",
      "format",
      "onState",
      "validate",
      "onRender"
    ], noop2 = function() {
    };
    function prompt() {
      return _prompt.apply(this, arguments);
    }
    function _prompt() {
      return _prompt = _asyncToGenerator(function() {
        var questions, _ref, _ref_onSubmit, onSubmit, _ref_onCancel, onCancel, answers, _$override, answer, question, quit, name, type, getFormattedAnswer, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, _question, _tmp, _tmp1, _i, key, value, _tmp2, _question2, _tmp3, err, err1, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              questions = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : [], _ref = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, _ref_onSubmit = _ref.onSubmit, onSubmit = _ref_onSubmit === void 0 ? noop2 : _ref_onSubmit, _ref_onCancel = _ref.onCancel, onCancel = _ref_onCancel === void 0 ? noop2 : _ref_onCancel, answers = {}, _$override = prompt._override || {}, questions = [].concat(questions), getFormattedAnswer = /* @__PURE__ */ function() {
                var _ref2 = _asyncToGenerator(function(question2, answer2) {
                  var skipValidation, _tmp4, _arguments2 = arguments;
                  return _ts_generator31(this, function(_state2) {
                    switch (_state2.label) {
                      case 0:
                        return skipValidation = _arguments2.length > 2 && _arguments2[2] !== void 0 ? _arguments2[2] : !1, !skipValidation && question2.validate && question2.validate(answer2) !== !0 ? [
                          2
                        ] : question2.format ? [
                          4,
                          question2.format(answer2, answers)
                        ] : [
                          3,
                          2
                        ];
                      case 1:
                        return _tmp4 = _state2.sent(), [
                          3,
                          3
                        ];
                      case 2:
                        _tmp4 = answer2, _state2.label = 3;
                      case 3:
                        return [
                          2,
                          _tmp4
                        ];
                    }
                  });
                });
                return function(_x, _x2) {
                  return _ref2.apply(this, arguments);
                };
              }(), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
            case 1:
              _state.trys.push([
                1,
                21,
                22,
                23
              ]), _iterator = questions[Symbol.iterator](), _state.label = 2;
            case 2:
              if (_iteratorNormalCompletion2 = (_step = _iterator.next()).done)
                return [
                  3,
                  20
                ];
              question = _step.value, _question = question, name = _question.name, type = _question.type, _tmp = [];
              for (_tmp1 in question)
                _tmp.push(_tmp1);
              _i = 0, _state.label = 3;
            case 3:
              return _i < _tmp.length ? (key = _tmp[_i], passOn.includes(key) ? [
                3,
                7
              ] : (value = question[key], typeof value != "function" ? [
                3,
                5
              ] : [
                4,
                value(answer, _objectSpread({}, answers), question)
              ])) : [
                3,
                8
              ];
            case 4:
              return _tmp2 = _state.sent(), [
                3,
                6
              ];
            case 5:
              _tmp2 = value, _state.label = 6;
            case 6:
              question[key] = _tmp2, _state.label = 7;
            case 7:
              return _i++, [
                3,
                3
              ];
            case 8:
              if (typeof question.message != "string")
                throw new Error("prompt message is required");
              if (_question2 = question, name = _question2.name, type = _question2.type, !type)
                return [
                  3,
                  19
                ];
              if (prompts5[type] === void 0)
                throw new Error("prompt type (".concat(type, ") is not defined"));
              return _$override[question.name] === void 0 ? [
                3,
                10
              ] : [
                4,
                getFormattedAnswer(question, _$override[question.name])
              ];
            case 9:
              if (answer = _state.sent(), answer !== void 0)
                return answers[name] = answer, [
                  3,
                  19
                ];
              _state.label = 10;
            case 10:
              return _state.trys.push([
                10,
                16,
                ,
                18
              ]), prompt._injected ? (_tmp3 = getInjectedAnswer(prompt._injected), [
                3,
                13
              ]) : [
                3,
                11
              ];
            case 11:
              return [
                4,
                prompts5[type](question)
              ];
            case 12:
              _tmp3 = _state.sent(), _state.label = 13;
            case 13:
              return answer = _tmp3, [
                4,
                getFormattedAnswer(question, answer, !0)
              ];
            case 14:
              return answers[name] = answer = _state.sent(), [
                4,
                onSubmit(question, answer, answers)
              ];
            case 15:
              return quit = _state.sent(), [
                3,
                18
              ];
            case 16:
              return err = _state.sent(), [
                4,
                onCancel(question, answers)
              ];
            case 17:
              return quit = !_state.sent(), [
                3,
                18
              ];
            case 18:
              if (quit)
                return [
                  2,
                  answers
                ];
              _state.label = 19;
            case 19:
              return _iteratorNormalCompletion2 = !0, [
                3,
                2
              ];
            case 20:
              return [
                3,
                23
              ];
            case 21:
              return err1 = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err1, [
                3,
                23
              ];
            case 22:
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
              return [
                7
              ];
            case 23:
              return [
                2,
                answers
              ];
          }
        });
      }), _prompt.apply(this, arguments);
    }
    function getInjectedAnswer(injected) {
      var answer = injected.shift();
      if (_instanceof13(answer, Error))
        throw answer;
      return answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, {
      prompt,
      prompts: prompts5,
      inject,
      override
    });
  }
});

// ../../node_modules/prompts/lib/util/action.js
var require_action2 = __commonJS({
  "../../node_modules/prompts/lib/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = function(key) {
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c" || key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      return key.name === "return" || key.name === "enter" ? "submit" : key.name === "backspace" ? "delete" : key.name === "delete" ? "deleteForward" : key.name === "abort" || key.name === "escape" ? "abort" : key.name === "tab" ? "next" : key.name === "pagedown" ? "nextPage" : key.name === "pageup" ? "prevPage" : key.name === "up" ? "up" : key.name === "down" ? "down" : key.name === "right" ? "right" : key.name === "left" ? "left" : !1;
    };
  }
});

// ../../node_modules/prompts/lib/util/strip.js
var require_strip2 = __commonJS({
  "../../node_modules/prompts/lib/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str) {
      var pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
      ].join("|"), RGX = new RegExp(pattern, "g");
      return typeof str == "string" ? str.replace(RGX, "") : str;
    };
  }
});

// ../../node_modules/prompts/lib/util/clear.js
var require_clear2 = __commonJS({
  "../../node_modules/prompts/lib/util/clear.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var strip = require_strip2(), _require = require_src(), erase = _require.erase, cursor = _require.cursor, width = function(str) {
      return _to_consumable_array16(strip(str)).length;
    };
    module2.exports = function(prompt) {
      var perLine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : process.stdout.columns;
      if (!perLine)
        return erase.line + cursor.to(0);
      var rows = 0, lines = prompt.split(/\r?\n/), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var line = _step.value;
          rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
    };
  }
});

// ../../node_modules/prompts/lib/util/figures.js
var require_figures2 = __commonJS({
  "../../node_modules/prompts/lib/util/figures.js"(exports2, module2) {
    "use strict";
    var main6 = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    }, win = {
      arrowUp: main6.arrowUp,
      arrowDown: main6.arrowDown,
      arrowLeft: main6.arrowLeft,
      arrowRight: main6.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    }, figures = process.platform === "win32" ? win : main6;
    module2.exports = figures;
  }
});

// ../../node_modules/prompts/lib/util/style.js
var require_style2 = __commonJS({
  "../../node_modules/prompts/lib/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur(), figures = require_figures2(), styles3 = Object.freeze({
      password: {
        scale: 1,
        render: function(input) {
          return "*".repeat(input.length);
        }
      },
      emoji: {
        scale: 2,
        render: function(input) {
          return "\u{1F603}".repeat(input.length);
        }
      },
      invisible: {
        scale: 0,
        render: function(input) {
          return "";
        }
      },
      default: {
        scale: 1,
        render: function(input) {
          return "".concat(input);
        }
      }
    }), render = function(type) {
      return styles3[type] || styles3.default;
    }, symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      default: c.cyan("?")
    }), symbol = function(done, aborted) {
      return aborted ? symbols.aborted : done ? symbols.done : symbols.default;
    }, delimiter = function(completing) {
      return c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    }, item = function(expandable, expanded) {
      return c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    };
    module2.exports = {
      styles: styles3,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// ../../node_modules/prompts/lib/util/index.js
var require_util3 = __commonJS({
  "../../node_modules/prompts/lib/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action2(),
      clear: require_clear2(),
      style: require_style2(),
      strip: require_strip2(),
      figures: require_figures2()
    };
  }
});

// ../../node_modules/prompts/lib/elements/prompt.js
var require_prompt2 = __commonJS({
  "../../node_modules/prompts/lib/elements/prompt.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var readline = require("readline"), action = require_util3().action, EventEmitter3 = require("events"), _require = require_src(), beep = _require.beep, cursor = _require.cursor, color = require_kleur(), Prompt = /* @__PURE__ */ function(EventEmitter4) {
      _inherits10(Prompt2, EventEmitter4);
      var _super = _create_super10(Prompt2);
      function Prompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, Prompt2);
        var _this;
        _this = _super.call(this), _this.firstRender = !0, _this.in = opts.in || process.stdin, _this.out = opts.out || process.stdout, _this.onRender = (opts.onRender || function() {
        }).bind(_assert_this_initialized10(_this));
        var rl = readline.createInterface(_this.in);
        readline.emitKeypressEvents(_this.in, rl), _this.in.isTTY && _this.in.setRawMode(!0);
        var keypress = function(str, key) {
          var a = action(key);
          a === !1 ? _this._ && _this._(str, key) : typeof _this[a] == "function" ? _this[a](key) : _this.bell();
        };
        return _this.close = function() {
          _this.out.write(cursor.show), _this.in.removeListener("keypress", keypress), _this.in.isTTY && _this.in.setRawMode(!1), rl.close(), _this.emit(_this.aborted ? "abort" : "submit", _this.value), _this.closed = !0;
        }, _this.in.on("keypress", keypress), _this;
      }
      return _create_class13(Prompt2, [
        {
          key: "fire",
          value: function() {
            this.emit("state", {
              value: this.value,
              aborted: !!this.aborted
            });
          }
        },
        {
          key: "bell",
          value: function() {
            this.out.write(beep);
          }
        },
        {
          key: "render",
          value: function() {
            this.onRender(color), this.firstRender && (this.firstRender = !1);
          }
        }
      ]), Prompt2;
    }(EventEmitter3);
    module2.exports = Prompt;
  }
});

// ../../node_modules/prompts/lib/elements/text.js
var require_text2 = __commonJS({
  "../../node_modules/prompts/lib/elements/text.js"(exports2, module2) {
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var color = require_kleur(), Prompt = require_prompt2(), cursor = require_src().cursor, _require = require_util3(), style = _require.style, clear = _require.clear, strip = _require.strip, figures = _require.figures, TextPrompt = /* @__PURE__ */ function(Prompt2) {
      "use strict";
      _inherits10(TextPrompt2, Prompt2);
      var _super = _create_super10(TextPrompt2);
      function TextPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, TextPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.transform = style.render(opts.style), _this.scale = _this.transform.scale, _this.msg = opts.message, _this.initial = opts.initial || "", _this.validator = opts.validate || function() {
          return !0;
        }, _this.value = "", _this.errorMsg = opts.error || "Please Enter A Valid Value", _this.cursor = +!!_this.initial, _this.clear = clear(""), _this.render(), _this;
      }
      return _create_class13(TextPrompt2, [
        {
          key: "value",
          get: function() {
            return this._value;
          },
          set: function(v) {
            !v && this.initial ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.rendered = this.transform.render(v)), this._value = v, this.fire();
          }
        },
        {
          key: "reset",
          value: function() {
            this.value = "", this.cursor = +!!this.initial, this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "validate",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var valid;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validator(_this.value)
                    ];
                  case 1:
                    return valid = _state.sent(), typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid, [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "submit",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return _this.value = _this.value || _this.initial, [
                      4,
                      _this.validate()
                    ];
                  case 1:
                    return _state.sent(), _this.error ? (_this.red = !0, _this.fire(), _this.render(), [
                      2
                    ]) : (_this.done = !0, _this.aborted = !1, _this.fire(), _this.render(), _this.out.write(`
`), _this.close(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "next",
          value: function() {
            if (!this.placeholder)
              return this.bell();
            this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
          }
        },
        {
          key: "moveCursor",
          value: function(n) {
            this.placeholder || (this.cursor = this.cursor + n);
          }
        },
        {
          key: "_",
          value: function(c, key) {
            var s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor);
            this.value = "".concat(s1).concat(c).concat(s2), this.red = !1, this.cursor = this.placeholder ? 0 : s1.length + 1, this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            if (this.cursor === 0)
              return this.bell();
            var s1 = this.value.slice(0, this.cursor - 1), s2 = this.value.slice(this.cursor);
            this.value = "".concat(s1).concat(s2), this.red = !1, this.moveCursor(-1), this.render();
          }
        },
        {
          key: "deleteForward",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
              return this.bell();
            var s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor + 1);
            this.value = "".concat(s1).concat(s2), this.red = !1, this.render();
          }
        },
        {
          key: "first",
          value: function() {
            this.cursor = 0, this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.cursor = this.value.length, this.render();
          }
        },
        {
          key: "left",
          value: function() {
            if (this.cursor <= 0 || this.placeholder)
              return this.bell();
            this.moveCursor(-1), this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
              return this.bell();
            this.moveCursor(1), this.render();
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              _get4(_get_prototype_of10(TextPrompt2.prototype), "render", this).call(this);
              var erase = (this.lines ? cursor.down(this.lines) : "") + this.clear;
              this.lines = 0;
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(this.done),
                this.red ? color.red(this.rendered) : this.rendered
              ].join(" "), error = "";
              if (this.error) {
                var lines = this.errorMsg.split(`
`);
                error += lines.reduce(function(a, l, i) {
                  return a += `
`.concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l));
                }, ""), this.lines = lines.length;
              }
              var position = "";
              this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), position += cursor.move(this.placeholder ? -this.initial.length * this.scale : -this.rendered.length + this.cursor * this.scale), this.out.write(erase + prompt + error + position), this.clear = clear(prompt + error);
            }
          }
        }
      ]), TextPrompt2;
    }(Prompt);
    module2.exports = TextPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/select.js
var require_select2 = __commonJS({
  "../../node_modules/prompts/lib/elements/select.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), Prompt = require_prompt2(), _require = require_util3(), style = _require.style, clear = _require.clear, figures = _require.figures, _require1 = require_src(), erase = _require1.erase, cursor = _require1.cursor, SelectPrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(SelectPrompt2, Prompt2);
      var _super = _create_super10(SelectPrompt2);
      function SelectPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, SelectPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.hint = opts.hint || "- Use arrow-keys. Return to submit.", _this.warn = opts.warn || "- This option is disabled", _this.cursor = opts.initial || 0, _this.choices = opts.choices.map(function(ch, idx) {
          return typeof ch == "string" && (ch = {
            title: ch,
            value: idx
          }), {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value || idx),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        }), _this.value = (_this.choices[_this.cursor] || {}).value, _this.clear = clear(""), _this.render(), _this;
      }
      return _create_class13(SelectPrompt2, [
        {
          key: "moveCursor",
          value: function(n) {
            this.cursor = n, this.value = this.choices[n].value, this.fire();
          }
        },
        {
          key: "reset",
          value: function() {
            this.moveCursor(0), this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
          }
        },
        {
          key: "first",
          value: function() {
            this.moveCursor(0), this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.moveCursor(this.choices.length - 1), this.render();
          }
        },
        {
          key: "up",
          value: function() {
            if (this.cursor === 0)
              return this.bell();
            this.moveCursor(this.cursor - 1), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            if (this.cursor === this.choices.length - 1)
              return this.bell();
            this.moveCursor(this.cursor + 1), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (c === " ")
              return this.submit();
          }
        },
        {
          key: "selection",
          get: function() {
            return this.choices[this.cursor];
          }
        },
        {
          key: "render",
          value: function() {
            var _this = this;
            this.closed || (this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(this.choices.length + 1)), _get4(_get_prototype_of10(SelectPrompt2.prototype), "render", this).call(this), this.out.write([
              style.symbol(this.done, this.aborted),
              color.bold(this.msg),
              style.delimiter(!1),
              this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
            ].join(" ")), this.done || this.out.write(`
` + this.choices.map(function(v, i) {
              var title, prefix;
              return v.disabled ? (title = _this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title), prefix = _this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") : (title = _this.cursor === i ? color.cyan().underline(v.title) : v.title, prefix = _this.cursor === i ? color.cyan(figures.pointer) + " " : "  "), "".concat(prefix, " ").concat(title);
            }).join(`
`)));
          }
        }
      ]), SelectPrompt2;
    }(Prompt);
    module2.exports = SelectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/toggle.js
var require_toggle2 = __commonJS({
  "../../node_modules/prompts/lib/elements/toggle.js"(exports2, module2) {
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), Prompt = require_prompt2(), _require = require_util3(), style = _require.style, clear = _require.clear, _require1 = require_src(), cursor = _require1.cursor, erase = _require1.erase, TogglePrompt = /* @__PURE__ */ function(Prompt2) {
      "use strict";
      _inherits10(TogglePrompt2, Prompt2);
      var _super = _create_super10(TogglePrompt2);
      function TogglePrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, TogglePrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.value = !!opts.initial, _this.active = opts.active || "on", _this.inactive = opts.inactive || "off", _this.initialValue = _this.value, _this.render(), _this;
      }
      return _create_class13(TogglePrompt2, [
        {
          key: "reset",
          value: function() {
            this.value = this.initialValue, this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "deactivate",
          value: function() {
            if (this.value === !1)
              return this.bell();
            this.value = !1, this.render();
          }
        },
        {
          key: "activate",
          value: function() {
            if (this.value === !0)
              return this.bell();
            this.value = !0, this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            this.deactivate();
          }
        },
        {
          key: "left",
          value: function() {
            this.deactivate();
          }
        },
        {
          key: "right",
          value: function() {
            this.activate();
          }
        },
        {
          key: "down",
          value: function() {
            this.deactivate();
          }
        },
        {
          key: "up",
          value: function() {
            this.activate();
          }
        },
        {
          key: "next",
          value: function() {
            this.value = !this.value, this.fire(), this.render();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (c === " ")
              this.value = !this.value;
            else if (c === "1")
              this.value = !0;
            else if (c === "0")
              this.value = !1;
            else
              return this.bell();
            this.render();
          }
        },
        {
          key: "render",
          value: function() {
            this.closed || (this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(TogglePrompt2.prototype), "render", this).call(this), this.out.write(erase.lines(this.first ? 1 : this.msg.split(/\n/g).length) + cursor.to(0) + [
              style.symbol(this.done, this.aborted),
              color.bold(this.msg),
              style.delimiter(this.done),
              this.value ? this.inactive : color.cyan().underline(this.inactive),
              color.gray("/"),
              this.value ? color.cyan().underline(this.active) : this.active
            ].join(" ")));
          }
        }
      ]), TogglePrompt2;
    }(Prompt);
    module2.exports = TogglePrompt;
  }
});

// ../../node_modules/prompts/lib/dateparts/datepart.js
var require_datepart2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var DatePart = /* @__PURE__ */ function() {
      function DatePart2(param) {
        var token = param.token, date = param.date, parts = param.parts, locales = param.locales;
        _class_call_check15(this, DatePart2), this.token = token, this.date = date || /* @__PURE__ */ new Date(), this.parts = parts || [
          this
        ], this.locales = locales || {};
      }
      return _create_class13(DatePart2, [
        {
          key: "up",
          value: function() {
          }
        },
        {
          key: "down",
          value: function() {
          }
        },
        {
          key: "next",
          value: function() {
            var currentIdx = this.parts.indexOf(this);
            return this.parts.find(function(part, idx) {
              return idx > currentIdx && _instanceof13(part, DatePart2);
            });
          }
        },
        {
          key: "setTo",
          value: function(val) {
          }
        },
        {
          key: "prev",
          value: function() {
            var parts = [].concat(this.parts).reverse(), currentIdx = parts.indexOf(this);
            return parts.find(function(part, idx) {
              return idx > currentIdx && _instanceof13(part, DatePart2);
            });
          }
        },
        {
          key: "toString",
          value: function() {
            return String(this.date);
          }
        }
      ]), DatePart2;
    }();
    module2.exports = DatePart;
  }
});

// ../../node_modules/prompts/lib/dateparts/meridiem.js
var require_meridiem2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), Meridiem = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Meridiem2, DatePart2);
      var _super = _create_super10(Meridiem2);
      function Meridiem2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Meridiem2), _super.call(this, opts);
      }
      return _create_class13(Meridiem2, [
        {
          key: "up",
          value: function() {
            this.date.setHours((this.date.getHours() + 12) % 24);
          }
        },
        {
          key: "down",
          value: function() {
            this.up();
          }
        },
        {
          key: "toString",
          value: function() {
            var meridiem = this.date.getHours() > 12 ? "pm" : "am";
            return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
          }
        }
      ]), Meridiem2;
    }(DatePart);
    module2.exports = Meridiem;
  }
});

// ../../node_modules/prompts/lib/dateparts/day.js
var require_day2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/day.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), pos = function(n) {
      return n = n % 10, n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    }, Day = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Day2, DatePart2);
      var _super = _create_super10(Day2);
      function Day2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Day2), _super.call(this, opts);
      }
      return _create_class13(Day2, [
        {
          key: "up",
          value: function() {
            this.date.setDate(this.date.getDate() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setDate(this.date.getDate() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setDate(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var date = this.date.getDate(), day = this.date.getDay();
            return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
          }
        }
      ]), Day2;
    }(DatePart);
    module2.exports = Day;
  }
});

// ../../node_modules/prompts/lib/dateparts/hours.js
var require_hours2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/hours.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), Hours = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Hours2, DatePart2);
      var _super = _create_super10(Hours2);
      function Hours2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Hours2), _super.call(this, opts);
      }
      return _create_class13(Hours2, [
        {
          key: "up",
          value: function() {
            this.date.setHours(this.date.getHours() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setHours(this.date.getHours() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setHours(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var hours = this.date.getHours();
            return /h/.test(this.token) && (hours = hours % 12 || 12), this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
          }
        }
      ]), Hours2;
    }(DatePart);
    module2.exports = Hours;
  }
});

// ../../node_modules/prompts/lib/dateparts/milliseconds.js
var require_milliseconds2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), Milliseconds = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Milliseconds2, DatePart2);
      var _super = _create_super10(Milliseconds2);
      function Milliseconds2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Milliseconds2), _super.call(this, opts);
      }
      return _create_class13(Milliseconds2, [
        {
          key: "up",
          value: function() {
            this.date.setMilliseconds(this.date.getMilliseconds() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setMilliseconds(this.date.getMilliseconds() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
          }
        },
        {
          key: "toString",
          value: function() {
            return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
          }
        }
      ]), Milliseconds2;
    }(DatePart);
    module2.exports = Milliseconds;
  }
});

// ../../node_modules/prompts/lib/dateparts/minutes.js
var require_minutes2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), Minutes = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Minutes2, DatePart2);
      var _super = _create_super10(Minutes2);
      function Minutes2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Minutes2), _super.call(this, opts);
      }
      return _create_class13(Minutes2, [
        {
          key: "up",
          value: function() {
            this.date.setMinutes(this.date.getMinutes() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setMinutes(this.date.getMinutes() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setMinutes(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var m = this.date.getMinutes();
            return this.token.length > 1 ? String(m).padStart(2, "0") : m;
          }
        }
      ]), Minutes2;
    }(DatePart);
    module2.exports = Minutes;
  }
});

// ../../node_modules/prompts/lib/dateparts/month.js
var require_month2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/month.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), Month = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Month2, DatePart2);
      var _super = _create_super10(Month2);
      function Month2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Month2), _super.call(this, opts);
      }
      return _create_class13(Month2, [
        {
          key: "up",
          value: function() {
            this.date.setMonth(this.date.getMonth() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setMonth(this.date.getMonth() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            val = parseInt(val.substr(-2)) - 1, this.date.setMonth(val < 0 ? 0 : val);
          }
        },
        {
          key: "toString",
          value: function() {
            var month = this.date.getMonth(), tl = this.token.length;
            return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
          }
        }
      ]), Month2;
    }(DatePart);
    module2.exports = Month;
  }
});

// ../../node_modules/prompts/lib/dateparts/seconds.js
var require_seconds2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), Seconds = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Seconds2, DatePart2);
      var _super = _create_super10(Seconds2);
      function Seconds2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Seconds2), _super.call(this, opts);
      }
      return _create_class13(Seconds2, [
        {
          key: "up",
          value: function() {
            this.date.setSeconds(this.date.getSeconds() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setSeconds(this.date.getSeconds() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setSeconds(parseInt(val.substr(-2)));
          }
        },
        {
          key: "toString",
          value: function() {
            var s = this.date.getSeconds();
            return this.token.length > 1 ? String(s).padStart(2, "0") : s;
          }
        }
      ]), Seconds2;
    }(DatePart);
    module2.exports = Seconds;
  }
});

// ../../node_modules/prompts/lib/dateparts/year.js
var require_year2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/year.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var DatePart = require_datepart2(), Year = /* @__PURE__ */ function(DatePart2) {
      _inherits10(Year2, DatePart2);
      var _super = _create_super10(Year2);
      function Year2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _class_call_check15(this, Year2), _super.call(this, opts);
      }
      return _create_class13(Year2, [
        {
          key: "up",
          value: function() {
            this.date.setFullYear(this.date.getFullYear() + 1);
          }
        },
        {
          key: "down",
          value: function() {
            this.date.setFullYear(this.date.getFullYear() - 1);
          }
        },
        {
          key: "setTo",
          value: function(val) {
            this.date.setFullYear(val.substr(-4));
          }
        },
        {
          key: "toString",
          value: function() {
            var year = String(this.date.getFullYear()).padStart(4, "0");
            return this.token.length === 2 ? year.substr(-2) : year;
          }
        }
      ]), Year2;
    }(DatePart);
    module2.exports = Year;
  }
});

// ../../node_modules/prompts/lib/dateparts/index.js
var require_dateparts2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart2(),
      Meridiem: require_meridiem2(),
      Day: require_day2(),
      Hours: require_hours2(),
      Milliseconds: require_milliseconds2(),
      Minutes: require_minutes2(),
      Month: require_month2(),
      Seconds: require_seconds2(),
      Year: require_year2()
    };
  }
});

// ../../node_modules/prompts/lib/elements/date.js
var require_date2 = __commonJS({
  "../../node_modules/prompts/lib/elements/date.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var color = require_kleur(), Prompt = require_prompt2(), _require = require_util3(), style = _require.style, clear = _require.clear, figures = _require.figures, strip = _require.strip, _require1 = require_src(), erase = _require1.erase, cursor = _require1.cursor, _require2 = require_dateparts2(), DatePart = _require2.DatePart, Meridiem = _require2.Meridiem, Day = _require2.Day, Hours = _require2.Hours, Milliseconds = _require2.Milliseconds, Minutes = _require2.Minutes, Month = _require2.Month, Seconds = _require2.Seconds, Year = _require2.Year, regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, regexGroups = {
      1: function(param) {
        var token = param.token;
        return token.replace(/\\(.)/g, "$1");
      },
      2: function(opts) {
        return new Day(opts);
      },
      // Day // TODO
      3: function(opts) {
        return new Month(opts);
      },
      // Month
      4: function(opts) {
        return new Year(opts);
      },
      // Year
      5: function(opts) {
        return new Meridiem(opts);
      },
      // AM/PM // TODO (special)
      6: function(opts) {
        return new Hours(opts);
      },
      // Hours
      7: function(opts) {
        return new Minutes(opts);
      },
      // Minutes
      8: function(opts) {
        return new Seconds(opts);
      },
      // Seconds
      9: function(opts) {
        return new Milliseconds(opts);
      }
    }, dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    }, DatePrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(DatePrompt2, Prompt2);
      var _super = _create_super10(DatePrompt2);
      function DatePrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, DatePrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.cursor = 0, _this.typed = "", _this.locales = Object.assign(dfltLocales, opts.locales), _this._date = opts.initial || /* @__PURE__ */ new Date(), _this.errorMsg = opts.error || "Please Enter A Valid Value", _this.validator = opts.validate || function() {
          return !0;
        }, _this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss", _this.clear = clear(""), _this.render(), _this;
      }
      return _create_class13(DatePrompt2, [
        {
          key: "value",
          get: function() {
            return this.date;
          }
        },
        {
          key: "date",
          get: function() {
            return this._date;
          },
          set: function(date) {
            date && this._date.setTime(date.getTime());
          }
        },
        {
          key: "mask",
          set: function(mask) {
            var _this_parts, result;
            for (this.parts = []; result = regex.exec(mask); ) {
              var match2 = result.shift(), idx = result.findIndex(function(gr) {
                return gr != null;
              });
              this.parts.push(idx in regexGroups ? regexGroups[idx]({
                token: result[idx] || match2,
                date: this.date,
                parts: this.parts,
                locales: this.locales
              }) : result[idx] || match2);
            }
            var parts = this.parts.reduce(function(arr, i) {
              return typeof i == "string" && typeof arr[arr.length - 1] == "string" ? arr[arr.length - 1] += i : arr.push(i), arr;
            }, []);
            this.parts.splice(0), (_this_parts = this.parts).push.apply(_this_parts, _to_consumable_array16(parts)), this.reset();
          }
        },
        {
          key: "moveCursor",
          value: function(n) {
            this.typed = "", this.cursor = n, this.fire();
          }
        },
        {
          key: "reset",
          value: function() {
            this.moveCursor(this.parts.findIndex(function(p) {
              return _instanceof13(p, DatePart);
            })), this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "validate",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var valid;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validator(_this.value)
                    ];
                  case 1:
                    return valid = _state.sent(), typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid, [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "submit",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validate()
                    ];
                  case 1:
                    return _state.sent(), _this.error ? (_this.color = "red", _this.fire(), _this.render(), [
                      2
                    ]) : (_this.done = !0, _this.aborted = !1, _this.fire(), _this.render(), _this.out.write(`
`), _this.close(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "up",
          value: function() {
            this.typed = "", this.parts[this.cursor].up(), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            this.typed = "", this.parts[this.cursor].down(), this.render();
          }
        },
        {
          key: "left",
          value: function() {
            var prev = this.parts[this.cursor].prev();
            if (prev == null)
              return this.bell();
            this.moveCursor(this.parts.indexOf(prev)), this.render();
          }
        },
        {
          key: "right",
          value: function() {
            var next = this.parts[this.cursor].next();
            if (next == null)
              return this.bell();
            this.moveCursor(this.parts.indexOf(next)), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            var next2 = this.parts[this.cursor].next();
            this.moveCursor(next2 ? this.parts.indexOf(next2) : this.parts.findIndex(function(part) {
              return _instanceof13(part, DatePart);
            })), this.render();
          }
        },
        {
          key: "_",
          value: function(c) {
            /\d/.test(c) && (this.typed += c, this.parts[this.cursor].setTo(this.typed), this.render());
          }
        },
        {
          key: "render",
          value: function() {
            var _this = this;
            if (!this.closed) {
              this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(1)), _get4(_get_prototype_of10(DatePrompt2.prototype), "render", this).call(this);
              var clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
              this.lines = 0;
              var error = "";
              if (this.error) {
                var lines = this.errorMsg.split(`
`);
                error = lines.reduce(function(a, l, i) {
                  return a + `
`.concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l));
                }, ""), this.lines = lines.length;
              }
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(!1),
                this.parts.reduce(function(arr, p, idx) {
                  return arr.concat(idx === _this.cursor && !_this.done ? color.cyan().underline(p.toString()) : p);
                }, []).join("")
              ].join(" "), position = "";
              this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
            }
          }
        }
      ]), DatePrompt2;
    }(Prompt);
    module2.exports = DatePrompt;
  }
});

// ../../node_modules/prompts/lib/elements/number.js
var require_number2 = __commonJS({
  "../../node_modules/prompts/lib/elements/number.js"(exports2, module2) {
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var color = require_kleur(), Prompt = require_prompt2(), _require = require_src(), cursor = _require.cursor, erase = _require.erase, _require1 = require_util3(), style = _require1.style, clear = _require1.clear, figures = _require1.figures, strip = _require1.strip, isNumber = /[0-9]/, isDef = function(any) {
      return any !== void 0;
    }, round = function(number, precision) {
      var factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    }, NumberPrompt = /* @__PURE__ */ function(Prompt2) {
      "use strict";
      _inherits10(NumberPrompt2, Prompt2);
      var _super = _create_super10(NumberPrompt2);
      function NumberPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, NumberPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.transform = style.render(opts.style), _this.msg = opts.message, _this.initial = isDef(opts.initial) ? opts.initial : "", _this.float = !!opts.float, _this.round = opts.round || 2, _this.inc = opts.increment || 1, _this.min = isDef(opts.min) ? opts.min : -1 / 0, _this.max = isDef(opts.max) ? opts.max : 1 / 0, _this.errorMsg = opts.error || "Please Enter A Valid Value", _this.validator = opts.validate || function() {
          return !0;
        }, _this.color = "cyan", _this.value = "", _this.typed = "", _this.lastHit = 0, _this.render(), _this;
      }
      return _create_class13(NumberPrompt2, [
        {
          key: "value",
          get: function() {
            return this._value;
          },
          set: function(v) {
            !v && v !== 0 ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render("".concat(this.initial))), this._value = "") : (this.placeholder = !1, this.rendered = this.transform.render("".concat(round(v, this.round))), this._value = round(v, this.round)), this.fire();
          }
        },
        {
          key: "parse",
          value: function(x) {
            return this.float ? parseFloat(x) : parseInt(x);
          }
        },
        {
          key: "valid",
          value: function(c) {
            return c === "-" || c === "." && this.float || isNumber.test(c);
          }
        },
        {
          key: "reset",
          value: function() {
            this.typed = "", this.value = "", this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            var x = this.value;
            this.value = x !== "" ? x : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "validate",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var valid;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validator(_this.value)
                    ];
                  case 1:
                    return valid = _state.sent(), typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid, [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "submit",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var x;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.validate()
                    ];
                  case 1:
                    return _state.sent(), _this.error ? (_this.color = "red", _this.fire(), _this.render(), [
                      2
                    ]) : (x = _this.value, _this.value = x !== "" ? x : _this.initial, _this.done = !0, _this.aborted = !1, _this.error = !1, _this.fire(), _this.render(), _this.out.write(`
`), _this.close(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "up",
          value: function() {
            if (this.typed = "", this.value >= this.max)
              return this.bell();
            this.value += this.inc, this.color = "cyan", this.fire(), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            if (this.typed = "", this.value <= this.min)
              return this.bell();
            this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            var val = this.value.toString();
            if (val.length === 0)
              return this.bell();
            this.value = this.parse(val = val.slice(0, -1)) || "", this.color = "cyan", this.fire(), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.value = this.initial, this.fire(), this.render();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (!this.valid(c))
              return this.bell();
            var now = Date.now();
            if (now - this.lastHit > 1e3 && (this.typed = ""), this.typed += c, this.lastHit = now, this.color = "cyan", c === ".")
              return this.fire();
            this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.value = this.min), this.fire(), this.render();
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              _get4(_get_prototype_of10(NumberPrompt2.prototype), "render", this).call(this);
              var clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
              this.lines = 0;
              var error = "";
              if (this.error) {
                var lines = this.errorMsg.split(`
`);
                error += lines.reduce(function(a, l, i) {
                  return a + `
`.concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l));
                }, ""), this.lines = lines.length;
              }
              var underline = !this.done || !this.done && !this.placeholder, prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(this.done),
                underline ? color[this.color]().underline(this.rendered) : this.rendered
              ].join(" "), position = "";
              this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
            }
          }
        }
      ]), NumberPrompt2;
    }(Prompt);
    module2.exports = NumberPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/multiselect.js
var require_multiselect2 = __commonJS({
  "../../node_modules/prompts/lib/elements/multiselect.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), cursor = require_src().cursor, Prompt = require_prompt2(), _require = require_util3(), clear = _require.clear, figures = _require.figures, style = _require.style, MultiselectPrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(MultiselectPrompt2, Prompt2);
      var _super = _create_super10(MultiselectPrompt2);
      function MultiselectPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, MultiselectPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.cursor = opts.cursor || 0, _this.scrollIndex = opts.cursor || 0, _this.hint = opts.hint || "", _this.warn = opts.warn || "- This option is disabled -", _this.minSelected = opts.min, _this.showMinError = !1, _this.maxChoices = opts.max, _this.value = opts.choices.map(function(ch, idx) {
          return typeof ch == "string" && (ch = {
            title: ch,
            value: idx
          }), {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value || idx),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        }), _this.clear = clear(""), opts.overrideRender || _this.render(), _this;
      }
      return _create_class13(MultiselectPrompt2, [
        {
          key: "reset",
          value: function() {
            this.value.map(function(v) {
              return !v.selected;
            }), this.cursor = 0, this.fire(), this.render();
          }
        },
        {
          key: "selected",
          value: function() {
            return this.value.filter(function(v) {
              return v.selected;
            });
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            var selected = this.value.filter(function(e) {
              return e.selected;
            });
            this.minSelected && selected.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
          }
        },
        {
          key: "first",
          value: function() {
            this.cursor = 0, this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.cursor = this.value.length - 1, this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.cursor = (this.cursor + 1) % this.value.length, this.render();
          }
        },
        {
          key: "up",
          value: function() {
            this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
          }
        },
        {
          key: "down",
          value: function() {
            this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
          }
        },
        {
          key: "left",
          value: function() {
            this.value[this.cursor].selected = !1, this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.value.filter(function(e) {
              return e.selected;
            }).length >= this.maxChoices)
              return this.bell();
            this.value[this.cursor].selected = !0, this.render();
          }
        },
        {
          key: "handleSpaceToggle",
          value: function() {
            var v = this.value[this.cursor];
            if (v.selected)
              v.selected = !1, this.render();
            else {
              if (v.disabled || this.value.filter(function(e) {
                return e.selected;
              }).length >= this.maxChoices)
                return this.bell();
              v.selected = !0, this.render();
            }
          }
        },
        {
          key: "_",
          value: function(c, key) {
            if (c === " ")
              this.handleSpaceToggle();
            else
              return this.bell();
          }
        },
        {
          key: "renderInstructions",
          value: function() {
            return `
Instructions:
    `.concat(figures.arrowUp, "/").concat(figures.arrowDown, `: Highlight option
    `).concat(figures.arrowLeft, "/").concat(figures.arrowRight, `/[space]: Toggle selection
    enter/return: Complete answer
    `);
          }
        },
        {
          key: "renderOption",
          value: function(cursor2, v, i) {
            var title;
            return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
          }
        },
        {
          // shared with autocompleteMultiselect
          key: "paginateOptions",
          value: function(options) {
            var _this = this, c = this.cursor, styledOptions = options.map(function(v, i) {
              return _this.renderOption(c, v, i);
            }), numOfOptionsToRender = 10, scopedOptions = styledOptions, hint = "";
            if (styledOptions.length === 0)
              return color.red("No matches for this query.");
            if (styledOptions.length > numOfOptionsToRender) {
              var startIndex = c - numOfOptionsToRender / 2, endIndex = c + numOfOptionsToRender / 2;
              startIndex < 0 ? (startIndex = 0, endIndex = numOfOptionsToRender) : endIndex > options.length && (endIndex = options.length, startIndex = endIndex - numOfOptionsToRender), scopedOptions = styledOptions.slice(startIndex, endIndex), hint = color.dim("(Move up and down to reveal more choices)");
            }
            return `
` + scopedOptions.join(`
`) + `
` + hint;
          }
        },
        {
          // shared with autocomleteMultiselect
          key: "renderOptions",
          value: function(options) {
            return this.done ? "" : this.paginateOptions(options);
          }
        },
        {
          key: "renderDoneOrInstructions",
          value: function() {
            if (this.done) {
              var selected = this.value.filter(function(e) {
                return e.selected;
              }).map(function(v) {
                return v.title;
              }).join(", ");
              return selected;
            }
            var output = [
              color.gray(this.hint),
              this.renderInstructions()
            ];
            return this.value[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(MultiselectPrompt2.prototype), "render", this).call(this);
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(!1),
                this.renderDoneOrInstructions()
              ].join(" ");
              this.showMinError && (prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices.")), this.showMinError = !1), prompt += this.renderOptions(this.value), this.out.write(this.clear + prompt), this.clear = clear(prompt);
            }
          }
        }
      ]), MultiselectPrompt2;
    }(Prompt);
    module2.exports = MultiselectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/autocomplete.js
var require_autocomplete2 = __commonJS({
  "../../node_modules/prompts/lib/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var color = require_kleur(), Prompt = require_prompt2(), cursor = require_src().cursor, _require = require_util3(), style = _require.style, clear = _require.clear, figures = _require.figures, strip = _require.strip, getVal = function(arr, i) {
      return arr[i] && (arr[i].value || arr[i].title || arr[i]);
    }, getTitle = function(arr, i) {
      return arr[i] && (arr[i].title || arr[i].value || arr[i]);
    }, getIndex = function(arr, valOrTitle) {
      var index = arr.findIndex(function(el) {
        return el.value === valOrTitle || el.title === valOrTitle;
      });
      return index > -1 ? index : void 0;
    }, AutocompletePrompt = /* @__PURE__ */ function(Prompt2) {
      _inherits10(AutocompletePrompt2, Prompt2);
      var _super = _create_super10(AutocompletePrompt2);
      function AutocompletePrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, AutocompletePrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.suggest = opts.suggest, _this.choices = opts.choices, _this.initial = typeof opts.initial == "number" ? opts.initial : getIndex(opts.choices, opts.initial), _this.select = _this.initial || opts.cursor || 0, _this.fallback = opts.fallback || (opts.initial !== void 0 ? "".concat(figures.pointerSmall, " ").concat(getTitle(_this.choices, _this.initial)) : "".concat(figures.pointerSmall, " ").concat(opts.noMatches || "no matches found")), _this.suggestions = [
          []
        ], _this.page = 0, _this.input = "", _this.limit = opts.limit || 10, _this.cursor = 0, _this.transform = style.render(opts.style), _this.scale = _this.transform.scale, _this.render = _this.render.bind(_assert_this_initialized10(_this)), _this.complete = _this.complete.bind(_assert_this_initialized10(_this)), _this.clear = clear(""), _this.complete(_this.render), _this.render(), _this;
      }
      return _create_class13(AutocompletePrompt2, [
        {
          key: "moveSelect",
          value: function(i) {
            this.select = i, this.suggestions[this.page].length > 0 ? this.value = getVal(this.suggestions[this.page], i) : this.value = this.initial !== void 0 ? getVal(this.choices, this.initial) : null, this.fire();
          }
        },
        {
          key: "complete",
          value: function(cb) {
            var _this = this;
            return _async_to_generator31(function() {
              var p, suggestions, index, l;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return p = _this.completing = _this.suggest(_this.input, _this.choices), [
                      4,
                      p
                    ];
                  case 1:
                    return suggestions = _state.sent(), _this.completing !== p ? [
                      2
                    ] : (_this.suggestions = suggestions.map(function(s, i, arr) {
                      return {
                        title: getTitle(arr, i),
                        value: getVal(arr, i)
                      };
                    }).reduce(function(arr, sug) {
                      return arr[arr.length - 1].length < _this.limit ? arr[arr.length - 1].push(sug) : arr.push([
                        sug
                      ]), arr;
                    }, [
                      []
                    ]), _this.isFallback = !1, _this.completing = !1, _this.suggestions[_this.page] || (_this.page = 0), !_this.suggestions.length && _this.fallback && (index = getIndex(_this.choices, _this.fallback), _this.suggestions = [
                      []
                    ], index !== void 0 && _this.suggestions[0].push({
                      title: getTitle(_this.choices, index),
                      value: getVal(_this.choices, index)
                    }), _this.isFallback = !0), l = Math.max(suggestions.length - 1, 0), _this.moveSelect(Math.min(l, _this.select)), cb && cb(), [
                      2
                    ]);
                }
              });
            })();
          }
        },
        {
          key: "reset",
          value: function() {
            var _this = this;
            this.input = "", this.complete(function() {
              _this.moveSelect(_this.initial !== void 0 ? _this.initial : 0), _this.render();
            }), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            var s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor);
            this.input = "".concat(s1).concat(c).concat(s2), this.cursor = s1.length + 1, this.complete(this.render), this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            if (this.cursor === 0)
              return this.bell();
            var s1 = this.input.slice(0, this.cursor - 1), s2 = this.input.slice(this.cursor);
            this.input = "".concat(s1).concat(s2), this.complete(this.render), this.cursor = this.cursor - 1, this.render();
          }
        },
        {
          key: "deleteForward",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length)
              return this.bell();
            var s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor + 1);
            this.input = "".concat(s1).concat(s2), this.complete(this.render), this.render();
          }
        },
        {
          key: "first",
          value: function() {
            this.moveSelect(0), this.render();
          }
        },
        {
          key: "last",
          value: function() {
            this.moveSelect(this.suggestions[this.page].length - 1), this.render();
          }
        },
        {
          key: "up",
          value: function() {
            if (this.select <= 0)
              return this.bell();
            this.moveSelect(this.select - 1), this.render();
          }
        },
        {
          key: "down",
          value: function() {
            if (this.select >= this.suggestions[this.page].length - 1)
              return this.bell();
            this.moveSelect(this.select + 1), this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.select === this.suggestions[this.page].length - 1 ? (this.page = (this.page + 1) % this.suggestions.length, this.moveSelect(0)) : this.moveSelect(this.select + 1), this.render();
          }
        },
        {
          key: "nextPage",
          value: function() {
            if (this.page >= this.suggestions.length - 1)
              return this.bell();
            this.page++, this.moveSelect(0), this.render();
          }
        },
        {
          key: "prevPage",
          value: function() {
            if (this.page <= 0)
              return this.bell();
            this.page--, this.moveSelect(0), this.render();
          }
        },
        {
          key: "left",
          value: function() {
            if (this.cursor <= 0)
              return this.bell();
            this.cursor = this.cursor - 1, this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.cursor * this.scale >= this.rendered.length)
              return this.bell();
            this.cursor = this.cursor + 1, this.render();
          }
        },
        {
          key: "render",
          value: function() {
            var _this = this;
            if (!this.closed) {
              _get4(_get_prototype_of10(AutocompletePrompt2.prototype), "render", this).call(this), this.lineCount && this.out.write(cursor.down(this.lineCount));
              var prompt = color.bold("".concat(style.symbol(this.done, this.aborted), " ").concat(this.msg, " ")) + "".concat(style.delimiter(this.completing), " "), length = strip(prompt).length;
              if (this.done && this.suggestions[this.page][this.select] ? prompt += "".concat(this.suggestions[this.page][this.select].title) : (this.rendered = "".concat(this.transform.render(this.input)), length += this.rendered.length, prompt += this.rendered), !this.done) {
                this.lineCount = this.suggestions[this.page].length;
                var suggestions = this.suggestions[this.page].reduce(function(acc, item, i) {
                  return acc + `
`.concat(i === _this.select ? color.cyan(item.title) : item.title);
                }, "");
                if (suggestions && !this.isFallback)
                  prompt += suggestions, this.suggestions.length > 1 && (this.lineCount++, prompt += color.blue(`
Page `.concat(this.page + 1, "/").concat(this.suggestions.length)));
                else {
                  var fallbackIndex = getIndex(this.choices, this.fallback), fallbackTitle = fallbackIndex !== void 0 ? getTitle(this.choices, fallbackIndex) : this.fallback;
                  prompt += `
`.concat(color.gray(fallbackTitle)), this.lineCount++;
                }
              }
              if (this.out.write(this.clear + prompt), this.clear = clear(prompt), this.lineCount && !this.done) {
                var pos = cursor.up(this.lineCount);
                pos += cursor.left + cursor.to(length), pos += cursor.move(-this.rendered.length + this.cursor * this.scale), this.out.write(pos);
              }
            }
          }
        }
      ]), AutocompletePrompt2;
    }(Prompt);
    module2.exports = AutocompletePrompt;
  }
});

// ../../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect2 = __commonJS({
  "../../node_modules/prompts/lib/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), cursor = require_src().cursor, MultiselectPrompt = require_multiselect2(), _require = require_util3(), clear = _require.clear, style = _require.style, figures = _require.figures, AutocompleteMultiselectPrompt = /* @__PURE__ */ function(MultiselectPrompt2) {
      _inherits10(AutocompleteMultiselectPrompt2, MultiselectPrompt2);
      var _super = _create_super10(AutocompleteMultiselectPrompt2);
      function AutocompleteMultiselectPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, AutocompleteMultiselectPrompt2);
        var _this;
        return opts.overrideRender = !0, _this = _super.call(this, opts), _this.inputValue = "", _this.clear = clear(""), _this.filteredOptions = _this.value, _this.render(), _this;
      }
      return _create_class13(AutocompleteMultiselectPrompt2, [
        {
          key: "last",
          value: function() {
            this.cursor = this.filteredOptions.length - 1, this.render();
          }
        },
        {
          key: "next",
          value: function() {
            this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
          }
        },
        {
          key: "up",
          value: function() {
            this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
          }
        },
        {
          key: "down",
          value: function() {
            this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
          }
        },
        {
          key: "left",
          value: function() {
            this.filteredOptions[this.cursor].selected = !1, this.render();
          }
        },
        {
          key: "right",
          value: function() {
            if (this.value.filter(function(e) {
              return e.selected;
            }).length >= this.maxChoices)
              return this.bell();
            this.filteredOptions[this.cursor].selected = !0, this.render();
          }
        },
        {
          key: "delete",
          value: function() {
            this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
          }
        },
        {
          key: "updateFilteredOptions",
          value: function() {
            var _this = this, currentHighlight = this.filteredOptions[this.cursor];
            this.filteredOptions = this.value.filter(function(v) {
              return _this.inputValue ? !!(typeof v.title == "string" && v.title.toLowerCase().includes(_this.inputValue.toLowerCase()) || typeof v.value == "string" && v.value.toLowerCase().includes(_this.inputValue.toLowerCase())) : !0;
            });
            var newHighlightIndex = this.filteredOptions.findIndex(function(v) {
              return v === currentHighlight;
            });
            this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex, this.render();
          }
        },
        {
          key: "handleSpaceToggle",
          value: function() {
            var v = this.filteredOptions[this.cursor];
            if (v.selected)
              v.selected = !1, this.render();
            else {
              if (v.disabled || this.value.filter(function(e) {
                return e.selected;
              }).length >= this.maxChoices)
                return this.bell();
              v.selected = !0, this.render();
            }
          }
        },
        {
          key: "handleInputChange",
          value: function(c) {
            this.inputValue = this.inputValue + c, this.updateFilteredOptions();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            c === " " ? this.handleSpaceToggle() : this.handleInputChange(c);
          }
        },
        {
          key: "renderInstructions",
          value: function() {
            return `
Instructions:
    `.concat(figures.arrowUp, "/").concat(figures.arrowDown, `: Highlight option
    `).concat(figures.arrowLeft, "/").concat(figures.arrowRight, `/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
    `);
          }
        },
        {
          key: "renderCurrentInput",
          value: function() {
            return `
Filtered results for: `.concat(this.inputValue ? this.inputValue : color.gray("Enter something to filter"), `
`);
          }
        },
        {
          key: "renderOption",
          value: function(cursor2, v, i) {
            var title;
            return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
          }
        },
        {
          key: "renderDoneOrInstructions",
          value: function() {
            if (this.done) {
              var selected = this.value.filter(function(e) {
                return e.selected;
              }).map(function(v) {
                return v.title;
              }).join(", ");
              return selected;
            }
            var output = [
              color.gray(this.hint),
              this.renderInstructions(),
              this.renderCurrentInput()
            ];
            return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
          }
        },
        {
          key: "render",
          value: function() {
            if (!this.closed) {
              this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(AutocompleteMultiselectPrompt2.prototype), "render", this).call(this);
              var prompt = [
                style.symbol(this.done, this.aborted),
                color.bold(this.msg),
                style.delimiter(!1),
                this.renderDoneOrInstructions()
              ].join(" ");
              this.showMinError && (prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices.")), this.showMinError = !1), prompt += this.renderOptions(this.filteredOptions), this.out.write(this.clear + prompt), this.clear = clear(prompt);
            }
          }
        }
      ]), AutocompleteMultiselectPrompt2;
    }(MultiselectPrompt);
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/confirm.js
var require_confirm2 = __commonJS({
  "../../node_modules/prompts/lib/elements/confirm.js"(exports2, module2) {
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var color = require_kleur(), Prompt = require_prompt2(), style = require_util3().style, _require = require_src(), erase = _require.erase, cursor = _require.cursor, ConfirmPrompt = /* @__PURE__ */ function(Prompt2) {
      "use strict";
      _inherits10(ConfirmPrompt2, Prompt2);
      var _super = _create_super10(ConfirmPrompt2);
      function ConfirmPrompt2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, ConfirmPrompt2);
        var _this;
        return _this = _super.call(this, opts), _this.msg = opts.message, _this.value = opts.initial, _this.initialValue = !!opts.initial, _this.yesMsg = opts.yes || "yes", _this.yesOption = opts.yesOption || "(Y/n)", _this.noMsg = opts.no || "no", _this.noOption = opts.noOption || "(y/N)", _this.render(), _this;
      }
      return _create_class13(ConfirmPrompt2, [
        {
          key: "reset",
          value: function() {
            this.value = this.initialValue, this.fire(), this.render();
          }
        },
        {
          key: "abort",
          value: function() {
            this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "submit",
          value: function() {
            this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
          }
        },
        {
          key: "_",
          value: function(c, key) {
            return c.toLowerCase() === "y" ? (this.value = !0, this.submit()) : c.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.bell();
          }
        },
        {
          key: "render",
          value: function() {
            this.closed || (this.firstRender && this.out.write(cursor.hide), _get4(_get_prototype_of10(ConfirmPrompt2.prototype), "render", this).call(this), this.out.write(erase.line + cursor.to(0) + [
              style.symbol(this.done, this.aborted),
              color.bold(this.msg),
              style.delimiter(this.done),
              this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
            ].join(" ")));
          }
        }
      ]), ConfirmPrompt2;
    }(Prompt);
    module2.exports = ConfirmPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/index.js
var require_elements2 = __commonJS({
  "../../node_modules/prompts/lib/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text2(),
      SelectPrompt: require_select2(),
      TogglePrompt: require_toggle2(),
      DatePrompt: require_date2(),
      NumberPrompt: require_number2(),
      MultiselectPrompt: require_multiselect2(),
      AutocompletePrompt: require_autocomplete2(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
      ConfirmPrompt: require_confirm2()
    };
  }
});

// ../../node_modules/prompts/lib/prompts.js
var require_prompts2 = __commonJS({
  "../../node_modules/prompts/lib/prompts.js"(exports2) {
    "use strict";
    var $2 = exports2, el = require_elements2(), noop2 = function(v) {
      return v;
    };
    function toPrompt(type, args) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return new Promise(function(res, rej) {
        var p = new el[type](args), onAbort = opts.onAbort || noop2, onSubmit = opts.onSubmit || noop2;
        p.on("state", args.onState || noop2), p.on("submit", function(x) {
          return res(onSubmit(x));
        }), p.on("abort", function(x) {
          return rej(onAbort(x));
        });
      });
    }
    $2.text = function(args) {
      return toPrompt("TextPrompt", args);
    };
    $2.password = function(args) {
      return args.style = "password", $2.text(args);
    };
    $2.invisible = function(args) {
      return args.style = "invisible", $2.text(args);
    };
    $2.number = function(args) {
      return toPrompt("NumberPrompt", args);
    };
    $2.date = function(args) {
      return toPrompt("DatePrompt", args);
    };
    $2.confirm = function(args) {
      return toPrompt("ConfirmPrompt", args);
    };
    $2.list = function(args) {
      var sep2 = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: function(str) {
          return str.split(sep2).map(function(s) {
            return s.trim();
          });
        }
      });
    };
    $2.toggle = function(args) {
      return toPrompt("TogglePrompt", args);
    };
    $2.select = function(args) {
      return toPrompt("SelectPrompt", args);
    };
    $2.multiselect = function(args) {
      args.choices = [].concat(args.choices || []);
      var toSelected = function(items) {
        return items.filter(function(item) {
          return item.selected;
        }).map(function(item) {
          return item.value;
        });
      };
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $2.autocompleteMultiselect = function(args) {
      args.choices = [].concat(args.choices || []);
      var toSelected = function(items) {
        return items.filter(function(item) {
          return item.selected;
        }).map(function(item) {
          return item.value;
        });
      };
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = function(input, choices) {
      return Promise.resolve(choices.filter(function(item) {
        return item.title.slice(0, input.length).toLowerCase() === input.toLowerCase();
      }));
    };
    $2.autocomplete = function(args) {
      return args.suggest = args.suggest || byTitle, args.choices = [].concat(args.choices || []), toPrompt("AutocompletePrompt", args);
    };
  }
});

// ../../node_modules/prompts/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/prompts/lib/index.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var prompts5 = require_prompts2(), passOn = [
      "suggest",
      "format",
      "onState",
      "validate",
      "onRender"
    ], noop2 = function() {
    };
    function prompt() {
      return _prompt.apply(this, arguments);
    }
    function _prompt() {
      return _prompt = /**
      * Prompt for a series of questions
      * @param {Array|Object} questions Single question object or Array of question objects
      * @param {Function} [onSubmit] Callback function called on prompt submit
      * @param {Function} [onCancel] Callback function called on cancel/abort
      * @returns {Object} Object with values from user input
      */
      _async_to_generator31(function() {
        var questions, _ref, _ref_onSubmit, onSubmit, _ref_onCancel, onCancel, answers, _$override, answer, question, quit, name, type, getFormattedAnswer, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, ref, _tmp, _tmp1, _i, key, value, _tmp2, ref1, _tmp3, err, err1, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              questions = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : [], _ref = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, _ref_onSubmit = _ref.onSubmit, onSubmit = _ref_onSubmit === void 0 ? noop2 : _ref_onSubmit, _ref_onCancel = _ref.onCancel, onCancel = _ref_onCancel === void 0 ? noop2 : _ref_onCancel, answers = {}, _$override = prompt._override || {}, questions = [].concat(questions), getFormattedAnswer = function() {
                var _ref2 = _async_to_generator31(function(question2, answer2) {
                  var skipValidation, _tmp4, _arguments2 = arguments;
                  return _ts_generator31(this, function(_state2) {
                    switch (_state2.label) {
                      case 0:
                        return skipValidation = _arguments2.length > 2 && _arguments2[2] !== void 0 ? _arguments2[2] : !1, !skipValidation && question2.validate && question2.validate(answer2) !== !0 ? [
                          2
                        ] : question2.format ? [
                          4,
                          question2.format(answer2, answers)
                        ] : [
                          3,
                          2
                        ];
                      case 1:
                        return _tmp4 = _state2.sent(), [
                          3,
                          3
                        ];
                      case 2:
                        _tmp4 = answer2, _state2.label = 3;
                      case 3:
                        return [
                          2,
                          _tmp4
                        ];
                    }
                  });
                });
                return function(question2, answer2) {
                  return _ref2.apply(this, arguments);
                };
              }(), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
            case 1:
              _state.trys.push([
                1,
                21,
                22,
                23
              ]), _iterator = questions[Symbol.iterator](), _state.label = 2;
            case 2:
              if (_iteratorNormalCompletion2 = (_step = _iterator.next()).done)
                return [
                  3,
                  20
                ];
              question = _step.value, ref = question, name = ref.name, type = ref.type, _tmp = [];
              for (_tmp1 in question)
                _tmp.push(_tmp1);
              _i = 0, _state.label = 3;
            case 3:
              return _i < _tmp.length ? (key = _tmp[_i], passOn.includes(key) ? [
                3,
                7
              ] : (value = question[key], typeof value != "function" ? [
                3,
                5
              ] : [
                4,
                value(answer, _object_spread13({}, answers), question)
              ])) : [
                3,
                8
              ];
            case 4:
              return _tmp2 = _state.sent(), [
                3,
                6
              ];
            case 5:
              _tmp2 = value, _state.label = 6;
            case 6:
              question[key] = _tmp2, _state.label = 7;
            case 7:
              return _i++, [
                3,
                3
              ];
            case 8:
              if (typeof question.message != "string")
                throw new Error("prompt message is required");
              if (ref1 = question, name = ref1.name, type = ref1.type, !type)
                return [
                  3,
                  19
                ];
              if (prompts5[type] === void 0)
                throw new Error("prompt type (".concat(type, ") is not defined"));
              return _$override[question.name] === void 0 ? [
                3,
                10
              ] : [
                4,
                getFormattedAnswer(question, _$override[question.name])
              ];
            case 9:
              if (answer = _state.sent(), answer !== void 0)
                return answers[name] = answer, [
                  3,
                  19
                ];
              _state.label = 10;
            case 10:
              return _state.trys.push([
                10,
                16,
                ,
                18
              ]), prompt._injected ? (_tmp3 = getInjectedAnswer(prompt._injected), [
                3,
                13
              ]) : [
                3,
                11
              ];
            case 11:
              return [
                4,
                prompts5[type](question)
              ];
            case 12:
              _tmp3 = _state.sent(), _state.label = 13;
            case 13:
              return answer = _tmp3, [
                4,
                getFormattedAnswer(question, answer, !0)
              ];
            case 14:
              return answers[name] = answer = _state.sent(), [
                4,
                onSubmit(question, answer, answers)
              ];
            case 15:
              return quit = _state.sent(), [
                3,
                18
              ];
            case 16:
              return err = _state.sent(), [
                4,
                onCancel(question, answers)
              ];
            case 17:
              return quit = !_state.sent(), [
                3,
                18
              ];
            case 18:
              if (quit)
                return [
                  2,
                  answers
                ];
              _state.label = 19;
            case 19:
              return _iteratorNormalCompletion2 = !0, [
                3,
                2
              ];
            case 20:
              return [
                3,
                23
              ];
            case 21:
              return err1 = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err1, [
                3,
                23
              ];
            case 22:
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
              return [
                7
              ];
            case 23:
              return [
                2,
                answers
              ];
          }
        });
      }), _prompt.apply(this, arguments);
    }
    function getInjectedAnswer(injected) {
      var answer = injected.shift();
      if (_instanceof13(answer, Error))
        throw answer;
      return answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, {
      prompt,
      prompts: prompts5,
      inject,
      override
    });
  }
});

// ../../node_modules/prompts/index.js
var require_prompts3 = __commonJS({
  "../../node_modules/prompts/index.js"(exports2, module2) {
    function isNodeLT(tar) {
      tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
      for (var i = 0, src = process.versions.node.split(".").map(Number); i < tar.length; i++) {
        if (src[i] > tar[i])
          return !1;
        if (tar[i] > src[i])
          return !0;
      }
      return !1;
    }
    module2.exports = isNodeLT("8.6.0") ? require_dist() : require_lib2();
  }
});

// ../../node_modules/which/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/which/lib/index.js"(exports2, module2) {
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var isexe = require_isexe(), _require = require("path"), join3 = _require.join, delimiter = _require.delimiter, sep2 = _require.sep, posix3 = _require.posix, isWindows = process.platform === "win32", rSlash = new RegExp("[".concat(posix3.sep).concat(sep2 === posix3.sep ? "" : sep2, "]").replace(/(\\)/g, "\\$1")), rRel = new RegExp("^\\.".concat(rSlash.source)), getNotFoundError = function(cmd) {
      return Object.assign(new Error("not found: ".concat(cmd)), {
        code: "ENOENT"
      });
    }, getPathInfo = function(cmd, param) {
      var tmp = param.path, optPath = tmp === void 0 ? process.env.PATH : tmp, tmp1 = param.pathExt, optPathExt = tmp1 === void 0 ? process.env.PATHEXT : tmp1, tmp2 = param.delimiter, optDelimiter = tmp2 === void 0 ? delimiter : tmp2, pathEnv = cmd.match(rSlash) ? [
        ""
      ] : (
        // windows always checks the cwd first
        _to_consumable_array16(isWindows ? [
          process.cwd()
        ] : []).concat(_to_consumable_array16((optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)))
      );
      if (isWindows) {
        var pathExtExe = optPathExt || [
          ".EXE",
          ".CMD",
          ".BAT",
          ".COM"
        ].join(optDelimiter), pathExt = pathExtExe.split(optDelimiter);
        return cmd.includes(".") && pathExt[0] !== "" && pathExt.unshift(""), {
          pathEnv,
          pathExt,
          pathExtExe
        };
      }
      return {
        pathEnv,
        pathExt: [
          ""
        ]
      };
    }, getPathPart = function(raw, cmd) {
      var pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw, prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix + join3(pathPart, cmd);
    }, which2 = function() {
      var _ref = _async_to_generator31(function(cmd) {
        var opt, _getPathInfo, pathEnv, pathExt, pathExtExe, found, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, envPart, p, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator1, _step1, ext2, withExt, is, err, err, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              opt = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe, found = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
            case 1:
              _state.trys.push([
                1,
                12,
                13,
                14
              ]), _iterator = pathEnv[Symbol.iterator](), _state.label = 2;
            case 2:
              if (_iteratorNormalCompletion2 = (_step = _iterator.next()).done)
                return [
                  3,
                  11
                ];
              envPart = _step.value, p = getPathPart(envPart, cmd), _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0, _state.label = 3;
            case 3:
              _state.trys.push([
                3,
                8,
                9,
                10
              ]), _iterator1 = pathExt[Symbol.iterator](), _state.label = 4;
            case 4:
              return (_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done) ? [
                3,
                7
              ] : (ext2 = _step1.value, withExt = p + ext2, [
                4,
                isexe(withExt, {
                  pathExt: pathExtExe,
                  ignoreErrors: !0
                })
              ]);
            case 5:
              if (is = _state.sent(), is) {
                if (!opt.all)
                  return [
                    2,
                    withExt
                  ];
                found.push(withExt);
              }
              _state.label = 6;
            case 6:
              return _iteratorNormalCompletion12 = !0, [
                3,
                4
              ];
            case 7:
              return [
                3,
                10
              ];
            case 8:
              return err = _state.sent(), _didIteratorError12 = !0, _iteratorError12 = err, [
                3,
                10
              ];
            case 9:
              try {
                !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
              return [
                7
              ];
            case 10:
              return _iteratorNormalCompletion2 = !0, [
                3,
                2
              ];
            case 11:
              return [
                3,
                14
              ];
            case 12:
              return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                3,
                14
              ];
            case 13:
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
              return [
                7
              ];
            case 14:
              if (opt.all && found.length)
                return [
                  2,
                  found
                ];
              if (opt.nothrow)
                return [
                  2,
                  null
                ];
              throw getNotFoundError(cmd);
          }
        });
      });
      return function(cmd) {
        return _ref.apply(this, arguments);
      };
    }(), whichSync = function(cmd) {
      var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe, found = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = pathEnv[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var pathEnvPart = _step.value, p = getPathPart(pathEnvPart, cmd), _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = pathExt[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var ext2 = _step1.value, withExt = p + ext2, is = isexe.sync(withExt, {
                pathExt: pathExtExe,
                ignoreErrors: !0
              });
              if (is) {
                if (!opt.all)
                  return withExt;
                found.push(withExt);
              }
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// ../../node_modules/through/index.js
var require_through = __commonJS({
  "../../node_modules/through/index.js"(exports2, module2) {
    var Stream3 = require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      }, end = end || function() {
        this.queue(null);
      };
      var ended = !1, destroyed = !1, buffer = [], _ended = !1, stream2 = new Stream3();
      stream2.readable = stream2.writable = !0, stream2.paused = !1, stream2.autoDestroy = !(opts && opts.autoDestroy === !1), stream2.write = function(data) {
        return write.call(this, data), !stream2.paused;
      };
      function drain() {
        for (; buffer.length && !stream2.paused; ) {
          var data = buffer.shift();
          if (data === null)
            return stream2.emit("end");
          stream2.emit("data", data);
        }
      }
      stream2.queue = stream2.push = function(data) {
        return _ended || (data === null && (_ended = !0), buffer.push(data), drain()), stream2;
      }, stream2.on("end", function() {
        stream2.readable = !1, !stream2.writable && stream2.autoDestroy && process.nextTick(function() {
          stream2.destroy();
        });
      });
      function _end() {
        stream2.writable = !1, end.call(stream2), !stream2.readable && stream2.autoDestroy && stream2.destroy();
      }
      return stream2.end = function(data) {
        if (!ended)
          return ended = !0, arguments.length && stream2.write(data), _end(), stream2;
      }, stream2.destroy = function() {
        if (!destroyed)
          return destroyed = !0, ended = !0, buffer.length = 0, stream2.writable = stream2.readable = !1, stream2.emit("close"), stream2;
      }, stream2.pause = function() {
        if (!stream2.paused)
          return stream2.paused = !0, stream2;
      }, stream2.resume = function() {
        return stream2.paused && (stream2.paused = !1, stream2.emit("resume")), drain(), stream2.paused || stream2.emit("drain"), stream2;
      }, stream2;
    }
  }
});

// ../../node_modules/from/index.js
var require_from = __commonJS({
  "../../node_modules/from/index.js"(exports2, module2) {
    "use strict";
    var Stream3 = require("stream");
    module2.exports = function from(source) {
      if (Array.isArray(source)) {
        var source_index = 0, source_len = source.length;
        return from(function(i2) {
          return source_index < source_len ? this.emit("data", source[source_index++]) : this.emit("end"), !0;
        });
      }
      var s = new Stream3(), i = 0;
      s.ended = !1, s.started = !1, s.readable = !0, s.writable = !1, s.paused = !1, s.ended = !1, s.pause = function() {
        s.started = !0, s.paused = !0;
      };
      function next() {
        if (s.started = !0, !s.ended)
          for (; !s.ended && !s.paused && source.call(s, i++, function() {
            !s.ended && !s.paused && process.nextTick(next);
          }); )
            ;
      }
      return s.resume = function() {
        s.started = !0, s.paused = !1, next();
      }, s.on("end", function() {
        s.ended = !0, s.readable = !1, process.nextTick(s.destroy);
      }), s.destroy = function() {
        s.ended = !0, s.emit("close");
      }, process.nextTick(function() {
        s.started || s.resume();
      }), s;
    };
  }
});

// ../../node_modules/duplexer/index.js
var require_duplexer = __commonJS({
  "../../node_modules/duplexer/index.js"(exports2, module2) {
    var Stream3 = require("stream"), writeMethods = [
      "write",
      "end",
      "destroy"
    ], readMethods = [
      "resume",
      "pause"
    ], readEvents = [
      "data",
      "close"
    ], slice = Array.prototype.slice;
    module2.exports = duplex;
    function forEach(arr, fn) {
      if (arr.forEach)
        return arr.forEach(fn);
      for (var i = 0; i < arr.length; i++)
        fn(arr[i], i);
    }
    function duplex(writer, reader) {
      var stream2 = new Stream3(), ended = !1;
      return forEach(writeMethods, proxyWriter), forEach(readMethods, proxyReader), forEach(readEvents, proxyStream), reader.on("end", handleEnd), writer.on("drain", function() {
        stream2.emit("drain");
      }), writer.on("error", reemit), reader.on("error", reemit), stream2.writable = writer.writable, stream2.readable = reader.readable, stream2;
      function proxyWriter(methodName) {
        stream2[methodName] = method;
        function method() {
          return writer[methodName].apply(writer, arguments);
        }
      }
      function proxyReader(methodName) {
        stream2[methodName] = method;
        function method() {
          stream2.emit(methodName);
          var func = reader[methodName];
          if (func)
            return func.apply(reader, arguments);
          reader.emit(methodName);
        }
      }
      function proxyStream(methodName) {
        reader.on(methodName, reemit2);
        function reemit2() {
          var args = slice.call(arguments);
          args.unshift(methodName), stream2.emit.apply(stream2, args);
        }
      }
      function handleEnd() {
        if (!ended) {
          ended = !0;
          var args = slice.call(arguments);
          args.unshift("end"), stream2.emit.apply(stream2, args);
        }
      }
      function reemit(err) {
        stream2.emit("error", err);
      }
    }
  }
});

// ../../node_modules/map-stream/index.js
var require_map_stream = __commonJS({
  "../../node_modules/map-stream/index.js"(exports2, module2) {
    var Stream3 = require("stream").Stream;
    module2.exports = function(mapper, opts) {
      var stream2 = new Stream3(), self = this, inputs = 0, outputs = 0, ended = !1, paused = !1, destroyed = !1, lastWritten = 0, inNext = !1;
      this.opts = opts || {};
      var errorEventName = this.opts.failures ? "failure" : "error", writeQueue = {};
      stream2.writable = !0, stream2.readable = !0;
      function queueData(data, number) {
        var nextToWrite = lastWritten + 1;
        if (number === nextToWrite ? (data !== void 0 && stream2.emit.apply(stream2, [
          "data",
          data
        ]), lastWritten++, nextToWrite++) : writeQueue[number] = data, writeQueue.hasOwnProperty(nextToWrite)) {
          var dataToWrite = writeQueue[nextToWrite];
          return delete writeQueue[nextToWrite], queueData(dataToWrite, nextToWrite);
        }
        outputs++, inputs === outputs && (paused && (paused = !1, stream2.emit("drain")), ended && end());
      }
      function next(err, data, number) {
        destroyed || (inNext = !0, (!err || self.opts.failures) && queueData(data, number), err && stream2.emit.apply(stream2, [
          errorEventName,
          err
        ]), inNext = !1);
      }
      function wrappedMapper(input, number, callback) {
        return mapper.call(null, input, function(err, data) {
          callback(err, data, number);
        });
      }
      stream2.write = function(data) {
        if (ended)
          throw new Error("map stream is not writable");
        inNext = !1, inputs++;
        try {
          var written = wrappedMapper(data, inputs, next);
          return paused = written === !1, !paused;
        } catch (err) {
          if (inNext)
            throw err;
          return next(err), !paused;
        }
      };
      function end(data) {
        if (ended = !0, stream2.writable = !1, data !== void 0)
          return queueData(data, inputs);
        inputs == outputs && (stream2.readable = !1, stream2.emit("end"), stream2.destroy());
      }
      return stream2.end = function(data) {
        ended || end();
      }, stream2.destroy = function() {
        ended = destroyed = !0, stream2.writable = stream2.readable = paused = !1, process.nextTick(function() {
          stream2.emit("close");
        });
      }, stream2.pause = function() {
        paused = !0;
      }, stream2.resume = function() {
        paused = !1;
      }, stream2;
    };
  }
});

// ../../node_modules/pause-stream/index.js
var require_pause_stream = __commonJS({
  "../../node_modules/pause-stream/index.js"(exports2, module2) {
    module2.exports = require_through();
  }
});

// ../../node_modules/split/index.js
var require_split = __commonJS({
  "../../node_modules/split/index.js"(exports2, module2) {
    var through = require_through(), Decoder = require("string_decoder").StringDecoder;
    module2.exports = split;
    function split(matcher, mapper, options) {
      var decoder = new Decoder(), soFar = "", maxLength = options && options.maxLength;
      typeof matcher == "function" && (mapper = matcher, matcher = null), matcher || (matcher = /\r?\n/);
      function emit(stream2, piece) {
        if (mapper) {
          try {
            piece = mapper(piece);
          } catch (err) {
            return stream2.emit("error", err);
          }
          typeof piece < "u" && stream2.queue(piece);
        } else
          stream2.queue(piece);
      }
      function next(stream2, buffer) {
        var pieces = ((soFar ?? "") + buffer).split(matcher);
        soFar = pieces.pop(), maxLength && soFar.length > maxLength && stream2.emit("error", new Error("maximum buffer reached"));
        for (var i = 0; i < pieces.length; i++) {
          var piece = pieces[i];
          emit(stream2, piece);
        }
      }
      return through(function(b) {
        next(this, decoder.write(b));
      }, function() {
        decoder.end && next(this, decoder.end()), soFar != null && emit(this, soFar), this.queue(null);
      });
    }
  }
});

// ../../node_modules/stream-combiner/index.js
var require_stream_combiner = __commonJS({
  "../../node_modules/stream-combiner/index.js"(exports2, module2) {
    var duplexer = require_duplexer();
    module2.exports = function() {
      var streams = [].slice.call(arguments), first = streams[0], last = streams[streams.length - 1], thepipe = duplexer(first, last);
      if (streams.length == 1)
        return streams[0];
      if (!streams.length)
        throw new Error("connect called with empty args");
      function recurse(streams2) {
        streams2.length < 2 || (streams2[0].pipe(streams2[1]), recurse(streams2.slice(1)));
      }
      recurse(streams);
      function onerror() {
        var args = [].slice.call(arguments);
        args.unshift("error"), thepipe.emit.apply(thepipe, args);
      }
      for (var i = 1; i < streams.length - 1; i++)
        streams[i].on("error", onerror);
      return thepipe;
    };
  }
});

// ../../node_modules/event-stream/index.js
var require_event_stream = __commonJS({
  "../../node_modules/event-stream/index.js"(exports2) {
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var Stream3 = require("stream").Stream, es = exports2, through = require_through(), from = require_from(), duplex = require_duplexer(), map = require_map_stream(), pause = require_pause_stream(), split = require_split(), pipeline = require_stream_combiner(), immediately = global.setImmediate || process.nextTick;
    es.Stream = Stream3;
    es.through = through;
    es.from = from;
    es.duplex = duplex;
    es.map = map;
    es.pause = pause;
    es.split = split;
    es.pipeline = es.connect = es.pipe = pipeline;
    es.concat = //actually this should be called concat
    es.merge = function() {
      var toMerge = [].slice.call(arguments);
      toMerge.length === 1 && _instanceof13(toMerge[0], Array) && (toMerge = toMerge[0]);
      var stream2 = new Stream3();
      stream2.setMaxListeners(0);
      var endCount = 0;
      return stream2.writable = stream2.readable = !0, toMerge.length ? toMerge.forEach(function(e) {
        e.pipe(stream2, {
          end: !1
        });
        var ended = !1;
        e.on("end", function() {
          ended || (ended = !0, endCount++, endCount == toMerge.length && stream2.emit("end"));
        });
      }) : process.nextTick(function() {
        stream2.emit("end");
      }), stream2.write = function(data) {
        this.emit("data", data);
      }, stream2.destroy = function() {
        toMerge.forEach(function(e) {
          e.destroy && e.destroy();
        });
      }, stream2;
    };
    es.writeArray = function(done) {
      if (typeof done != "function")
        throw new Error("function writeArray (done): done must be function");
      var a = new Stream3(), array = [], isDone = !1;
      return a.write = function(l) {
        array.push(l);
      }, a.end = function() {
        isDone = !0, done(null, array);
      }, a.writable = !0, a.readable = !1, a.destroy = function() {
        a.writable = a.readable = !1, !isDone && done(new Error("destroyed before end"), array);
      }, a;
    };
    es.readArray = function(array) {
      var stream2 = new Stream3(), i = 0, paused = !1, ended = !1;
      if (stream2.readable = !0, stream2.writable = !1, !Array.isArray(array))
        throw new Error("event-stream.read expects an array");
      return stream2.resume = function() {
        if (!ended) {
          paused = !1;
          for (var l = array.length; i < l && !paused && !ended; )
            stream2.emit("data", array[i++]);
          i == l && !ended && (ended = !0, stream2.readable = !1, stream2.emit("end"));
        }
      }, process.nextTick(stream2.resume), stream2.pause = function() {
        paused = !0;
      }, stream2.destroy = function() {
        ended = !0, stream2.emit("close");
      }, stream2;
    };
    es.readable = function(func, continueOnError) {
      var stream2 = new Stream3(), i = 0, paused = !1, ended = !1, reading = !1;
      if (stream2.readable = !0, stream2.writable = !1, typeof func != "function")
        throw new Error("event-stream.readable expects async function");
      stream2.on("end", function() {
        ended = !0;
      });
      function get4(err, data) {
        err ? (stream2.emit("error", err), continueOnError || stream2.emit("end")) : arguments.length > 1 && stream2.emit("data", data), immediately(function() {
          if (!(ended || paused || reading))
            try {
              reading = !0, func.call(stream2, i++, function() {
                reading = !1, get4.apply(null, arguments);
              });
            } catch (err2) {
              stream2.emit("error", err2);
            }
        });
      }
      return stream2.resume = function() {
        paused = !1, get4();
      }, process.nextTick(get4), stream2.pause = function() {
        paused = !0;
      }, stream2.destroy = function() {
        stream2.emit("end"), stream2.emit("close"), ended = !0;
      }, stream2;
    };
    es.mapSync = function(sync2) {
      return es.through(function(data) {
        var mappedData;
        try {
          mappedData = sync2(data);
        } catch (err) {
          return this.emit("error", err);
        }
        mappedData !== void 0 && this.emit("data", mappedData);
      });
    };
    es.log = function(name) {
      return es.through(function(data) {
        var args = [].slice.call(arguments);
        name ? console.error(name, data) : console.error(data), this.emit("data", data);
      });
    };
    es.child = function(child) {
      return es.duplex(child.stdin, child.stdout);
    };
    es.parse = function(options) {
      var emitError = !!(options && options.error);
      return es.through(function(data) {
        var obj;
        try {
          data && (obj = JSON.parse(data.toString()));
        } catch (err) {
          return emitError ? this.emit("error", err) : console.error(err, "attempting to parse:", data);
        }
        obj !== void 0 && this.emit("data", obj);
      });
    };
    es.stringify = function() {
      var Buffer1 = require("buffer").Buffer;
      return es.mapSync(function(e) {
        return JSON.stringify(Buffer1.isBuffer(e) ? e.toString() : e) + `
`;
      });
    };
    es.replace = function(from2, to) {
      return es.pipeline(es.split(from2), es.join(to));
    };
    es.join = function(str) {
      if (typeof str == "function")
        return es.wait(str);
      var first = !0;
      return es.through(function(data) {
        return first || this.emit("data", str), first = !1, this.emit("data", data), !0;
      });
    };
    es.wait = function(callback) {
      var arr = [];
      return es.through(function(data) {
        arr.push(data);
      }, function() {
        var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr) : arr.join("");
        this.emit("data", body), this.emit("end"), callback && callback(null, body);
      });
    };
    es.pipeable = function() {
      throw new Error("[EVENT-STREAM] es.pipeable is deprecated");
    };
  }
});

// ../../node_modules/ps-tree/index.js
var require_ps_tree = __commonJS({
  "../../node_modules/ps-tree/index.js"(exports2, module2) {
    "use strict";
    var spawn2 = require("child_process").spawn, es = require_event_stream();
    module2.exports = function(pid, callback) {
      var headers = null;
      if (typeof callback != "function")
        throw new Error("childrenOfPid(pid, callback) expects callback");
      typeof pid == "number" && (pid = pid.toString());
      var processLister;
      process.platform === "win32" ? processLister = spawn2("wmic.exe", [
        "PROCESS",
        "GET",
        "Name,ProcessId,ParentProcessId,Status"
      ]) : processLister = spawn2("ps", [
        "-A",
        "-o",
        "ppid,pid,stat,comm"
      ]), es.connect(
        // spawn('ps', ['-A', '-o', 'ppid,pid,stat,comm']).stdout,
        processLister.stdout,
        es.split(),
        es.map(function(line, cb) {
          var columns = line.trim().split(/\s+/);
          if (!headers)
            return headers = columns, headers = headers.map(normalizeHeader), cb();
          for (var row = {}, h = headers.slice(); h.length; )
            row[h.shift()] = h.length ? columns.shift() : columns.join(" ");
          return cb(null, row);
        }),
        es.writeArray(function(err, ps) {
          var parents = {}, children = [];
          parents[pid] = !0, ps.forEach(function(proc3) {
            parents[proc3.PPID] && (parents[proc3.PID] = !0, children.push(proc3));
          }), callback(null, children);
        })
      ).on("error", callback);
    };
    function normalizeHeader(str) {
      if (process.platform !== "win32")
        return str;
      switch (str) {
        case "Name":
          return "COMMAND";
        case "ParentProcessId":
          return "PPID";
        case "ProcessId":
          return "PID";
        case "Status":
          return "STAT";
        default:
          throw new Error("Unknown process listing header: " + str);
      }
    }
  }
});

// ../../node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "../../node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream3 = require("stream"), PassThrough = Stream3.PassThrough, slice = Array.prototype.slice;
    module2.exports = merge22;
    function merge22() {
      var streamsQueue = [], args = slice.call(arguments), merging = !1, options = args[args.length - 1];
      options && !Array.isArray(options) && options.pipe == null ? args.pop() : options = {};
      var doEnd = options.end !== !1, doPipeError = options.pipeError === !0;
      options.objectMode == null && (options.objectMode = !0), options.highWaterMark == null && (options.highWaterMark = 64 * 1024);
      var mergedStream = PassThrough(options);
      function addStream() {
        for (var i = 0, len = arguments.length; i < len; i++)
          streamsQueue.push(pauseStreams(arguments[i], options));
        return mergeStream(), this;
      }
      function mergeStream() {
        if (merging)
          return;
        merging = !0;
        var streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        Array.isArray(streams) || (streams = [
          streams
        ]);
        var pipesCount = streams.length + 1;
        function next() {
          --pipesCount > 0 || (merging = !1, mergeStream());
        }
        function pipe(stream2) {
          function onend() {
            stream2.removeListener("merge2UnpipeEnd", onend), stream2.removeListener("end", onend), doPipeError && stream2.removeListener("error", onerror), next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream2._readableState.endEmitted)
            return next();
          stream2.on("merge2UnpipeEnd", onend), stream2.on("end", onend), doPipeError && stream2.on("error", onerror), stream2.pipe(mergedStream, {
            end: !1
          }), stream2.resume();
        }
        for (var i = 0; i < streams.length; i++)
          pipe(streams[i]);
        next();
      }
      function endStream() {
        merging = !1, mergedStream.emit("queueDrain"), doEnd && mergedStream.end();
      }
      return mergedStream.setMaxListeners(0), mergedStream.add = addStream, mergedStream.on("unpipe", function(stream2) {
        stream2.emit("merge2UnpipeEnd");
      }), args.length && addStream.apply(null, args), mergedStream;
    }
    function pauseStreams(streams, options) {
      if (Array.isArray(streams))
        for (var i = 0, len = streams.length; i < len; i++)
          streams[i] = pauseStreams(streams[i], options);
      else {
        if (!streams._readableState && streams.pipe && (streams = streams.pipe(PassThrough(options))), !streams._readableState || !streams.pause || !streams.pipe)
          throw new Error("Only readable stream can be merged.");
        streams.pause();
      }
      return streams;
    }
  }
});

// ../../node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "../../node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce(function(collection, item) {
        return [].concat(collection, item);
      }, []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      var result = [
        []
      ], groupIndex = 0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var item = _step.value;
          predicate(item) ? (groupIndex++, result[groupIndex] = []) : result[groupIndex].push(item);
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// ../../node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "../../node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// ../../node_modules/fast-glob/out/utils/fs.js
var require_fs2 = __commonJS({
  "../../node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = function DirentFromStats2(name, stats) {
      _class_call_check15(this, DirentFromStats2), this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "../../node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.convertPosixPathToPattern = exports2.convertWindowsPathToPattern = exports2.convertPathToPattern = exports2.escapePosixPath = exports2.escapeWindowsPath = exports2.escape = exports2.removeLeadingDotSegment = exports2.makeAbsolute = exports2.unixify = void 0;
    var os2 = require("os"), path6 = require("path"), IS_WINDOWS_PLATFORM = os2.platform() === "win32", LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2, POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g, WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, DOS_DEVICE_PATH_RE = /^\\\\([.?])/, WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd2, filepath) {
      return path6.resolve(cwd2, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        var secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\")
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
    exports2.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapePosixPath = escapePosixPath;
    exports2.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports2.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports2.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// ../../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "../../node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function(str) {
      if (typeof str != "string" || str === "")
        return !1;
      for (var match2; match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str); ) {
        if (match2[2])
          return !0;
        str = str.slice(match2.index + match2[0].length);
      }
      return !1;
    };
  }
});

// ../../node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "../../node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob(), chars = {
      "{": "}",
      "(": ")",
      "[": "]"
    }, strictCheck = function(str) {
      if (str[0] === "!")
        return !0;
      for (var index = 0, pipeIndex = -2, closeSquareIndex = -2, closeCurlyIndex = -2, closeParenIndex = -2, backSlashIndex = -2; index < str.length; ) {
        if (str[index] === "*" || str[index + 1] === "?" && /[\].+)]/.test(str[index]) || closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]" && (closeSquareIndex < index && (closeSquareIndex = str.indexOf("]", index)), closeSquareIndex > index && (backSlashIndex === -1 || backSlashIndex > closeSquareIndex || (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeSquareIndex))) || closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}" && (closeCurlyIndex = str.indexOf("}", index), closeCurlyIndex > index && (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeCurlyIndex)) || closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")" && (closeParenIndex = str.indexOf(")", index), closeParenIndex > index && (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeParenIndex)) || pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|" && (pipeIndex < index && (pipeIndex = str.indexOf("|", index)), pipeIndex !== -1 && str[pipeIndex + 1] !== ")" && (closeParenIndex = str.indexOf(")", pipeIndex), closeParenIndex > pipeIndex && (backSlashIndex = str.indexOf("\\", pipeIndex), backSlashIndex === -1 || backSlashIndex > closeParenIndex))))
          return !0;
        if (str[index] === "\\") {
          var open3 = str[index + 1];
          index += 2;
          var close = chars[open3];
          if (close) {
            var n = str.indexOf(close, index);
            n !== -1 && (index = n + 1);
          }
          if (str[index] === "!")
            return !0;
        } else
          index++;
      }
      return !1;
    }, relaxedCheck = function(str) {
      if (str[0] === "!")
        return !0;
      for (var index = 0; index < str.length; ) {
        if (/[*?{}()[\]]/.test(str[index]))
          return !0;
        if (str[index] === "\\") {
          var open3 = str[index + 1];
          index += 2;
          var close = chars[open3];
          if (close) {
            var n = str.indexOf(close, index);
            n !== -1 && (index = n + 1);
          }
          if (str[index] === "!")
            return !0;
        } else
          index++;
      }
      return !1;
    };
    module2.exports = function(str, options) {
      if (typeof str != "string" || str === "")
        return !1;
      if (isExtglob(str))
        return !0;
      var check = strictCheck;
      return options && options.strict === !1 && (check = relaxedCheck), check(str);
    };
  }
});

// ../../node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "../../node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob(), pathPosixDirname = require("path").posix.dirname, isWin32 = require("os").platform() === "win32", slash2 = "/", backslash = /\\/g, enclosure = /[\{\[].*[\}\]]$/, globby4 = /(^|[^\\])([\{\[]|\([^\)]+$)/, escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function(str, opts) {
      var options = Object.assign({
        flipBackslashes: !0
      }, opts);
      options.flipBackslashes && isWin32 && str.indexOf(slash2) < 0 && (str = str.replace(backslash, slash2)), enclosure.test(str) && (str += slash2), str += "a";
      do
        str = pathPosixDirname(str);
      while (isGlob(str) || globby4.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// ../../node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = function(num) {
      return typeof num == "number" ? Number.isInteger(num) : typeof num == "string" && num.trim() !== "" ? Number.isInteger(Number(num)) : !1;
    };
    exports2.find = function(node, type) {
      return node.nodes.find(function(node2) {
        return node2.type === type;
      });
    };
    exports2.exceedsLimit = function(min, max) {
      var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 ? arguments[3] : void 0;
      return limit === !1 || !exports2.isInteger(min) || !exports2.isInteger(max) ? !1 : (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = function(block) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, type = arguments.length > 2 ? arguments[2] : void 0, node = block.nodes[n];
      node && (type && node.type === type || node.type === "open" || node.type === "close") && node.escaped !== !0 && (node.value = "\\" + node.value, node.escaped = !0);
    };
    exports2.encloseBrace = function(node) {
      return node.type !== "brace" || node.commas >> 0 + node.ranges >> 0 ? !1 : (node.invalid = !0, !0);
    };
    exports2.isInvalidBrace = function(block) {
      return block.type !== "brace" ? !1 : block.invalid === !0 || block.dollar ? !0 : !(block.commas >> 0 + block.ranges >> 0) || block.open !== !0 || block.close !== !0 ? (block.invalid = !0, !0) : !1;
    };
    exports2.isOpenOrClose = function(node) {
      return node.type === "open" || node.type === "close" ? !0 : node.open === !0 || node.close === !0;
    };
    exports2.reduce = function(nodes) {
      return nodes.reduce(function(acc, node) {
        return node.type === "text" && acc.push(node.value), node.type === "range" && (node.type = "text"), acc;
      }, []);
    };
    exports2.flatten = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      var result = [], flat = function(arr) {
        for (var i = 0; i < arr.length; i++) {
          var ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      return flat(args), result;
    };
  }
});

// ../../node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = function(ast) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, stringify = function(node) {
        var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options.escapeInvalid === !0, output = "";
        if (node.value)
          return (invalidBlock || invalidNode) && utils.isOpenOrClose(node) ? "\\" + node.value : node.value;
        if (node.value)
          return node.value;
        if (node.nodes) {
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = node.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var child = _step.value;
              output += stringify(child);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// ../../node_modules/to-regex-range/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "../../node_modules/to-regex-range/node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      return typeof num == "number" ? num - num === 0 : typeof num == "string" && num.trim() !== "" ? Number.isFinite ? Number.isFinite(+num) : isFinite(+num) : !1;
    };
  }
});

// ../../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "../../node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var isNumber = require_is_number(), toRegexRange = function(min, max, options) {
      if (isNumber(min) === !1)
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      if (max === void 0 || min === max)
        return String(min);
      if (isNumber(max) === !1)
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      var opts = _object_spread13({
        relaxZeros: !0
      }, options);
      typeof opts.strictZeros == "boolean" && (opts.relaxZeros = opts.strictZeros === !1);
      var relax = String(opts.relaxZeros), shorthand = String(opts.shorthand), capture = String(opts.capture), wrap2 = String(opts.wrap), cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange.cache.hasOwnProperty(cacheKey))
        return toRegexRange.cache[cacheKey].result;
      var a = Math.min(min, max), b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        var result = min + "|" + max;
        return opts.capture ? "(".concat(result, ")") : opts.wrap === !1 ? result : "(?:".concat(result, ")");
      }
      var isPadded = hasPadding(min) || hasPadding(max), state = {
        min,
        max,
        a,
        b
      }, positives = [], negatives = [];
      if (isPadded && (state.isPadded = isPadded, state.maxLen = String(state.max).length), a < 0) {
        var newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts), a = state.a = 0;
      }
      return b >= 0 && (positives = splitToPatterns(a, b, state, opts)), state.negatives = negatives, state.positives = positives, state.result = collatePatterns(negatives, positives, opts), opts.capture === !0 ? state.result = "(".concat(state.result, ")") : opts.wrap !== !1 && positives.length + negatives.length > 1 && (state.result = "(?:".concat(state.result, ")")), toRegexRange.cache[cacheKey] = state, state.result;
    };
    function collatePatterns(neg, pos, options) {
      var onlyNegative = filterPatterns(neg, pos, "-", !1, options) || [], onlyPositive = filterPatterns(pos, neg, "", !1, options) || [], intersected = filterPatterns(neg, pos, "-?", !0, options) || [], subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      for (var nines = 1, zeros = 1, stop = countNines(min, nines), stops = /* @__PURE__ */ new Set([
        max
      ]); min <= stop && stop <= max; )
        stops.add(stop), nines += 1, stop = countNines(min, nines);
      for (stop = countZeros(max + 1, zeros) - 1; min < stop && stop <= max; )
        stops.add(stop), zeros += 1, stop = countZeros(max + 1, zeros) - 1;
      return stops = _to_consumable_array16(stops), stops.sort(compare), stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop)
        return {
          pattern: start,
          count: [],
          digits: 0
        };
      for (var zipped = zip(start, stop), digits = zipped.length, pattern = "", count = 0, i = 0; i < digits; i++) {
        var _zipped_i = _sliced_to_array15(zipped[i], 2), startDigit = _zipped_i[0], stopDigit = _zipped_i[1];
        startDigit === stopDigit ? pattern += startDigit : startDigit !== "0" || stopDigit !== "9" ? pattern += toCharacterClass(startDigit, stopDigit, options) : count++;
      }
      return count && (pattern += options.shorthand === !0 ? "\\d" : "[0-9]"), {
        pattern,
        count: [
          count
        ],
        digits
      };
    }
    function splitToPatterns(min, max, tok, options) {
      for (var ranges = splitToRanges(min, max), tokens = [], start = min, prev, i = 0; i < ranges.length; i++) {
        var _$max = ranges[i], obj = rangeToPattern(String(start), String(_$max), options), zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          prev.count.length > 1 && prev.count.pop(), prev.count.push(obj.count[0]), prev.string = prev.pattern + toQuantifier(prev.count), start = _$max + 1;
          continue;
        }
        tok.isPadded && (zeros = padZeros(_$max, tok, options)), obj.string = zeros + obj.pattern + toQuantifier(obj.count), tokens.push(obj), start = _$max + 1, prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      var result = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var ele = _step.value, string = ele.string;
          !intersection && !contains(comparison, "string", string) && result.push(prefix + string), intersection && contains(comparison, "string", string) && result.push(prefix + string);
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return result;
    }
    function zip(a, b) {
      for (var arr = [], i = 0; i < a.length; i++)
        arr.push([
          a[i],
          b[i]
        ]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some(function(ele) {
        return ele[key] === val;
      });
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      var _digits = _sliced_to_array15(digits, 2), tmp = _digits[0], start = tmp === void 0 ? 0 : tmp, tmp1 = _digits[1], stop = tmp1 === void 0 ? "" : tmp1;
      return stop || start > 1 ? "{".concat(start + (stop ? "," + stop : ""), "}") : "";
    }
    function toCharacterClass(a, b, options) {
      return "[".concat(a).concat(b - a === 1 ? "" : "-").concat(b, "]");
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded)
        return value;
      var diff = Math.abs(tok.maxLen - String(value).length), relax = options.relaxZeros !== !1;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default:
          return relax ? "0{0,".concat(diff, "}") : "0{".concat(diff, "}");
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = function() {
      return toRegexRange.cache = {};
    };
    module2.exports = toRegexRange;
  }
});

// ../../node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "../../node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var util = require("util"), toRegexRange = require_to_regex_range(), isObject = function(val) {
      return val !== null && typeof val == "object" && !Array.isArray(val);
    }, transform = function(toNumber) {
      return function(value) {
        return toNumber === !0 ? Number(value) : String(value);
      };
    }, isValidValue = function(value) {
      return typeof value == "number" || typeof value == "string" && value !== "";
    }, isNumber = function(num) {
      return Number.isInteger(+num);
    }, zeros = function(input) {
      var value = "".concat(input), index = -1;
      if (value[0] === "-" && (value = value.slice(1)), value === "0")
        return !1;
      for (; value[++index] === "0"; )
        ;
      return index > 0;
    }, stringify = function(start, end, options) {
      return typeof start == "string" || typeof end == "string" ? !0 : options.stringify === !0;
    }, pad = function(input, maxLength, toNumber) {
      if (maxLength > 0) {
        var dash = input[0] === "-" ? "-" : "";
        dash && (input = input.slice(1)), input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      return toNumber === !1 ? String(input) : input;
    }, toMaxLen = function(input, maxLength) {
      var negative = input[0] === "-" ? "-" : "";
      for (negative && (input = input.slice(1), maxLength--); input.length < maxLength; )
        input = "0" + input;
      return negative ? "-" + input : input;
    }, toSequence = function(parts, options) {
      parts.negatives.sort(function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }), parts.positives.sort(function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      });
      var prefix = options.capture ? "" : "?:", positives = "", negatives = "", result;
      return parts.positives.length && (positives = parts.positives.join("|")), parts.negatives.length && (negatives = "-(".concat(prefix).concat(parts.negatives.join("|"), ")")), positives && negatives ? result = "".concat(positives, "|").concat(negatives) : result = positives || negatives, options.wrap ? "(".concat(prefix).concat(result, ")") : result;
    }, toRange = function(a, b, isNumbers, options) {
      if (isNumbers)
        return toRegexRange(a, b, _object_spread13({
          wrap: !1
        }, options));
      var start = String.fromCharCode(a);
      if (a === b)
        return start;
      var stop = String.fromCharCode(b);
      return "[".concat(start, "-").concat(stop, "]");
    }, toRegex = function(start, end, options) {
      if (Array.isArray(start)) {
        var wrap2 = options.wrap === !0, prefix = options.capture ? "" : "?:";
        return wrap2 ? "(".concat(prefix).concat(start.join("|"), ")") : start.join("|");
      }
      return toRegexRange(start, end, options);
    }, rangeError = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      var _util;
      return new RangeError("Invalid range arguments: " + (_util = util).inspect.apply(_util, _to_consumable_array16(args)));
    }, invalidRange = function(start, end, options) {
      if (options.strictRanges === !0)
        throw rangeError([
          start,
          end
        ]);
      return [];
    }, invalidStep = function(step, options) {
      if (options.strictRanges === !0)
        throw new TypeError('Expected step "'.concat(step, '" to be a number'));
      return [];
    }, fillNumbers = function(start, end) {
      var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, a = Number(start), b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === !0)
          throw rangeError([
            start,
            end
          ]);
        return [];
      }
      a === 0 && (a = 0), b === 0 && (b = 0);
      var descending = a > b, startString = String(start), endString = String(end), stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      var padded = zeros(startString) || zeros(endString) || zeros(stepString), maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0, toNumber = padded === !1 && stringify(start, end, options) === !1, format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1)
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), !0, options);
      for (var parts = {
        negatives: [],
        positives: []
      }, push = function(num) {
        return parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      }, range = [], index = 0; descending ? a >= b : a <= b; )
        options.toRegex === !0 && step > 1 ? push(a) : range.push(pad(format(a, index), maxLen, toNumber)), a = descending ? a - step : a + step, index++;
      return options.toRegex === !0 ? step > 1 ? toSequence(parts, options) : toRegex(range, null, _object_spread13({
        wrap: !1
      }, options)) : range;
    }, fillLetters = function(start, end) {
      var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1)
        return invalidRange(start, end, options);
      var format = options.transform || function(val) {
        return String.fromCharCode(val);
      }, a = "".concat(start).charCodeAt(0), b = "".concat(end).charCodeAt(0), descending = a > b, min = Math.min(a, b), max = Math.max(a, b);
      if (options.toRegex && step === 1)
        return toRange(min, max, !1, options);
      for (var range = [], index = 0; descending ? a >= b : a <= b; )
        range.push(format(a, index)), a = descending ? a - step : a + step, index++;
      return options.toRegex === !0 ? toRegex(range, null, {
        wrap: !1,
        options
      }) : range;
    }, fill = function(start, end, step) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (end == null && isValidValue(start))
        return [
          start
        ];
      if (!isValidValue(start) || !isValidValue(end))
        return invalidRange(start, end, options);
      if (typeof step == "function")
        return fill(start, end, 1, {
          transform: step
        });
      if (isObject(step))
        return fill(start, end, 0, step);
      var opts = _object_spread13({}, options);
      return opts.capture === !0 && (opts.wrap = !0), step = step || opts.step || 1, isNumber(step) ? isNumber(start) && isNumber(end) ? fillNumbers(start, end, step, opts) : fillLetters(start, end, Math.max(Math.abs(step), 1), opts) : step != null && !isObject(step) ? invalidStep(step, opts) : fill(start, end, 1, step);
    };
    module2.exports = fill;
  }
});

// ../../node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "../../node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var fill = require_fill_range(), utils = require_utils3(), compile = function(ast) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, walk = function(node) {
        var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, invalidBlock = utils.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options.escapeInvalid === !0, invalid = invalidBlock === !0 || invalidNode === !0, prefix = options.escapeInvalid === !0 ? "\\" : "", output = "";
        if (node.isOpen === !0 || node.isClose === !0)
          return prefix + node.value;
        if (node.type === "open")
          return invalid ? prefix + node.value : "(";
        if (node.type === "close")
          return invalid ? prefix + node.value : ")";
        if (node.type === "comma")
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        if (node.value)
          return node.value;
        if (node.nodes && node.ranges > 0) {
          var args = utils.reduce(node.nodes), range = fill.apply(void 0, _to_consumable_array16(args).concat([
            _object_spread_props9(_object_spread13({}, options), {
              wrap: !1,
              toRegex: !0
            })
          ]));
          if (range.length !== 0)
            return args.length > 1 && range.length > 1 ? "(".concat(range, ")") : range;
        }
        if (node.nodes) {
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = node.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var child = _step.value;
              output += walk(child, node);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// ../../node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "../../node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var fill = require_fill_range(), stringify = require_stringify(), utils = require_utils3(), append = function() {
      var queue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", stash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", enclose = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, result = [];
      if (queue = [].concat(queue), stash = [].concat(stash), !stash.length)
        return queue;
      if (!queue.length)
        return enclose ? utils.flatten(stash).map(function(ele2) {
          return "{".concat(ele2, "}");
        }) : stash;
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var item = _step.value;
          if (Array.isArray(item)) {
            var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
            try {
              for (var _iterator1 = item[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                var value = _step1.value;
                result.push(append(value, stash, enclose));
              }
            } catch (err) {
              _didIteratorError12 = !0, _iteratorError12 = err;
            } finally {
              try {
                !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
            }
          } else {
            var _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
            try {
              for (var _iterator2 = stash[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
                var ele = _step2.value;
                enclose === !0 && typeof ele == "string" && (ele = "{".concat(ele, "}")), result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
              }
            } catch (err) {
              _didIteratorError22 = !0, _iteratorError22 = err;
            } finally {
              try {
                !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
              } finally {
                if (_didIteratorError22)
                  throw _iteratorError22;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return utils.flatten(result);
    }, expand2 = function(ast) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit, walk = function(node) {
        var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        node.queue = [];
        for (var p = parent, q = parent.queue; p.type !== "brace" && p.type !== "root" && p.parent; )
          p = p.parent, q = p.queue;
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== !0 && node.nodes.length === 2) {
          q.push(append(q.pop(), [
            "{}"
          ]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          var _utils, args = utils.reduce(node.nodes);
          if ((_utils = utils).exceedsLimit.apply(_utils, _to_consumable_array16(args).concat([
            options.step,
            rangeLimit
          ])))
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          var range = fill.apply(void 0, _to_consumable_array16(args).concat([
            options
          ]));
          range.length === 0 && (range = stringify(node, options)), q.push(append(q.pop(), range)), node.nodes = [];
          return;
        }
        for (var enclose = utils.encloseBrace(node), queue = node.queue, block = node; block.type !== "brace" && block.type !== "root" && block.parent; )
          block = block.parent, queue = block.queue;
        for (var i = 0; i < node.nodes.length; i++) {
          var child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            i === 1 && queue.push(""), queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          child.nodes && walk(child, node);
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand2;
  }
});

// ../../node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: `
`,
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// ../../node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var stringify = require_stringify(), _require = require_constants(), MAX_LENGTH = _require.MAX_LENGTH, CHAR_BACKSLASH = _require.CHAR_BACKSLASH, CHAR_BACKTICK = _require.CHAR_BACKTICK, CHAR_COMMA = _require.CHAR_COMMA, CHAR_DOT = _require.CHAR_DOT, CHAR_LEFT_PARENTHESES = _require.CHAR_LEFT_PARENTHESES, CHAR_RIGHT_PARENTHESES = _require.CHAR_RIGHT_PARENTHESES, CHAR_LEFT_CURLY_BRACE = _require.CHAR_LEFT_CURLY_BRACE, CHAR_RIGHT_CURLY_BRACE = _require.CHAR_RIGHT_CURLY_BRACE, CHAR_LEFT_SQUARE_BRACKET = _require.CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET = _require.CHAR_RIGHT_SQUARE_BRACKET, CHAR_DOUBLE_QUOTE = _require.CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE = _require.CHAR_SINGLE_QUOTE, CHAR_NO_BREAK_SPACE = _require.CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE = _require.CHAR_ZERO_WIDTH_NOBREAK_SPACE, parse6 = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (typeof input != "string")
        throw new TypeError("Expected a string");
      var opts = options || {}, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max)
        throw new SyntaxError("Input length (".concat(input.length, "), exceeds max characters (").concat(max, ")"));
      var ast = {
        type: "root",
        input,
        nodes: []
      }, stack = [
        ast
      ], block = ast, prev = ast, brackets = 0, length = input.length, index = 0, depth = 0, value, memo = {}, advance = function() {
        return input[index++];
      }, push = function(node) {
        if (node.type === "text" && prev.type === "dot" && (prev.type = "text"), prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        return block.nodes.push(node), node.parent = block, node.prev = prev, prev = node, node;
      };
      for (push({
        type: "bos"
      }); index < length; )
        if (block = stack[stack.length - 1], value = advance(), !(value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE)) {
          if (value === CHAR_BACKSLASH) {
            push({
              type: "text",
              value: (options.keepEscaping ? value : "") + advance()
            });
            continue;
          }
          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({
              type: "text",
              value: "\\" + value
            });
            continue;
          }
          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            for (var closed = !0, next = void 0; index < length && (next = advance()); ) {
              if (value += next, next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                continue;
              }
              if (next === CHAR_BACKSLASH) {
                value += advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET && (brackets--, brackets === 0))
                break;
            }
            push({
              type: "text",
              value
            });
            continue;
          }
          if (value === CHAR_LEFT_PARENTHESES) {
            block = push({
              type: "paren",
              nodes: []
            }), stack.push(block), push({
              type: "text",
              value
            });
            continue;
          }
          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== "paren") {
              push({
                type: "text",
                value
              });
              continue;
            }
            block = stack.pop(), push({
              type: "text",
              value
            }), block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            var open3 = value, next1 = void 0;
            for (options.keepQuotes !== !0 && (value = ""); index < length && (next1 = advance()); ) {
              if (next1 === CHAR_BACKSLASH) {
                value += next1 + advance();
                continue;
              }
              if (next1 === open3) {
                options.keepQuotes === !0 && (value += next1);
                break;
              }
              value += next1;
            }
            push({
              type: "text",
              value
            });
            continue;
          }
          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            var dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === !0, brace = {
              type: "brace",
              open: !0,
              close: !1,
              dollar,
              depth,
              commas: 0,
              ranges: 0,
              nodes: []
            };
            block = push(brace), stack.push(block), push({
              type: "open",
              value
            });
            continue;
          }
          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== "brace") {
              push({
                type: "text",
                value
              });
              continue;
            }
            var type = "close";
            block = stack.pop(), block.close = !0, push({
              type,
              value
            }), depth--, block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
              block.ranges = 0;
              var open1 = block.nodes.shift();
              block.nodes = [
                open1,
                {
                  type: "text",
                  value: stringify(block)
                }
              ];
            }
            push({
              type: "comma",
              value
            }), block.commas++;
            continue;
          }
          if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            var siblings = block.nodes;
            if (depth === 0 || siblings.length === 0) {
              push({
                type: "text",
                value
              });
              continue;
            }
            if (prev.type === "dot") {
              if (block.range = [], prev.value += value, prev.type = "range", block.nodes.length !== 3 && block.nodes.length !== 5) {
                block.invalid = !0, block.ranges = 0, prev.type = "text";
                continue;
              }
              block.ranges++, block.args = [];
              continue;
            }
            if (prev.type === "range") {
              siblings.pop();
              var before = siblings[siblings.length - 1];
              before.value += prev.value + value, prev = before, block.ranges--;
              continue;
            }
            push({
              type: "dot",
              value
            });
            continue;
          }
          push({
            type: "text",
            value
          });
        }
      do
        if (block = stack.pop(), block.type !== "root") {
          var _parent_nodes;
          block.nodes.forEach(function(node) {
            node.nodes || (node.type === "open" && (node.isOpen = !0), node.type === "close" && (node.isClose = !0), node.nodes || (node.type = "text"), node.invalid = !0);
          });
          var parent = stack[stack.length - 1], index1 = parent.nodes.indexOf(block);
          (_parent_nodes = parent.nodes).splice.apply(_parent_nodes, [
            index1,
            1
          ].concat(_to_consumable_array16(block.nodes)));
        }
      while (stack.length > 0);
      return push({
        type: "eos"
      }), ast;
    };
    module2.exports = parse6;
  }
});

// ../../node_modules/braces/index.js
var require_braces = __commonJS({
  "../../node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var stringify = require_stringify(), compile = require_compile(), expand2 = require_expand(), parse6 = require_parse2(), braces = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, output = [];
      if (Array.isArray(input)) {
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var pattern = _step.value, result = braces.create(pattern, options);
            if (Array.isArray(result)) {
              var _output;
              (_output = output).push.apply(_output, _to_consumable_array16(result));
            } else
              output.push(result);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      } else
        output = [].concat(braces.create(input, options));
      return options && options.expand === !0 && options.nodupes === !0 && (output = _to_consumable_array16(new Set(output))), output;
    };
    braces.parse = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return parse6(input, options);
    };
    braces.stringify = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return stringify(typeof input == "string" ? braces.parse(input, options) : input, options);
    };
    braces.compile = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return typeof input == "string" && (input = braces.parse(input, options)), compile(input, options);
    };
    braces.expand = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      typeof input == "string" && (input = braces.parse(input, options));
      var result = expand2(input, options);
      return options.noempty === !0 && (result = result.filter(Boolean)), options.nodupes === !0 && (result = _to_consumable_array16(new Set(result))), result;
    };
    braces.create = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return input === "" || input.length < 3 ? [
        input
      ] : options.expand !== !0 ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    var path6 = require("path"), WIN_SLASH = "\\\\/", WIN_NO_SLASH = "[^".concat(WIN_SLASH, "]"), DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = "(?:".concat(SLASH_LITERAL, "|$)"), START_ANCHOR = "(?:^|".concat(SLASH_LITERAL, ")"), DOTS_SLASH = "".concat(DOT_LITERAL, "{1,2}").concat(END_ANCHOR), NO_DOT = "(?!".concat(DOT_LITERAL, ")"), NO_DOTS = "(?!".concat(START_ANCHOR).concat(DOTS_SLASH, ")"), NO_DOT_SLASH = "(?!".concat(DOT_LITERAL, "{0,1}").concat(END_ANCHOR, ")"), NO_DOTS_SLASH = "(?!".concat(DOTS_SLASH, ")"), QMARK_NO_DOT = "[^.".concat(SLASH_LITERAL, "]"), STAR = "".concat(QMARK, "*?"), POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    }, WINDOWS_CHARS = _object_spread_props9(_object_spread13({}, POSIX_CHARS), {
      SLASH_LITERAL: "[".concat(WIN_SLASH, "]"),
      QMARK: WIN_NO_SLASH,
      STAR: "".concat(WIN_NO_SLASH, "*?"),
      DOTS_SLASH: "".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$)"),
      NO_DOT: "(?!".concat(DOT_LITERAL, ")"),
      NO_DOTS: "(?!(?:^|[".concat(WIN_SLASH, "])").concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
      NO_DOT_SLASH: "(?!".concat(DOT_LITERAL, "{0,1}(?:[").concat(WIN_SLASH, "]|$))"),
      NO_DOTS_SLASH: "(?!".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
      QMARK_NO_DOT: "[^.".concat(WIN_SLASH, "]"),
      START_ANCHOR: "(?:^|[".concat(WIN_SLASH, "])"),
      END_ANCHOR: "(?:[".concat(WIN_SLASH, "]|$)")
    }), POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path6.sep,
      /**
      * Create EXTGLOB_CHARS
      */
      extglobChars: function(chars) {
        return {
          "!": {
            type: "negate",
            open: "(?:(?!(?:",
            close: "))".concat(chars.STAR, ")")
          },
          "?": {
            type: "qmark",
            open: "(?:",
            close: ")?"
          },
          "+": {
            type: "plus",
            open: "(?:",
            close: ")+"
          },
          "*": {
            type: "star",
            open: "(?:",
            close: ")*"
          },
          "@": {
            type: "at",
            open: "(?:",
            close: ")"
          }
        };
      },
      /**
      * Create GLOB_CHARS
      */
      globChars: function(win322) {
        return win322 === !0 ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path6 = require("path"), win322 = process.platform === "win32", _require = require_constants2(), REGEX_BACKSLASH = _require.REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH = _require.REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS = _require.REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL = _require.REGEX_SPECIAL_CHARS_GLOBAL;
    exports2.isObject = function(val) {
      return val !== null && typeof val == "object" && !Array.isArray(val);
    };
    exports2.hasRegexChars = function(str) {
      return REGEX_SPECIAL_CHARS.test(str);
    };
    exports2.isRegexChar = function(str) {
      return str.length === 1 && exports2.hasRegexChars(str);
    };
    exports2.escapeRegex = function(str) {
      return str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    };
    exports2.toPosixSlashes = function(str) {
      return str.replace(REGEX_BACKSLASH, "/");
    };
    exports2.removeBackslashes = function(str) {
      return str.replace(REGEX_REMOVE_BACKSLASH, function(match2) {
        return match2 === "\\" ? "" : match2;
      });
    };
    exports2.supportsLookbehinds = function() {
      var segs = process.version.slice(1).split(".").map(Number);
      return segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10;
    };
    exports2.isWindows = function(options) {
      return options && typeof options.windows == "boolean" ? options.windows : win322 === !0 || path6.sep === "\\";
    };
    exports2.escapeLast = function(input, char, lastIdx) {
      var idx = input.lastIndexOf(char, lastIdx);
      return idx === -1 ? input : input[idx - 1] === "\\" ? exports2.escapeLast(input, char, idx - 1) : "".concat(input.slice(0, idx), "\\").concat(input.slice(idx));
    };
    exports2.removePrefix = function(input) {
      var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, output = input;
      return output.startsWith("./") && (output = output.slice(2), state.prefix = "./"), output;
    };
    exports2.wrapOutput = function(input) {
      var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, prepend = options.contains ? "" : "^", append = options.contains ? "" : "$", output = "".concat(prepend, "(?:").concat(input, ")").concat(append);
      return state.negated === !0 && (output = "(?:^(?!".concat(output, ").*$)")), output;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4(), _require = require_constants2(), CHAR_ASTERISK = _require.CHAR_ASTERISK, CHAR_AT = _require.CHAR_AT, CHAR_BACKWARD_SLASH = _require.CHAR_BACKWARD_SLASH, CHAR_COMMA = _require.CHAR_COMMA, CHAR_DOT = _require.CHAR_DOT, CHAR_EXCLAMATION_MARK = _require.CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH = _require.CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE = _require.CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES = _require.CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET = _require.CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS = _require.CHAR_PLUS, CHAR_QUESTION_MARK = _require.CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE = _require.CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES = _require.CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET = _require.CHAR_RIGHT_SQUARE_BRACKET, isPathSeparator = function(code) {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    }, depth = function(token) {
      token.isPrefix !== !0 && (token.depth = token.isGlobstar ? 1 / 0 : 1);
    }, scan = function(input, options) {
      for (var opts = options || {}, length = input.length - 1, scanToEnd = opts.parts === !0 || opts.scanToEnd === !0, slashes = [], tokens = [], parts = [], str = input, index = -1, start = 0, lastIndex = 0, isBrace = !1, isBracket = !1, isGlob = !1, isExtglob = !1, isGlobstar = !1, braceEscaped = !1, backslashes = !1, negated = !1, negatedExtglob = !1, finished = !1, braces = 0, prev, code, token = {
        value: "",
        depth: 0,
        isGlob: !1
      }, eos = function() {
        return index >= length;
      }, peek = function() {
        return str.charCodeAt(index + 1);
      }, advance = function() {
        return prev = code, str.charCodeAt(++index);
      }; index < length; ) {
        code = advance();
        var next = void 0;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = !0, code = advance(), code === CHAR_LEFT_CURLY_BRACE && (braceEscaped = !0);
          continue;
        }
        if (braceEscaped === !0 || code === CHAR_LEFT_CURLY_BRACE) {
          for (braces++; eos() !== !0 && (code = advance()); ) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = !0, advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== !0 && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              if (isBrace = token.isBrace = !0, isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (braceEscaped !== !0 && code === CHAR_COMMA) {
              if (isBrace = token.isBrace = !0, isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE && (braces--, braces === 0)) {
              braceEscaped = !1, isBrace = token.isBrace = !0, finished = !0;
              break;
            }
          }
          if (scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          if (slashes.push(index), tokens.push(token), token = {
            value: "",
            depth: 0,
            isGlob: !1
          }, finished === !0)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== !0) {
          var isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === !0 && peek() === CHAR_LEFT_PARENTHESES) {
            if (isGlob = token.isGlob = !0, isExtglob = token.isExtglob = !0, finished = !0, code === CHAR_EXCLAMATION_MARK && index === start && (negatedExtglob = !0), scanToEnd === !0) {
              for (; eos() !== !0 && (code = advance()); ) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = !0, code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = !0, finished = !0;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK && (isGlobstar = token.isGlobstar = !0), isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          if (isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          for (; eos() !== !0 && (next = advance()); ) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = !0, advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = !0, isGlob = token.isGlob = !0, finished = !0;
              break;
            }
          }
          if (scanToEnd === !0)
            continue;
          break;
        }
        if (opts.nonegate !== !0 && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = !0, start++;
          continue;
        }
        if (opts.noparen !== !0 && code === CHAR_LEFT_PARENTHESES) {
          if (isGlob = token.isGlob = !0, scanToEnd === !0) {
            for (; eos() !== !0 && (code = advance()); ) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = !0, code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = !0;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === !0) {
          if (finished = !0, scanToEnd === !0)
            continue;
          break;
        }
      }
      opts.noext === !0 && (isExtglob = !1, isGlob = !1);
      var base = str, prefix = "", glob2 = "";
      start > 0 && (prefix = str.slice(0, start), str = str.slice(start), lastIndex -= start), base && isGlob === !0 && lastIndex > 0 ? (base = str.slice(0, lastIndex), glob2 = str.slice(lastIndex)) : isGlob === !0 ? (base = "", glob2 = str) : base = str, base && base !== "" && base !== "/" && base !== str && isPathSeparator(base.charCodeAt(base.length - 1)) && (base = base.slice(0, -1)), opts.unescape === !0 && (glob2 && (glob2 = utils.removeBackslashes(glob2)), base && backslashes === !0 && (base = utils.removeBackslashes(base)));
      var state = {
        prefix,
        input,
        start,
        base,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === !0 && (state.maxDepth = 0, isPathSeparator(code) || tokens.push(token), state.tokens = tokens), opts.parts === !0 || opts.tokens === !0) {
        for (var prevIndex, idx = 0; idx < slashes.length; idx++) {
          var n = prevIndex ? prevIndex + 1 : start, i = slashes[idx], value = input.slice(n, i);
          opts.tokens && (idx === 0 && start !== 0 ? (tokens[idx].isPrefix = !0, tokens[idx].value = prefix) : tokens[idx].value = value, depth(tokens[idx]), state.maxDepth += tokens[idx].depth), (idx !== 0 || value !== "") && parts.push(value), prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          var value1 = input.slice(prevIndex + 1);
          parts.push(value1), opts.tokens && (tokens[tokens.length - 1].value = value1, depth(tokens[tokens.length - 1]), state.maxDepth += tokens[tokens.length - 1].depth);
        }
        state.slashes = slashes, state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var constants = require_constants2(), utils = require_utils4(), MAX_LENGTH = constants.MAX_LENGTH, POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS = constants.REPLACEMENTS, expandRange = function(args, options) {
      if (typeof options.expandRange == "function") {
        var _options2;
        return (_options2 = options).expandRange.apply(_options2, _to_consumable_array16(args).concat([
          options
        ]));
      }
      args.sort();
      var value = "[".concat(args.join("-"), "]");
      try {
        new RegExp(value);
      } catch {
        return args.map(function(v) {
          return utils.escapeRegex(v);
        }).join("..");
      }
      return value;
    }, syntaxError = function(type, char) {
      return "Missing ".concat(type, ': "').concat(char, '" - use "\\\\').concat(char, '" to match literal characters');
    }, parse6 = function(input, options) {
      if (typeof input != "string")
        throw new TypeError("Expected a string");
      input = REPLACEMENTS[input] || input;
      var opts = _object_spread13({}, options), max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input.length;
      if (len > max)
        throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
      var bos = {
        type: "bos",
        value: "",
        output: opts.prepend || ""
      }, tokens = [
        bos
      ], capture = opts.capture ? "" : "?:", win322 = utils.isWindows(options), PLATFORM_CHARS = constants.globChars(win322), EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS), DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL, PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL, SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL, ONE_CHAR = PLATFORM_CHARS.ONE_CHAR, DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH, NO_DOT = PLATFORM_CHARS.NO_DOT, NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH, NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH, QMARK = PLATFORM_CHARS.QMARK, QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT, STAR = PLATFORM_CHARS.STAR, START_ANCHOR = PLATFORM_CHARS.START_ANCHOR, globstar = function(opts2) {
        return "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts2.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
      }, nodot = opts.dot ? "" : NO_DOT, qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT, star3 = opts.bash === !0 ? globstar(opts) : STAR;
      opts.capture && (star3 = "(".concat(star3, ")")), typeof opts.noext == "boolean" && (opts.noextglob = opts.noext);
      var state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === !0,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: !1,
        negated: !1,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: !1,
        tokens
      };
      input = utils.removePrefix(input, state), len = input.length;
      var extglobs = [], braces = [], stack = [], prev = bos, value, eos = function() {
        return state.index === len - 1;
      }, peek = state.peek = function() {
        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return input[state.index + n];
      }, advance = state.advance = function() {
        return input[++state.index] || "";
      }, remaining = function() {
        return input.slice(state.index + 1);
      }, consume = function() {
        var value2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", num = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        state.consumed += value2, state.index += num;
      }, append = function(token2) {
        state.output += token2.output != null ? token2.output : token2.value, consume(token2.value);
      }, negate = function() {
        for (var count = 1; peek() === "!" && (peek(2) !== "(" || peek(3) === "?"); )
          advance(), state.start++, count++;
        return count % 2 === 0 ? !1 : (state.negated = !0, state.start++, !0);
      }, increment = function(type) {
        state[type]++, stack.push(type);
      }, decrement = function(type) {
        state[type]--, stack.pop();
      }, push = function(tok) {
        if (prev.type === "globstar") {
          var isBrace2 = state.braces > 0 && (tok.type === "comma" || tok.type === "brace"), isExtglob2 = tok.extglob === !0 || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          tok.type !== "slash" && tok.type !== "paren" && !isBrace2 && !isExtglob2 && (state.output = state.output.slice(0, -prev.output.length), prev.type = "star", prev.value = "*", prev.output = star3, state.output += prev.output);
        }
        if (extglobs.length && tok.type !== "paren" && (extglobs[extglobs.length - 1].inner += tok.value), (tok.value || tok.output) && append(tok), prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value, prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev, tokens.push(tok), prev = tok;
      }, extglobOpen = function(type, value2) {
        var token2 = _object_spread_props9(_object_spread13({}, EXTGLOB_CHARS[value2]), {
          conditions: 1,
          inner: ""
        });
        token2.prev = prev, token2.parens = state.parens, token2.output = state.output;
        var output4 = (opts.capture ? "(" : "") + token2.open;
        increment("parens"), push({
          type,
          value: value2,
          output: state.output ? "" : ONE_CHAR
        }), push({
          type: "paren",
          extglob: !0,
          value: advance(),
          output: output4
        }), extglobs.push(token2);
      }, extglobClose = function(token2) {
        var output4 = token2.close + (opts.capture ? ")" : ""), rest2;
        if (token2.type === "negate") {
          var extglobStar = star3;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/") && (extglobStar = globstar(opts)), (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) && (output4 = token2.close = ")$))".concat(extglobStar)), token2.inner.includes("*") && (rest2 = remaining()) && /^\.[^\\/.]+$/.test(rest2)) {
            var expression = parse6(rest2, _object_spread_props9(_object_spread13({}, options), {
              fastpaths: !1
            })).output;
            output4 = token2.close = ")".concat(expression, ")").concat(extglobStar, ")");
          }
          token2.prev.type === "bos" && (state.negatedExtglob = !0);
        }
        push({
          type: "paren",
          extglob: !0,
          value,
          output: output4
        }), decrement("parens");
      };
      if (opts.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        var backslashes = !1, output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function(m, esc, chars, first, rest2, index) {
          return first === "\\" ? (backslashes = !0, m) : first === "?" ? esc ? esc + first + (rest2 ? QMARK.repeat(rest2.length) : "") : index === 0 ? qmarkNoDot + (rest2 ? QMARK.repeat(rest2.length) : "") : QMARK.repeat(chars.length) : first === "." ? DOT_LITERAL.repeat(chars.length) : first === "*" ? esc ? esc + first + (rest2 ? star3 : "") : star3 : esc ? m : "\\".concat(m);
        });
        return backslashes === !0 && (opts.unescape === !0 ? output = output.replace(/\\/g, "") : output = output.replace(/\\+/g, function(m) {
          return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
        })), output === input && opts.contains === !0 ? (state.output = input, state) : (state.output = utils.wrapOutput(output, state, options), state);
      }
      for (; !eos(); )
        if (value = advance(), value !== "\0") {
          if (value === "\\") {
            var next = peek();
            if (next === "/" && opts.bash !== !0 || next === "." || next === ";")
              continue;
            if (!next) {
              value += "\\", push({
                type: "text",
                value
              });
              continue;
            }
            var match2 = /^\\+/.exec(remaining()), slashes = 0;
            if (match2 && match2[0].length > 2 && (slashes = match2[0].length, state.index += slashes, slashes % 2 !== 0 && (value += "\\")), opts.unescape === !0 ? value = advance() : value += advance(), state.brackets === 0) {
              push({
                type: "text",
                value
              });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== !1 && value === ":") {
              var inner = prev.value.slice(1);
              if (inner.includes("[") && (prev.posix = !0, inner.includes(":"))) {
                var idx = prev.value.lastIndexOf("["), pre = prev.value.slice(0, idx), rest = prev.value.slice(idx + 2), posix3 = POSIX_REGEX_SOURCE[rest];
                if (posix3) {
                  prev.value = pre + posix3, state.backtrack = !0, advance(), !bos.output && tokens.indexOf(prev) === 1 && (bos.output = ONE_CHAR);
                  continue;
                }
              }
            }
            (value === "[" && peek() !== ":" || value === "-" && peek() === "]") && (value = "\\".concat(value)), value === "]" && (prev.value === "[" || prev.value === "[^") && (value = "\\".concat(value)), opts.posix === !0 && value === "!" && prev.value === "[" && (value = "^"), prev.value += value, append({
              value
            });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value), prev.value += value, append({
              value
            });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1, opts.keepQuotes === !0 && push({
              type: "text",
              value
            });
            continue;
          }
          if (value === "(") {
            increment("parens"), push({
              type: "paren",
              value
            });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === !0)
              throw new SyntaxError(syntaxError("opening", "("));
            var extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({
              type: "paren",
              value,
              output: state.parens ? ")" : "\\)"
            }), decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === !0 || !remaining().includes("]")) {
              if (opts.nobracket !== !0 && opts.strictBrackets === !0)
                throw new SyntaxError(syntaxError("closing", "]"));
              value = "\\".concat(value);
            } else
              increment("brackets");
            push({
              type: "bracket",
              value
            });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === !0 || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({
                type: "text",
                value,
                output: "\\".concat(value)
              });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === !0)
                throw new SyntaxError(syntaxError("opening", "["));
              push({
                type: "text",
                value,
                output: "\\".concat(value)
              });
              continue;
            }
            decrement("brackets");
            var prevValue = prev.value.slice(1);
            if (prev.posix !== !0 && prevValue[0] === "^" && !prevValue.includes("/") && (value = "/".concat(value)), prev.value += value, append({
              value
            }), opts.literalBrackets === !1 || utils.hasRegexChars(prevValue))
              continue;
            var escaped = utils.escapeRegex(prev.value);
            if (state.output = state.output.slice(0, -prev.value.length), opts.literalBrackets === !0) {
              state.output += escaped, prev.value = escaped;
              continue;
            }
            prev.value = "(".concat(capture).concat(escaped, "|").concat(prev.value, ")"), state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== !0) {
            increment("braces");
            var open3 = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open3), push(open3);
            continue;
          }
          if (value === "}") {
            var brace = braces[braces.length - 1];
            if (opts.nobrace === !0 || !brace) {
              push({
                type: "text",
                value,
                output: value
              });
              continue;
            }
            var output1 = ")";
            if (brace.dots === !0) {
              for (var arr = tokens.slice(), range = [], i = arr.length - 1; i >= 0 && (tokens.pop(), arr[i].type !== "brace"); i--)
                arr[i].type !== "dots" && range.unshift(arr[i].value);
              output1 = expandRange(range, opts), state.backtrack = !0;
            }
            if (brace.comma !== !0 && brace.dots !== !0) {
              var out = state.output.slice(0, brace.outputIndex), toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{", value = output1 = "\\}", state.output = out;
              var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator = toks[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var t = _step.value;
                  state.output += t.output || t.value;
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
            }
            push({
              type: "brace",
              value,
              output: output1
            }), decrement("braces"), braces.pop();
            continue;
          }
          if (value === "|") {
            extglobs.length > 0 && extglobs[extglobs.length - 1].conditions++, push({
              type: "text",
              value
            });
            continue;
          }
          if (value === ",") {
            var output2 = value, brace1 = braces[braces.length - 1];
            brace1 && stack[stack.length - 1] === "braces" && (brace1.comma = !0, output2 = "|"), push({
              type: "comma",
              value,
              output: output2
            });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1, state.consumed = "", state.output = "", tokens.pop(), prev = bos;
              continue;
            }
            push({
              type: "slash",
              value,
              output: SLASH_LITERAL
            });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              prev.value === "." && (prev.output = DOT_LITERAL);
              var brace2 = braces[braces.length - 1];
              prev.type = "dots", prev.output += value, prev.value += value, brace2.dots = !0;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({
                type: "text",
                value,
                output: DOT_LITERAL
              });
              continue;
            }
            push({
              type: "dot",
              value,
              output: DOT_LITERAL
            });
            continue;
          }
          if (value === "?") {
            var isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== !0 && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              var next1 = peek(), output3 = value;
              if (next1 === "<" && !utils.supportsLookbehinds())
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              (prev.value === "(" && !/[!=<:]/.test(next1) || next1 === "<" && !/<([!=]|\w+>)/.test(remaining())) && (output3 = "\\".concat(value)), push({
                type: "text",
                value,
                output: output3
              });
              continue;
            }
            if (opts.dot !== !0 && (prev.type === "slash" || prev.type === "bos")) {
              push({
                type: "qmark",
                value,
                output: QMARK_NO_DOT
              });
              continue;
            }
            push({
              type: "qmark",
              value,
              output: QMARK
            });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== !0 && peek() === "(" && (peek(2) !== "?" || !/[!=<:]/.test(peek(3)))) {
              extglobOpen("negate", value);
              continue;
            }
            if (opts.nonegate !== !0 && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== !0 && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === !1) {
              push({
                type: "plus",
                value,
                output: PLUS_LITERAL
              });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({
                type: "plus",
                value
              });
              continue;
            }
            push({
              type: "plus",
              value: PLUS_LITERAL
            });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== !0 && peek() === "(" && peek(2) !== "?") {
              push({
                type: "at",
                extglob: !0,
                value,
                output: ""
              });
              continue;
            }
            push({
              type: "text",
              value
            });
            continue;
          }
          if (value !== "*") {
            (value === "$" || value === "^") && (value = "\\".concat(value));
            var match1 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            match1 && (value += match1[0], state.index += match1[0].length), push({
              type: "text",
              value
            });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === !0)) {
            prev.type = "star", prev.star = !0, prev.value += value, prev.output = star3, state.backtrack = !0, state.globstar = !0, consume(value);
            continue;
          }
          var rest1 = remaining();
          if (opts.noextglob !== !0 && /^\([^?]/.test(rest1)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === !0) {
              consume(value);
              continue;
            }
            var prior = prev.prev, before = prior.prev, isStart = prior.type === "slash" || prior.type === "bos", afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === !0 && (!isStart || rest1[0] && rest1[0] !== "/")) {
              push({
                type: "star",
                value,
                output: ""
              });
              continue;
            }
            var isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace"), isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({
                type: "star",
                value,
                output: ""
              });
              continue;
            }
            for (; rest1.slice(0, 3) === "/**"; ) {
              var after = input[state.index + 4];
              if (after && after !== "/")
                break;
              rest1 = rest1.slice(3), consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar", prev.value += value, prev.output = globstar(opts), state.output = prev.output, state.globstar = !0, consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = "(?:".concat(prior.output), prev.type = "globstar", prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)"), prev.value += value, state.globstar = !0, state.output += prior.output + prev.output, consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest1[0] === "/") {
              var end = rest1[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = "(?:".concat(prior.output), prev.type = "globstar", prev.output = "".concat(globstar(opts)).concat(SLASH_LITERAL, "|").concat(SLASH_LITERAL).concat(end, ")"), prev.value += value, state.output += prior.output + prev.output, state.globstar = !0, consume(value + advance()), push({
                type: "slash",
                value: "/",
                output: ""
              });
              continue;
            }
            if (prior.type === "bos" && rest1[0] === "/") {
              prev.type = "globstar", prev.value += value, prev.output = "(?:^|".concat(SLASH_LITERAL, "|").concat(globstar(opts)).concat(SLASH_LITERAL, ")"), state.output = prev.output, state.globstar = !0, consume(value + advance()), push({
                type: "slash",
                value: "/",
                output: ""
              });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length), prev.type = "globstar", prev.output = globstar(opts), prev.value += value, state.output += prev.output, state.globstar = !0, consume(value);
            continue;
          }
          var token = {
            type: "star",
            value,
            output: star3
          };
          if (opts.bash === !0) {
            token.output = ".*?", (prev.type === "bos" || prev.type === "slash") && (token.output = nodot + token.output), push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === !0) {
            token.output = value, push(token);
            continue;
          }
          (state.index === state.start || prev.type === "slash" || prev.type === "dot") && (prev.type === "dot" ? (state.output += NO_DOT_SLASH, prev.output += NO_DOT_SLASH) : opts.dot === !0 ? (state.output += NO_DOTS_SLASH, prev.output += NO_DOTS_SLASH) : (state.output += nodot, prev.output += nodot), peek() !== "*" && (state.output += ONE_CHAR, prev.output += ONE_CHAR)), push(token);
        }
      for (; state.brackets > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "["), decrement("brackets");
      }
      for (; state.parens > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "("), decrement("parens");
      }
      for (; state.braces > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{"), decrement("braces");
      }
      if (opts.strictSlashes !== !0 && (prev.type === "star" || prev.type === "bracket") && push({
        type: "maybe_slash",
        value: "",
        output: "".concat(SLASH_LITERAL, "?")
      }), state.backtrack === !0) {
        state.output = "";
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = state.tokens[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var token1 = _step1.value;
            state.output += token1.output != null ? token1.output : token1.value, token1.suffix && (state.output += token1.suffix);
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
      }
      return state;
    };
    parse6.fastpaths = function(input, options) {
      var opts = _object_spread13({}, options), max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input.length;
      if (len > max)
        throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
      input = REPLACEMENTS[input] || input;
      var win322 = utils.isWindows(options), _constants_globChars = constants.globChars(win322), DOT_LITERAL = _constants_globChars.DOT_LITERAL, SLASH_LITERAL = _constants_globChars.SLASH_LITERAL, ONE_CHAR = _constants_globChars.ONE_CHAR, DOTS_SLASH = _constants_globChars.DOTS_SLASH, NO_DOT = _constants_globChars.NO_DOT, NO_DOTS = _constants_globChars.NO_DOTS, NO_DOTS_SLASH = _constants_globChars.NO_DOTS_SLASH, STAR = _constants_globChars.STAR, START_ANCHOR = _constants_globChars.START_ANCHOR, nodot = opts.dot ? NO_DOTS : NO_DOT, slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT, capture = opts.capture ? "" : "?:", state = {
        negated: !1,
        prefix: ""
      }, star3 = opts.bash === !0 ? ".*?" : STAR;
      opts.capture && (star3 = "(".concat(star3, ")"));
      var globstar = function(opts2) {
        return opts2.noglobstar === !0 ? star3 : "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts2.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
      }, create = function(str) {
        switch (str) {
          case "*":
            return "".concat(nodot).concat(ONE_CHAR).concat(star3);
          case ".*":
            return "".concat(DOT_LITERAL).concat(ONE_CHAR).concat(star3);
          case "*.*":
            return "".concat(nodot).concat(star3).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star3);
          case "*/*":
            return "".concat(nodot).concat(star3).concat(SLASH_LITERAL).concat(ONE_CHAR).concat(slashDot).concat(star3);
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(ONE_CHAR).concat(star3);
          case "**/*.*":
            return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(star3).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star3);
          case "**/.*":
            return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(DOT_LITERAL).concat(ONE_CHAR).concat(star3);
          default: {
            var match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2)
              return;
            var source2 = create(match2[1]);
            return source2 ? source2 + DOT_LITERAL + match2[2] : void 0;
          }
        }
      }, output = utils.removePrefix(input, state), source = create(output);
      return source && opts.strictSlashes !== !0 && (source += "".concat(SLASH_LITERAL, "?")), source;
    };
    module2.exports = parse6;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    var path6 = require("path"), scan = require_scan(), parse6 = require_parse3(), utils = require_utils4(), constants = require_constants2(), isObject = function(val) {
      return val && typeof val == "object" && !Array.isArray(val);
    }, picomatch = function(glob2, options) {
      var returnState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      if (Array.isArray(glob2)) {
        var fns = glob2.map(function(input) {
          return picomatch(input, options, returnState);
        }), arrayMatcher = function(str) {
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = fns[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var isMatch = _step.value, state2 = isMatch(str);
              if (state2)
                return state2;
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          return !1;
        };
        return arrayMatcher;
      }
      var isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 != "string" && !isState)
        throw new TypeError("Expected pattern to be a non-empty string");
      var opts = options || {}, posix3 = utils.isWindows(options), regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, !1, !0), state = regex.state;
      delete regex.state;
      var isIgnored = function() {
        return !1;
      };
      if (opts.ignore) {
        var ignoreOpts = _object_spread_props9(_object_spread13({}, options), {
          ignore: null,
          onMatch: null,
          onResult: null
        });
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      var matcher = function(input) {
        var returnObject = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, _picomatch_test = picomatch.test(input, regex, options, {
          glob: glob2,
          posix: posix3
        }), isMatch = _picomatch_test.isMatch, match2 = _picomatch_test.match, output = _picomatch_test.output, result = {
          glob: glob2,
          state,
          regex,
          posix: posix3,
          input,
          output,
          match: match2,
          isMatch
        };
        return typeof opts.onResult == "function" && opts.onResult(result), isMatch === !1 ? (result.isMatch = !1, returnObject ? result : !1) : isIgnored(input) ? (typeof opts.onIgnore == "function" && opts.onIgnore(result), result.isMatch = !1, returnObject ? result : !1) : (typeof opts.onMatch == "function" && opts.onMatch(result), returnObject ? result : !0);
      };
      return returnState && (matcher.state = state), matcher;
    };
    picomatch.test = function(input, regex, options) {
      var _ref = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, glob2 = _ref.glob, posix3 = _ref.posix;
      if (typeof input != "string")
        throw new TypeError("Expected input to be a string");
      if (input === "")
        return {
          isMatch: !1,
          output: ""
        };
      var opts = options || {}, format = opts.format || (posix3 ? utils.toPosixSlashes : null), match2 = input === glob2, output = match2 && format ? format(input) : input;
      return match2 === !1 && (output = format ? format(input) : input, match2 = output === glob2), (match2 === !1 || opts.capture === !0) && (opts.matchBase === !0 || opts.basename === !0 ? match2 = picomatch.matchBase(input, regex, options, posix3) : match2 = regex.exec(output)), {
        isMatch: !!match2,
        match: match2,
        output
      };
    };
    picomatch.matchBase = function(input, glob2, options) {
      var posix3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : utils.isWindows(options), regex = _instanceof13(glob2, RegExp) ? glob2 : picomatch.makeRe(glob2, options);
      return regex.test(path6.basename(input));
    };
    picomatch.isMatch = function(str, patterns, options) {
      return picomatch(patterns, options)(str);
    };
    picomatch.parse = function(pattern, options) {
      return Array.isArray(pattern) ? pattern.map(function(p) {
        return picomatch.parse(p, options);
      }) : parse6(pattern, _object_spread_props9(_object_spread13({}, options), {
        fastpaths: !1
      }));
    };
    picomatch.scan = function(input, options) {
      return scan(input, options);
    };
    picomatch.compileRe = function(state, options) {
      var returnOutput = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, returnState = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
      if (returnOutput === !0)
        return state.output;
      var opts = options || {}, prepend = opts.contains ? "" : "^", append = opts.contains ? "" : "$", source = "".concat(prepend, "(?:").concat(state.output, ")").concat(append);
      state && state.negated === !0 && (source = "^(?!".concat(source, ").*$"));
      var regex = picomatch.toRegex(source, options);
      return returnState === !0 && (regex.state = state), regex;
    };
    picomatch.makeRe = function(input) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, returnOutput = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, returnState = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
      if (!input || typeof input != "string")
        throw new TypeError("Expected a non-empty string");
      var parsed = {
        negated: !1,
        fastpaths: !0
      };
      return options.fastpaths !== !1 && (input[0] === "." || input[0] === "*") && (parsed.output = parse6.fastpaths(input, options)), parsed.output || (parsed = parse6(input, options)), picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = function(source, options) {
      try {
        var opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === !0)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// ../../node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "../../node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var _picomatch, _picomatch1, util = require("util"), braces = require_braces(), picomatch = require_picomatch2(), utils = require_utils4(), isEmptyString = function(val) {
      return val === "" || val === "./";
    }, micromatch = function(list, patterns, options) {
      patterns = [].concat(patterns), list = [].concat(list);
      for (var omit = /* @__PURE__ */ new Set(), keep = /* @__PURE__ */ new Set(), items = /* @__PURE__ */ new Set(), negatives = 0, onResult = function(state) {
        items.add(state.output), options && options.onResult && options.onResult(state);
      }, i = 0; i < patterns.length; i++) {
        var isMatch = picomatch(String(patterns[i]), _object_spread_props9(_object_spread13({}, options), {
          onResult
        }), !0), negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        negated && negatives++;
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var item = _step.value, matched = isMatch(item, !0), match2 = negated ? !matched.isMatch : matched.isMatch;
            match2 && (negated ? omit.add(matched.output) : (omit.delete(matched.output), keep.add(matched.output)));
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
      var result = negatives === patterns.length ? _to_consumable_array16(items) : _to_consumable_array16(keep), matches = result.filter(function(item2) {
        return !omit.has(item2);
      });
      if (options && matches.length === 0) {
        if (options.failglob === !0)
          throw new Error('No matches found for "'.concat(patterns.join(", "), '"'));
        if (options.nonull === !0 || options.nullglob === !0)
          return options.unescape ? patterns.map(function(p) {
            return p.replace(/\\/g, "");
          }) : patterns;
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = function(pattern, options) {
      return picomatch(pattern, options);
    };
    micromatch.isMatch = function(str, patterns, options) {
      return picomatch(patterns, options)(str);
    };
    micromatch.any = micromatch.isMatch;
    micromatch.not = function(list, patterns) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      patterns = [].concat(patterns).map(String);
      var result = /* @__PURE__ */ new Set(), items = [], onResult = function(state) {
        options.onResult && options.onResult(state), items.push(state.output);
      }, matches = new Set(micromatch(list, patterns, _object_spread_props9(_object_spread13({}, options), {
        onResult
      }))), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var item = _step.value;
          matches.has(item) || result.add(item);
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return _to_consumable_array16(result);
    };
    micromatch.contains = function(str, pattern, options) {
      if (typeof str != "string")
        throw new TypeError('Expected a string: "'.concat(util.inspect(str), '"'));
      if (Array.isArray(pattern))
        return pattern.some(function(p) {
          return micromatch.contains(str, p, options);
        });
      if (typeof pattern == "string") {
        if (isEmptyString(str) || isEmptyString(pattern))
          return !1;
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern))
          return !0;
      }
      return micromatch.isMatch(str, pattern, _object_spread_props9(_object_spread13({}, options), {
        contains: !0
      }));
    };
    micromatch.matchKeys = function(obj, patterns, options) {
      if (!utils.isObject(obj))
        throw new TypeError("Expected the first argument to be an object");
      var keys = micromatch(Object.keys(obj), patterns, options), res = {}, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var key = _step.value;
          res[key] = obj[key];
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return res;
    };
    micromatch.some = function(list, patterns, options) {
      var items = [].concat(list), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _loop = function() {
          var pattern = _step.value, isMatch = picomatch(String(pattern), options);
          if (items.some(function(item) {
            return isMatch(item);
          }))
            return {
              v: !0
            };
        }, _iterator = [].concat(patterns)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _ret = _loop();
          if (_type_of12(_ret) === "object")
            return _ret.v;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return !1;
    };
    micromatch.every = function(list, patterns, options) {
      var items = [].concat(list), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _loop = function() {
          var pattern = _step.value, isMatch = picomatch(String(pattern), options);
          if (!items.every(function(item) {
            return isMatch(item);
          }))
            return {
              v: !1
            };
        }, _iterator = [].concat(patterns)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _ret = _loop();
          if (_type_of12(_ret) === "object")
            return _ret.v;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return !0;
    };
    micromatch.all = function(str, patterns, options) {
      if (typeof str != "string")
        throw new TypeError('Expected a string: "'.concat(util.inspect(str), '"'));
      return [].concat(patterns).every(function(p) {
        return picomatch(p, options)(str);
      });
    };
    micromatch.capture = function(glob2, input, options) {
      var posix3 = utils.isWindows(options), regex = picomatch.makeRe(String(glob2), _object_spread_props9(_object_spread13({}, options), {
        capture: !0
      })), match2 = regex.exec(posix3 ? utils.toPosixSlashes(input) : input);
      if (match2)
        return match2.slice(1).map(function(v) {
          return v === void 0 ? "" : v;
        });
    };
    micromatch.makeRe = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return (_picomatch = picomatch).makeRe.apply(_picomatch, _to_consumable_array16(args));
    };
    micromatch.scan = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return (_picomatch1 = picomatch).scan.apply(_picomatch1, _to_consumable_array16(args));
    };
    micromatch.parse = function(patterns, options) {
      var res = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = [].concat(patterns || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var pattern = _step.value, _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = braces(String(pattern), options)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var str = _step1.value;
              res.push(picomatch.parse(str, options));
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return res;
    };
    micromatch.braces = function(pattern, options) {
      if (typeof pattern != "string")
        throw new TypeError("Expected a string");
      return options && options.nobrace === !0 || !/\{.*\}/.test(pattern) ? [
        pattern
      ] : braces(pattern, options);
    };
    micromatch.braceExpand = function(pattern, options) {
      if (typeof pattern != "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, _object_spread_props9(_object_spread13({}, options), {
        expand: !0
      }));
    };
    module2.exports = micromatch;
  }
});

// ../../node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.removeDuplicateSlashes = exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path6 = require("path"), globParent = require_glob_parent(), micromatch = require_micromatch(), GLOBSTAR2 = "**", ESCAPE_SYMBOL = "\\", COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/, REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/, REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/, BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./, DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return !isDynamicPattern2(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern2(pattern) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return pattern === "" ? !1 : !!(options.caseSensitiveMatch === !1 || pattern.includes(ESCAPE_SYMBOL) || COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern) || options.extglob !== !1 && GLOB_EXTENSION_SYMBOLS_RE.test(pattern) || options.braceExpansion !== !1 && hasBraceExpansion(pattern));
    }
    exports2.isDynamicPattern = isDynamicPattern2;
    function hasBraceExpansion(pattern) {
      var openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1)
        return !1;
      var closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1)
        return !1;
      var braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern2(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern2(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern2;
    function isPositivePattern(pattern) {
      return !isNegativePattern2(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern2);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter(function(pattern) {
        return !isPatternRelatedToParentDirectory(pattern);
      });
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, {
        flipBackslashes: !1
      });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR2);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR2);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      var basename2 = path6.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename2);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce(function(collection, pattern) {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      var patterns = micromatch.braces(pattern, {
        expand: !0,
        nodupes: !0,
        keepEscaping: !0
      });
      return patterns.sort(function(a, b) {
        return a.length - b.length;
      }), patterns.filter(function(pattern2) {
        return pattern2 !== "";
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      var parts = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {
        parts: !0
      })).parts;
      return parts.length === 0 && (parts = [
        pattern
      ]), parts[0].startsWith("/") && (parts[0] = parts[0].slice(1), parts.unshift("")), parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe2(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe2;
    function convertPatternsToRe(patterns, options) {
      return patterns.map(function(pattern) {
        return makeRe2(pattern, options);
      });
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some(function(patternRe) {
        return patternRe.test(entry);
      });
    }
    exports2.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// ../../node_modules/fast-glob/out/utils/stream.js
var require_stream2 = __commonJS({
  "../../node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.merge = void 0;
    var merge22 = require_merge2();
    function merge(streams) {
      var mergedStream = merge22(streams);
      return streams.forEach(function(stream2) {
        stream2.once("error", function(error) {
          return mergedStream.emit("error", error);
        });
      }), mergedStream.once("close", function() {
        return propagateCloseEventToSources(streams);
      }), mergedStream.once("end", function() {
        return propagateCloseEventToSources(streams);
      }), mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach(function(stream2) {
        return stream2.emit("close");
      });
    }
  }
});

// ../../node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "../../node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.isEmpty = exports2.isString = void 0;
    function isString2(input) {
      return typeof input == "string";
    }
    exports2.isString = isString2;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// ../../node_modules/fast-glob/out/utils/index.js
var require_utils5 = __commonJS({
  "../../node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs7 = require_fs2();
    exports2.fs = fs7;
    var path6 = require_path();
    exports2.path = path6;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream2 = require_stream2();
    exports2.stream = stream2;
    var string = require_string();
    exports2.string = string;
  }
});

// ../../node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "../../node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils5();
    function generate(input, settings) {
      var patterns = processPatterns(input, settings), ignore = processPatterns(settings.ignore, settings), positivePatterns = getPositivePatterns(patterns), negativePatterns = getNegativePatternsAsPositive(patterns, ignore), staticPatterns = positivePatterns.filter(function(pattern) {
        return utils.pattern.isStaticPattern(pattern, settings);
      }), dynamicPatterns = positivePatterns.filter(function(pattern) {
        return utils.pattern.isDynamicPattern(pattern, settings);
      }), staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        !1
      ), dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        !0
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function processPatterns(input, settings) {
      var patterns = input;
      return settings.braceExpansion && (patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns)), settings.baseNameMatch && (patterns = patterns.map(function(pattern) {
        return pattern.includes("/") ? pattern : "**/".concat(pattern);
      })), patterns.map(function(pattern) {
        return utils.pattern.removeDuplicateSlashes(pattern);
      });
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      var _tasks, tasks = [], patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive), patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive), outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory), insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      if ((_tasks = tasks).push.apply(_tasks, _to_consumable_array16(convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic))), "." in insideCurrentDirectoryGroup)
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      else {
        var _tasks1;
        (_tasks1 = tasks).push.apply(_tasks1, _to_consumable_array16(convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic)));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      var negative = utils.pattern.getNegativePatterns(patterns).concat(ignore), positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      var group = {};
      return patterns.reduce(function(collection, pattern) {
        var base = utils.pattern.getBaseDirectory(pattern);
        return base in collection ? collection[base].push(pattern) : collection[base] = [
          pattern
        ], collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map(function(base) {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.read = void 0;
    function read(path6, settings, callback) {
      settings.fs.lstat(path6, function(lstatError, lstat6) {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat6.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat6);
          return;
        }
        settings.fs.stat(path6, function(statError, stat3) {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat6);
            return;
          }
          settings.markSymbolicLink && (stat3.isSymbolicLink = function() {
            return !0;
          }), callSuccessCallback(callback, stat3);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.read = void 0;
    function read(path6, settings) {
      var lstat6 = settings.fs.lstatSync(path6);
      if (!lstat6.isSymbolicLink() || !settings.followSymbolicLink)
        return lstat6;
      try {
        var stat3 = settings.fs.statSync(path6);
        return settings.markSymbolicLink && (stat3.isSymbolicLink = function() {
          return !0;
        }), stat3;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink)
          return lstat6;
        throw error;
      }
    }
    exports2.read = read;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs3 = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      stat: fs7.stat,
      lstatSync: fs7.lstatSync,
      statSync: fs7.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      return fsMethods === void 0 ? exports2.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var fs7 = require_fs3(), Settings = /* @__PURE__ */ function() {
      function Settings2() {
        var _options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, Settings2), this._options = _options2, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = fs7.createFileSystemAdapter(this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
      }
      return _create_class13(Settings2, [
        {
          key: "_getValue",
          value: function(option, value) {
            return option ?? value;
          }
        }
      ]), Settings2;
    }();
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async(), sync2 = require_sync(), settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat3(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        async.read(path6, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat3;
    function statSync2(path6, optionsOrSettings) {
      var settings = getSettings(optionsOrSettings);
      return sync2.read(path6, settings);
    }
    exports2.statSync = statSync2;
    function getSettings() {
      var settingsOrOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _instanceof13(settingsOrOptions, settings_1.default) ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "../../node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (
      // reuse resolved promise, and allocate it lazily
      function(cb) {
        return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {
          return setTimeout(function() {
            throw err;
          }, 0);
        });
      }
    );
  }
});

// ../../node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "../../node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      var results, pending, keys, isSync = !0;
      Array.isArray(tasks) ? (results = [], pending = tasks.length) : (keys = Object.keys(tasks), results = {}, pending = keys.length);
      function done(err) {
        function end() {
          cb && cb(err, results), cb = null;
        }
        isSync ? queueMicrotask2(end) : end();
      }
      function each(i, err, result) {
        results[i] = result, (--pending === 0 || err) && done(err);
      }
      pending ? keys ? keys.forEach(function(key) {
        tasks[key](function(err, result) {
          each(key, err, result);
        });
      }) : tasks.forEach(function(task, i) {
        task(function(err, result) {
          each(i, err, result);
        });
      }) : done(null), isSync = !1;
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0)
      throw new Error("Unexpected behavior. The 'process.versions.node' variable has invalid value: ".concat(process.versions.node));
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10), MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10), SUPPORTED_MAJOR_VERSION = 10, SUPPORTED_MINOR_VERSION = 10, IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION, IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs4 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = function DirentFromStats2(name, stats) {
      _class_call_check15(this, DirentFromStats2), this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils6 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.fs = void 0;
    var fs7 = require_fs4();
    exports2.fs = fs7;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      return a.endsWith(separator) ? a + b : a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out(), rpl = require_run_parallel(), constants_1 = require_constants3(), utils = require_utils6(), common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir4(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, {
        withFileTypes: !0
      }, function(readdirError, dirents) {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        var entries = dirents.map(function(dirent) {
          return {
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
          };
        });
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        var tasks = entries.map(function(entry) {
          return makeRplTaskEntry(entry, settings);
        });
        rpl(tasks, function(rplError, rplEntries) {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return function(done) {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, function(statError, stats) {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats), done(null, entry);
        });
      };
    }
    function readdir4(directory, settings, callback) {
      settings.fs.readdir(directory, function(readdirError, names) {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        var tasks = names.map(function(name) {
          var path6 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return function(done) {
            fsStat.stat(path6, settings.fsStatSettings, function(error, stats) {
              if (error !== null) {
                done(error);
                return;
              }
              var entry = {
                name,
                path: path6,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              settings.stats && (entry.stats = stats), done(null, entry);
            });
          };
        });
        rpl(tasks, function(rplError, entries) {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir4;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out(), constants_1 = require_constants3(), utils = require_utils6(), common = require_common();
    function read(directory, settings) {
      return !settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? readdirWithFileTypes(directory, settings) : readdir4(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      var dirents = settings.fs.readdirSync(directory, {
        withFileTypes: !0
      });
      return dirents.map(function(dirent) {
        var entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks)
          try {
            var stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink)
              throw error;
          }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir4(directory, settings) {
      var names = settings.fs.readdirSync(directory);
      return names.map(function(name) {
        var entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator), stats = fsStat.statSync(entryPath, settings.fsStatSettings), entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        return settings.stats && (entry.stats = stats), entry;
      });
    }
    exports2.readdir = readdir4;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs5 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      stat: fs7.stat,
      lstatSync: fs7.lstatSync,
      statSync: fs7.statSync,
      readdir: fs7.readdir,
      readdirSync: fs7.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      return fsMethods === void 0 ? exports2.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var path6 = require("path"), fsStat = require_out(), fs7 = require_fs5(), Settings = /* @__PURE__ */ function() {
      function Settings2() {
        var _options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, Settings2), this._options = _options2, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = fs7.createFileSystemAdapter(this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep), this.stats = this._getValue(this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      return _create_class13(Settings2, [
        {
          key: "_getValue",
          value: function(option, value) {
            return option ?? value;
          }
        }
      ]), Settings2;
    }();
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2(), sync2 = require_sync2(), settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        async.read(path6, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path6, optionsOrSettings) {
      var settings = getSettings(optionsOrSettings);
      return sync2.read(path6, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings() {
      var settingsOrOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _instanceof13(settingsOrOptions, settings_1.default) ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "../../node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor(), tail = head;
      function get4() {
        var current = head;
        return current.next ? head = current.next : (head = new Constructor(), tail = head), current.next = null, current;
      }
      function release(obj) {
        tail.next = obj, tail = obj;
      }
      return {
        get: get4,
        release
      };
    }
    module2.exports = reusify;
  }
});

// ../../node_modules/fastq/queue.js
var require_queue = __commonJS({
  "../../node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context == "function" && (concurrency = worker, worker = context, context = null), concurrency < 1)
        throw new Error("fastqueue concurrency must be greater than 1");
      var cache2 = reusify(Task), queueHead = null, queueTail = null, _running = 0, errorHandler = null, self = {
        push,
        drain: noop2,
        saturated: noop2,
        pause,
        paused: !1,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop2,
        kill,
        killAndDrain,
        error
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = !0;
      }
      function length() {
        for (var current = queueHead, counter = 0; current; )
          current = current.next, counter++;
        return counter;
      }
      function getQueue() {
        for (var current = queueHead, tasks = []; current; )
          tasks.push(current.value), current = current.next;
        return tasks;
      }
      function resume() {
        if (self.paused) {
          self.paused = !1;
          for (var i = 0; i < self.concurrency; i++)
            _running++, release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push(value, done) {
        var current = cache2.get();
        current.context = context, current.release = release, current.value = value, current.callback = done || noop2, current.errorHandler = errorHandler, _running === self.concurrency || self.paused ? queueTail ? (queueTail.next = current, queueTail = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
      }
      function unshift(value, done) {
        var current = cache2.get();
        current.context = context, current.release = release, current.value = value, current.callback = done || noop2, _running === self.concurrency || self.paused ? queueHead ? (current.next = queueHead, queueHead = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
      }
      function release(holder) {
        holder && cache2.release(holder);
        var next = queueHead;
        next ? self.paused ? _running-- : (queueTail === queueHead && (queueTail = null), queueHead = next.next, next.next = null, worker.call(context, next.value, next.worked), queueTail === null && self.empty()) : --_running === 0 && self.drain();
      }
      function kill() {
        queueHead = null, queueTail = null, self.drain = noop2;
      }
      function killAndDrain() {
        queueHead = null, queueTail = null, self.drain(), self.drain = noop2;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop2() {
    }
    function Task() {
      this.value = null, this.callback = noop2, this.next = null, this.release = noop2, this.context = null, this.errorHandler = null;
      var self = this;
      this.worked = function(err, result) {
        var callback = self.callback, errorHandler = self.errorHandler, val = self.value;
        self.value = null, self.callback = noop2, self.errorHandler && errorHandler(err, val), callback.call(self.context, err, result), self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      typeof context == "function" && (concurrency = worker, worker = context, context = null);
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency), pushCb = queue.push, unshiftCb = queue.unshift;
      return queue.push = push, queue.unshift = unshift, queue.drained = drained, queue;
      function push(value) {
        var p = new Promise(function(resolve7, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve7(result);
          });
        });
        return p.catch(noop2), p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve7, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve7(result);
          });
        });
        return p.catch(noop2), p;
      }
      function drained() {
        if (queue.idle())
          return new Promise(function(resolve7) {
            resolve7();
          });
        var previousDrain = queue.drain, p = new Promise(function(resolve7) {
          queue.drain = function() {
            previousDrain(), resolve7();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      return settings.errorFilter === null ? !0 : !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter2, value) {
      return filter2 === null || filter2(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      return a === "" ? b : a.endsWith(separator) ? a + b : a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var common = require_common2(), Reader = function Reader2(_root2, _settings) {
      _class_call_check15(this, Reader2), this._root = _root2, this._settings = _settings, this._root = common.replacePathSegmentSeparator(_root2, _settings.pathSegmentSeparator);
    };
    exports2.default = Reader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var events_1 = require("events"), fsScandir = require_out2(), fastq = require_queue(), common = require_common2(), reader_1 = require_reader(), AsyncReader = /* @__PURE__ */ function(_reader_1_default) {
      _inherits10(AsyncReader2, _reader_1_default);
      var _super = _create_super10(AsyncReader2);
      function AsyncReader2(_root2, _settings) {
        _class_call_check15(this, AsyncReader2);
        var _this;
        return _this = _super.call(this, _root2, _settings), _this._settings = _settings, _this._scandir = fsScandir.scandir, _this._emitter = new events_1.EventEmitter(), _this._queue = fastq(_this._worker.bind(_assert_this_initialized10(_this)), _this._settings.concurrency), _this._isFatalError = !1, _this._isDestroyed = !1, _this._queue.drain = function() {
          _this._isFatalError || _this._emitter.emit("end");
        }, _this;
      }
      return _create_class13(AsyncReader2, [
        {
          key: "read",
          value: function() {
            var _this = this;
            return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(function() {
              _this._pushToQueue(_this._root, _this._settings.basePath);
            }), this._emitter;
          }
        },
        {
          key: "isDestroyed",
          get: function() {
            return this._isDestroyed;
          }
        },
        {
          key: "destroy",
          value: function() {
            if (this._isDestroyed)
              throw new Error("The reader is already destroyed");
            this._isDestroyed = !0, this._queue.killAndDrain();
          }
        },
        {
          key: "onEntry",
          value: function(callback) {
            this._emitter.on("entry", callback);
          }
        },
        {
          key: "onError",
          value: function(callback) {
            this._emitter.once("error", callback);
          }
        },
        {
          key: "onEnd",
          value: function(callback) {
            this._emitter.once("end", callback);
          }
        },
        {
          key: "_pushToQueue",
          value: function(directory, base) {
            var _this = this, queueItem = {
              directory,
              base
            };
            this._queue.push(queueItem, function(error) {
              error !== null && _this._handleError(error);
            });
          }
        },
        {
          key: "_worker",
          value: function(item, done) {
            var _this = this;
            this._scandir(item.directory, this._settings.fsScandirSettings, function(error, entries) {
              if (error !== null) {
                done(error, void 0);
                return;
              }
              var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var entry = _step.value;
                  _this._handleEntry(entry, item.base);
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
              done(null, void 0);
            });
          }
        },
        {
          key: "_handleError",
          value: function(error) {
            this._isDestroyed || !common.isFatalError(this._settings, error) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("error", error));
          }
        },
        {
          key: "_handleEntry",
          value: function(entry, base) {
            if (!(this._isDestroyed || this._isFatalError)) {
              var fullpath = entry.path;
              base !== void 0 && (entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common.isAppliedFilter(this._settings.entryFilter, entry) && this._emitEntry(entry), entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
            }
          }
        },
        {
          key: "_emitEntry",
          value: function(entry) {
            this._emitter.emit("entry", entry);
          }
        }
      ]), AsyncReader2;
    }(reader_1.default);
    exports2.default = AsyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var async_1 = require_async3(), AsyncProvider = /* @__PURE__ */ function() {
      function AsyncProvider2(_root2, _settings) {
        _class_call_check15(this, AsyncProvider2), this._root = _root2, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._storage = [];
      }
      return _create_class13(AsyncProvider2, [
        {
          key: "read",
          value: function(callback) {
            var _this = this;
            this._reader.onError(function(error) {
              callFailureCallback(callback, error);
            }), this._reader.onEntry(function(entry) {
              _this._storage.push(entry);
            }), this._reader.onEnd(function() {
              callSuccessCallback(callback, _this._storage);
            }), this._reader.read();
          }
        }
      ]), AsyncProvider2;
    }();
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var stream_1 = require("stream"), async_1 = require_async3(), StreamProvider = /* @__PURE__ */ function() {
      function StreamProvider2(_root2, _settings) {
        var _this = this;
        _class_call_check15(this, StreamProvider2), this._root = _root2, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._stream = new stream_1.Readable({
          objectMode: !0,
          read: function() {
          },
          destroy: function() {
            _this._reader.isDestroyed || _this._reader.destroy();
          }
        });
      }
      return _create_class13(StreamProvider2, [
        {
          key: "read",
          value: function() {
            var _this = this;
            return this._reader.onError(function(error) {
              _this._stream.emit("error", error);
            }), this._reader.onEntry(function(entry) {
              _this._stream.push(entry);
            }), this._reader.onEnd(function() {
              _this._stream.push(null);
            }), this._reader.read(), this._stream;
          }
        }
      ]), StreamProvider2;
    }();
    exports2.default = StreamProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var fsScandir = require_out2(), common = require_common2(), reader_1 = require_reader(), SyncReader = /* @__PURE__ */ function(_reader_1_default) {
      _inherits10(SyncReader2, _reader_1_default);
      var _super = _create_super10(SyncReader2);
      function SyncReader2() {
        _class_call_check15(this, SyncReader2);
        var _this;
        return _this = _super.call.apply(_super, [
          this
        ].concat(Array.prototype.slice.call(arguments))), _this._scandir = fsScandir.scandirSync, _this._storage = [], _this._queue = /* @__PURE__ */ new Set(), _this;
      }
      return _create_class13(SyncReader2, [
        {
          key: "read",
          value: function() {
            return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
          }
        },
        {
          key: "_pushToQueue",
          value: function(directory, base) {
            this._queue.add({
              directory,
              base
            });
          }
        },
        {
          key: "_handleQueue",
          value: function() {
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this._queue.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var item = _step.value;
                this._handleDirectory(item.directory, item.base);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
          }
        },
        {
          key: "_handleDirectory",
          value: function(directory, base) {
            try {
              var entries = this._scandir(directory, this._settings.fsScandirSettings), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var entry = _step.value;
                  this._handleEntry(entry, base);
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
            } catch (error) {
              this._handleError(error);
            }
          }
        },
        {
          key: "_handleError",
          value: function(error) {
            if (common.isFatalError(this._settings, error))
              throw error;
          }
        },
        {
          key: "_handleEntry",
          value: function(entry, base) {
            var fullpath = entry.path;
            base !== void 0 && (entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common.isAppliedFilter(this._settings.entryFilter, entry) && this._pushToStorage(entry), entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
          }
        },
        {
          key: "_pushToStorage",
          value: function(entry) {
            this._storage.push(entry);
          }
        }
      ]), SyncReader2;
    }(reader_1.default);
    exports2.default = SyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var sync_1 = require_sync3(), SyncProvider = /* @__PURE__ */ function() {
      function SyncProvider2(_root2, _settings) {
        _class_call_check15(this, SyncProvider2), this._root = _root2, this._settings = _settings, this._reader = new sync_1.default(this._root, this._settings);
      }
      return _create_class13(SyncProvider2, [
        {
          key: "read",
          value: function() {
            return this._reader.read();
          }
        }
      ]), SyncProvider2;
    }();
    exports2.default = SyncProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var path6 = require("path"), fsScandir = require_out2(), Settings = /* @__PURE__ */ function() {
      function Settings2() {
        var _options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, Settings2), this._options = _options2, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep), this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      return _create_class13(Settings2, [
        {
          key: "_getValue",
          value: function(option, value) {
            return option ?? value;
          }
        }
      ]), Settings2;
    }();
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4(), stream_1 = require_stream3(), sync_1 = require_sync4(), settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      var settings = getSettings(optionsOrSettings), provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      var settings = getSettings(optionsOrSettings), provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings() {
      var settingsOrOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _instanceof13(settingsOrOptions, settings_1.default) ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "../../node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var path6 = require("path"), fsStat = require_out(), utils = require_utils5(), Reader = /* @__PURE__ */ function() {
      function Reader2(_settings) {
        _class_call_check15(this, Reader2), this._settings = _settings, this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      return _create_class13(Reader2, [
        {
          key: "_getFullEntryPath",
          value: function(filepath) {
            return path6.resolve(this._settings.cwd, filepath);
          }
        },
        {
          key: "_makeEntry",
          value: function(stats, pattern) {
            var entry = {
              name: pattern,
              path: pattern,
              dirent: utils.fs.createDirentFromStats(pattern, stats)
            };
            return this._settings.stats && (entry.stats = stats), entry;
          }
        },
        {
          key: "_isFatalError",
          value: function(error) {
            return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
          }
        }
      ]), Reader2;
    }();
    exports2.default = Reader;
  }
});

// ../../node_modules/fast-glob/out/readers/stream.js
var require_stream4 = __commonJS({
  "../../node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var stream_1 = require("stream"), fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderStream = /* @__PURE__ */ function(_reader_1_default) {
      _inherits10(ReaderStream2, _reader_1_default);
      var _super = _create_super10(ReaderStream2);
      function ReaderStream2() {
        _class_call_check15(this, ReaderStream2);
        var _this;
        return _this = _super.call.apply(_super, [
          this
        ].concat(Array.prototype.slice.call(arguments))), _this._walkStream = fsWalk.walkStream, _this._stat = fsStat.stat, _this;
      }
      return _create_class13(ReaderStream2, [
        {
          key: "dynamic",
          value: function(root, options) {
            return this._walkStream(root, options);
          }
        },
        {
          key: "static",
          value: function(patterns, options) {
            var _this = this, filepaths = patterns.map(this._getFullEntryPath, this), stream2 = new stream_1.PassThrough({
              objectMode: !0
            });
            stream2._write = function(index, _enc, done) {
              return _this._getEntry(filepaths[index], patterns[index], options).then(function(entry) {
                entry !== null && options.entryFilter(entry) && stream2.push(entry), index === filepaths.length - 1 && stream2.end(), done();
              }).catch(done);
            };
            for (var i = 0; i < filepaths.length; i++)
              stream2.write(i);
            return stream2;
          }
        },
        {
          key: "_getEntry",
          value: function(filepath, pattern, options) {
            var _this = this;
            return this._getStat(filepath).then(function(stats) {
              return _this._makeEntry(stats, pattern);
            }).catch(function(error) {
              if (options.errorFilter(error))
                return null;
              throw error;
            });
          }
        },
        {
          key: "_getStat",
          value: function(filepath) {
            var _this = this;
            return new Promise(function(resolve7, reject) {
              _this._stat(filepath, _this._fsStatSettings, function(error, stats) {
                return error === null ? resolve7(stats) : reject(error);
              });
            });
          }
        }
      ]), ReaderStream2;
    }(reader_1.default);
    exports2.default = ReaderStream;
  }
});

// ../../node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "../../node_modules/fast-glob/out/readers/async.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var fsWalk = require_out3(), reader_1 = require_reader2(), stream_1 = require_stream4(), ReaderAsync = /* @__PURE__ */ function(_reader_1_default) {
      _inherits10(ReaderAsync2, _reader_1_default);
      var _super = _create_super10(ReaderAsync2);
      function ReaderAsync2() {
        _class_call_check15(this, ReaderAsync2);
        var _this;
        return _this = _super.call.apply(_super, [
          this
        ].concat(Array.prototype.slice.call(arguments))), _this._walkAsync = fsWalk.walk, _this._readerStream = new stream_1.default(_this._settings), _this;
      }
      return _create_class13(ReaderAsync2, [
        {
          key: "dynamic",
          value: function(root, options) {
            var _this = this;
            return new Promise(function(resolve7, reject) {
              _this._walkAsync(root, options, function(error, entries) {
                error === null ? resolve7(entries) : reject(error);
              });
            });
          }
        },
        {
          key: "static",
          value: function(patterns, options) {
            var _this = this;
            return _async_to_generator31(function() {
              var entries, stream2;
              return _ts_generator31(this, function(_state) {
                return entries = [], stream2 = _this._readerStream.static(patterns, options), [
                  2,
                  new Promise(function(resolve7, reject) {
                    stream2.once("error", reject), stream2.on("data", function(entry) {
                      return entries.push(entry);
                    }), stream2.once("end", function() {
                      return resolve7(entries);
                    });
                  })
                ];
              });
            })();
          }
        }
      ]), ReaderAsync2;
    }(reader_1.default);
    exports2.default = ReaderAsync;
  }
});

// ../../node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "../../node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var utils = require_utils5(), Matcher = /* @__PURE__ */ function() {
      function Matcher2(_patterns, _settings, _micromatchOptions) {
        _class_call_check15(this, Matcher2), this._patterns = _patterns, this._settings = _settings, this._micromatchOptions = _micromatchOptions, this._storage = [], this._fillStorage();
      }
      return _create_class13(Matcher2, [
        {
          key: "_fillStorage",
          value: function() {
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this._patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var pattern = _step.value, segments = this._getPatternSegments(pattern), sections = this._splitSegmentsIntoSections(segments);
                this._storage.push({
                  complete: sections.length <= 1,
                  pattern,
                  segments,
                  sections
                });
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
          }
        },
        {
          key: "_getPatternSegments",
          value: function(pattern) {
            var _this = this, parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
            return parts.map(function(part) {
              var dynamic = utils.pattern.isDynamicPattern(part, _this._settings);
              return dynamic ? {
                dynamic: !0,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, _this._micromatchOptions)
              } : {
                dynamic: !1,
                pattern: part
              };
            });
          }
        },
        {
          key: "_splitSegmentsIntoSections",
          value: function(segments) {
            return utils.array.splitWhen(segments, function(segment) {
              return segment.dynamic && utils.pattern.hasGlobStar(segment.pattern);
            });
          }
        }
      ]), Matcher2;
    }();
    exports2.default = Matcher;
  }
});

// ../../node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "../../node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var matcher_1 = require_matcher(), PartialMatcher = /* @__PURE__ */ function(_matcher_1_default) {
      _inherits10(PartialMatcher2, _matcher_1_default);
      var _super = _create_super10(PartialMatcher2);
      function PartialMatcher2() {
        return _class_call_check15(this, PartialMatcher2), _super.apply(this, arguments);
      }
      return _create_class13(PartialMatcher2, [
        {
          key: "match",
          value: function(filepath) {
            var parts = filepath.split("/"), levels = parts.length, patterns = this._storage.filter(function(info2) {
              return !info2.complete || info2.segments.length > levels;
            }), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _loop = function() {
                var pattern = _step.value, section = pattern.sections[0];
                if (!pattern.complete && levels > section.length)
                  return {
                    v: !0
                  };
                var match3 = parts.every(function(part, index) {
                  var segment = pattern.segments[index];
                  return !!(segment.dynamic && segment.patternRe.test(part) || !segment.dynamic && segment.pattern === part);
                });
                if (match3)
                  return {
                    v: !0
                  };
              }, _iterator = patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var _ret = _loop();
                if (_type_of12(_ret) === "object")
                  return _ret.v;
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return !1;
          }
        }
      ]), PartialMatcher2;
    }(matcher_1.default);
    exports2.default = PartialMatcher;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var utils = require_utils5(), partial_1 = require_partial(), DeepFilter = /* @__PURE__ */ function() {
      function DeepFilter2(_settings, _micromatchOptions) {
        _class_call_check15(this, DeepFilter2), this._settings = _settings, this._micromatchOptions = _micromatchOptions;
      }
      return _create_class13(DeepFilter2, [
        {
          key: "getFilter",
          value: function(basePath, positive, negative) {
            var _this = this, matcher = this._getMatcher(positive), negativeRe = this._getNegativePatternsRe(negative);
            return function(entry) {
              return _this._filter(basePath, entry, matcher, negativeRe);
            };
          }
        },
        {
          key: "_getMatcher",
          value: function(patterns) {
            return new partial_1.default(patterns, this._settings, this._micromatchOptions);
          }
        },
        {
          key: "_getNegativePatternsRe",
          value: function(patterns) {
            var affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
            return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
          }
        },
        {
          key: "_filter",
          value: function(basePath, entry, matcher, negativeRe) {
            if (this._isSkippedByDeep(basePath, entry.path) || this._isSkippedSymbolicLink(entry))
              return !1;
            var filepath = utils.path.removeLeadingDotSegment(entry.path);
            return this._isSkippedByPositivePatterns(filepath, matcher) ? !1 : this._isSkippedByNegativePatterns(filepath, negativeRe);
          }
        },
        {
          key: "_isSkippedByDeep",
          value: function(basePath, entryPath) {
            return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
          }
        },
        {
          key: "_getEntryLevel",
          value: function(basePath, entryPath) {
            var entryPathDepth = entryPath.split("/").length;
            if (basePath === "")
              return entryPathDepth;
            var basePathDepth = basePath.split("/").length;
            return entryPathDepth - basePathDepth;
          }
        },
        {
          key: "_isSkippedSymbolicLink",
          value: function(entry) {
            return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
          }
        },
        {
          key: "_isSkippedByPositivePatterns",
          value: function(entryPath, matcher) {
            return !this._settings.baseNameMatch && !matcher.match(entryPath);
          }
        },
        {
          key: "_isSkippedByNegativePatterns",
          value: function(entryPath, patternsRe) {
            return !utils.pattern.matchAny(entryPath, patternsRe);
          }
        }
      ]), DeepFilter2;
    }();
    exports2.default = DeepFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var utils = require_utils5(), EntryFilter = /* @__PURE__ */ function() {
      function EntryFilter2(_settings, _micromatchOptions) {
        _class_call_check15(this, EntryFilter2), this._settings = _settings, this._micromatchOptions = _micromatchOptions, this.index = /* @__PURE__ */ new Map();
      }
      return _create_class13(EntryFilter2, [
        {
          key: "getFilter",
          value: function(positive, negative) {
            var _this = this, positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions), negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), {
              dot: !0
            }));
            return function(entry) {
              return _this._filter(entry, positiveRe, negativeRe);
            };
          }
        },
        {
          key: "_filter",
          value: function(entry, positiveRe, negativeRe) {
            var filepath = utils.path.removeLeadingDotSegment(entry.path);
            if (this._settings.unique && this._isDuplicateEntry(filepath) || this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry) || this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe))
              return !1;
            var isDirectory = entry.dirent.isDirectory(), isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
            return this._settings.unique && isMatched && this._createIndexRecord(filepath), isMatched;
          }
        },
        {
          key: "_isDuplicateEntry",
          value: function(filepath) {
            return this.index.has(filepath);
          }
        },
        {
          key: "_createIndexRecord",
          value: function(filepath) {
            this.index.set(filepath, void 0);
          }
        },
        {
          key: "_onlyFileFilter",
          value: function(entry) {
            return this._settings.onlyFiles && !entry.dirent.isFile();
          }
        },
        {
          key: "_onlyDirectoryFilter",
          value: function(entry) {
            return this._settings.onlyDirectories && !entry.dirent.isDirectory();
          }
        },
        {
          key: "_isSkippedByAbsoluteNegativePatterns",
          value: function(entryPath, patternsRe) {
            if (!this._settings.absolute)
              return !1;
            var fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
            return utils.pattern.matchAny(fullpath, patternsRe);
          }
        },
        {
          key: "_isMatchToPatterns",
          value: function(filepath, patternsRe, isDirectory) {
            var isMatched = utils.pattern.matchAny(filepath, patternsRe);
            return !isMatched && isDirectory ? utils.pattern.matchAny(filepath + "/", patternsRe) : isMatched;
          }
        }
      ]), EntryFilter2;
    }();
    exports2.default = EntryFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/error.js
var require_error2 = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var utils = require_utils5(), ErrorFilter = /* @__PURE__ */ function() {
      function ErrorFilter2(_settings) {
        _class_call_check15(this, ErrorFilter2), this._settings = _settings;
      }
      return _create_class13(ErrorFilter2, [
        {
          key: "getFilter",
          value: function() {
            var _this = this;
            return function(error) {
              return _this._isNonFatalError(error);
            };
          }
        },
        {
          key: "_isNonFatalError",
          value: function(error) {
            return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
          }
        }
      ]), ErrorFilter2;
    }();
    exports2.default = ErrorFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "../../node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var utils = require_utils5(), EntryTransformer = /* @__PURE__ */ function() {
      function EntryTransformer2(_settings) {
        _class_call_check15(this, EntryTransformer2), this._settings = _settings;
      }
      return _create_class13(EntryTransformer2, [
        {
          key: "getTransformer",
          value: function() {
            var _this = this;
            return function(entry) {
              return _this._transform(entry);
            };
          }
        },
        {
          key: "_transform",
          value: function(entry) {
            var filepath = entry.path;
            return this._settings.absolute && (filepath = utils.path.makeAbsolute(this._settings.cwd, filepath), filepath = utils.path.unixify(filepath)), this._settings.markDirectories && entry.dirent.isDirectory() && (filepath += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, entry), {
              path: filepath
            }) : filepath;
          }
        }
      ]), EntryTransformer2;
    }();
    exports2.default = EntryTransformer;
  }
});

// ../../node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "../../node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var path6 = require("path"), deep_1 = require_deep(), entry_1 = require_entry(), error_1 = require_error2(), entry_2 = require_entry2(), Provider = /* @__PURE__ */ function() {
      function Provider2(_settings) {
        _class_call_check15(this, Provider2), this._settings = _settings, this.errorFilter = new error_1.default(this._settings), this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions()), this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new entry_2.default(this._settings);
      }
      return _create_class13(Provider2, [
        {
          key: "_getRootDirectory",
          value: function(task) {
            return path6.resolve(this._settings.cwd, task.base);
          }
        },
        {
          key: "_getReaderOptions",
          value: function(task) {
            var basePath = task.base === "." ? "" : task.base;
            return {
              basePath,
              pathSegmentSeparator: "/",
              concurrency: this._settings.concurrency,
              deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
              entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
              errorFilter: this.errorFilter.getFilter(),
              followSymbolicLinks: this._settings.followSymbolicLinks,
              fs: this._settings.fs,
              stats: this._settings.stats,
              throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
              transform: this.entryTransformer.getTransformer()
            };
          }
        },
        {
          key: "_getMicromatchOptions",
          value: function() {
            return {
              dot: this._settings.dot,
              matchBase: this._settings.baseNameMatch,
              nobrace: !this._settings.braceExpansion,
              nocase: !this._settings.caseSensitiveMatch,
              noext: !this._settings.extglob,
              noglobstar: !this._settings.globstar,
              posix: !0,
              strictSlashes: !1
            };
          }
        }
      ]), Provider2;
    }();
    exports2.default = Provider;
  }
});

// ../../node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "../../node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var async_1 = require_async5(), provider_1 = require_provider(), ProviderAsync = /* @__PURE__ */ function(_provider_1_default) {
      _inherits10(ProviderAsync2, _provider_1_default);
      var _super = _create_super10(ProviderAsync2);
      function ProviderAsync2() {
        _class_call_check15(this, ProviderAsync2);
        var _this;
        return _this = _super.call.apply(_super, [
          this
        ].concat(Array.prototype.slice.call(arguments))), _this._reader = new async_1.default(_this._settings), _this;
      }
      return _create_class13(ProviderAsync2, [
        {
          key: "read",
          value: function(task) {
            var _this = this;
            return _async_to_generator31(function() {
              var root, options, entries;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return root = _this._getRootDirectory(task), options = _this._getReaderOptions(task), [
                      4,
                      _this.api(root, task, options)
                    ];
                  case 1:
                    return entries = _state.sent(), [
                      2,
                      entries.map(function(entry) {
                        return options.transform(entry);
                      })
                    ];
                }
              });
            })();
          }
        },
        {
          key: "api",
          value: function(root, task, options) {
            return task.dynamic ? this._reader.dynamic(root, options) : this._reader.static(task.patterns, options);
          }
        }
      ]), ProviderAsync2;
    }(provider_1.default);
    exports2.default = ProviderAsync;
  }
});

// ../../node_modules/fast-glob/out/providers/stream.js
var require_stream5 = __commonJS({
  "../../node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var stream_1 = require("stream"), stream_2 = require_stream4(), provider_1 = require_provider(), ProviderStream = /* @__PURE__ */ function(_provider_1_default) {
      _inherits10(ProviderStream2, _provider_1_default);
      var _super = _create_super10(ProviderStream2);
      function ProviderStream2() {
        _class_call_check15(this, ProviderStream2);
        var _this;
        return _this = _super.call.apply(_super, [
          this
        ].concat(Array.prototype.slice.call(arguments))), _this._reader = new stream_2.default(_this._settings), _this;
      }
      return _create_class13(ProviderStream2, [
        {
          key: "read",
          value: function(task) {
            var root = this._getRootDirectory(task), options = this._getReaderOptions(task), source = this.api(root, task, options), destination = new stream_1.Readable({
              objectMode: !0,
              read: function() {
              }
            });
            return source.once("error", function(error) {
              return destination.emit("error", error);
            }).on("data", function(entry) {
              return destination.emit("data", options.transform(entry));
            }).once("end", function() {
              return destination.emit("end");
            }), destination.once("close", function() {
              return source.destroy();
            }), destination;
          }
        },
        {
          key: "api",
          value: function(root, task, options) {
            return task.dynamic ? this._reader.dynamic(root, options) : this._reader.static(task.patterns, options);
          }
        }
      ]), ProviderStream2;
    }(provider_1.default);
    exports2.default = ProviderStream;
  }
});

// ../../node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "../../node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderSync = /* @__PURE__ */ function(_reader_1_default) {
      _inherits10(ReaderSync2, _reader_1_default);
      var _super = _create_super10(ReaderSync2);
      function ReaderSync2() {
        _class_call_check15(this, ReaderSync2);
        var _this;
        return _this = _super.call.apply(_super, [
          this
        ].concat(Array.prototype.slice.call(arguments))), _this._walkSync = fsWalk.walkSync, _this._statSync = fsStat.statSync, _this;
      }
      return _create_class13(ReaderSync2, [
        {
          key: "dynamic",
          value: function(root, options) {
            return this._walkSync(root, options);
          }
        },
        {
          key: "static",
          value: function(patterns, options) {
            var entries = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var pattern = _step.value, filepath = this._getFullEntryPath(pattern), entry = this._getEntry(filepath, pattern, options);
                entry === null || !options.entryFilter(entry) || entries.push(entry);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return entries;
          }
        },
        {
          key: "_getEntry",
          value: function(filepath, pattern, options) {
            try {
              var stats = this._getStat(filepath);
              return this._makeEntry(stats, pattern);
            } catch (error) {
              if (options.errorFilter(error))
                return null;
              throw error;
            }
          }
        },
        {
          key: "_getStat",
          value: function(filepath) {
            return this._statSync(filepath, this._fsStatSettings);
          }
        }
      ]), ReaderSync2;
    }(reader_1.default);
    exports2.default = ReaderSync;
  }
});

// ../../node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "../../node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var sync_1 = require_sync5(), provider_1 = require_provider(), ProviderSync = /* @__PURE__ */ function(_provider_1_default) {
      _inherits10(ProviderSync2, _provider_1_default);
      var _super = _create_super10(ProviderSync2);
      function ProviderSync2() {
        _class_call_check15(this, ProviderSync2);
        var _this;
        return _this = _super.call.apply(_super, [
          this
        ].concat(Array.prototype.slice.call(arguments))), _this._reader = new sync_1.default(_this._settings), _this;
      }
      return _create_class13(ProviderSync2, [
        {
          key: "read",
          value: function(task) {
            var root = this._getRootDirectory(task), options = this._getReaderOptions(task), entries = this.api(root, task, options);
            return entries.map(options.transform);
          }
        },
        {
          key: "api",
          value: function(root, task, options) {
            return task.dynamic ? this._reader.dynamic(root, options) : this._reader.static(task.patterns, options);
          }
        }
      ]), ProviderSync2;
    }(provider_1.default);
    exports2.default = ProviderSync;
  }
});

// ../../node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "../../node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = require("fs"), os2 = require("os"), CPU_COUNT = Math.max(os2.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      lstatSync: fs7.lstatSync,
      stat: fs7.stat,
      statSync: fs7.statSync,
      readdir: fs7.readdir,
      readdirSync: fs7.readdirSync
    };
    var Settings = /* @__PURE__ */ function() {
      function Settings2() {
        var _options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, Settings2), this._options = _options2, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch, !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, !0), this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this._options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []), this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1), this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0), this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories && (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
      }
      return _create_class13(Settings2, [
        {
          key: "_getValue",
          value: function(option, value) {
            return option === void 0 ? value : option;
          }
        },
        {
          key: "_getFileSystemMethods",
          value: function() {
            var methods = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
          }
        }
      ]), Settings2;
    }();
    exports2.default = Settings;
  }
});

// ../../node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "../../node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var taskManager = require_tasks(), async_1 = require_async6(), stream_1 = require_stream5(), sync_1 = require_sync6(), settings_1 = require_settings4(), utils = require_utils5();
    function FastGlob(source, options) {
      return _FastGlob.apply(this, arguments);
    }
    function _FastGlob() {
      return _FastGlob = _async_to_generator31(function(source, options) {
        var works, result;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return assertPatternsInput2(source), works = getWorks(source, async_1.default, options), [
                4,
                Promise.all(works)
              ];
            case 1:
              return result = _state.sent(), [
                2,
                utils.array.flatten(result)
              ];
          }
        });
      }), _FastGlob.apply(this, arguments);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2, FastGlob2.globSync = sync2, FastGlob2.globStream = stream2, FastGlob2.async = FastGlob2;
      function sync2(source, options) {
        assertPatternsInput2(source);
        var works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream2(source, options) {
        assertPatternsInput2(source);
        var works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream2;
      function generateTasks2(source, options) {
        assertPatternsInput2(source);
        var patterns = [].concat(source), settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks2;
      function isDynamicPattern2(source, options) {
        assertPatternsInput2(source);
        var settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source) {
        return assertPatternsInput2(source), utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        return assertPatternsInput2(source), utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      var posix3;
      (function(posix4) {
        function escapePath2(source) {
          return assertPatternsInput2(source), utils.path.escapePosixPath(source);
        }
        posix4.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          return assertPatternsInput2(source), utils.path.convertPosixPathToPattern(source);
        }
        posix4.convertPathToPattern = convertPathToPattern2;
      })(posix3 = FastGlob2.posix || (FastGlob2.posix = {}));
      var win322;
      (function(win323) {
        function escapePath2(source) {
          return assertPatternsInput2(source), utils.path.escapeWindowsPath(source);
        }
        win323.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          return assertPatternsInput2(source), utils.path.convertWindowsPathToPattern(source);
        }
        win323.convertPathToPattern = convertPathToPattern2;
      })(win322 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      var patterns = [].concat(source), settings = new settings_1.default(options), tasks = taskManager.generate(patterns, settings), provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput2(input) {
      var source = [].concat(input), isValidSource = source.every(function(item) {
        return utils.string.isString(item) && !utils.string.isEmpty(item);
      });
      if (!isValidSource)
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
    }
    module2.exports = FastGlob;
  }
});

// ../../node_modules/path-type/index.js
var require_path_type = __commonJS({
  "../../node_modules/path-type/index.js"(exports2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var promisify2 = require("util").promisify, fs7 = require("fs");
    function isType(fsStatType, statsMethodName, filePath) {
      return _isType.apply(this, arguments);
    }
    function _isType() {
      return _isType = _async_to_generator31(function(fsStatType, statsMethodName, filePath) {
        var stats, error;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (typeof filePath != "string")
                throw new TypeError("Expected a string, got ".concat(typeof filePath > "u" ? "undefined" : _type_of12(filePath)));
              _state.label = 1;
            case 1:
              return _state.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                promisify2(fs7[fsStatType])(filePath)
              ];
            case 2:
              return stats = _state.sent(), [
                2,
                stats[statsMethodName]()
              ];
            case 3:
              if (error = _state.sent(), error.code === "ENOENT")
                return [
                  2,
                  !1
                ];
              throw error;
            case 4:
              return [
                2
              ];
          }
        });
      }), _isType.apply(this, arguments);
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath != "string")
        throw new TypeError("Expected a string, got ".concat(typeof filePath > "u" ? "undefined" : _type_of12(filePath)));
      try {
        return fs7[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT")
          return !1;
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// ../../node_modules/dir-glob/index.js
var require_dir_glob = __commonJS({
  "../../node_modules/dir-glob/index.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var path6 = require("path"), pathType = require_path_type(), getExtensions = function(extensions) {
      return extensions.length > 1 ? "{".concat(extensions.join(","), "}") : extensions[0];
    }, getPath = function(filepath, cwd2) {
      var pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path6.isAbsolute(pth) ? pth : path6.join(cwd2, pth);
    }, addExtensions = function(file, extensions) {
      return path6.extname(file) ? "**/".concat(file) : "**/".concat(file, ".").concat(getExtensions(extensions));
    }, getGlob = function(directory, options) {
      if (options.files && !Array.isArray(options.files))
        throw new TypeError("Expected `files` to be of type `Array` but received type `".concat(_type_of12(options.files), "`"));
      if (options.extensions && !Array.isArray(options.extensions))
        throw new TypeError("Expected `extensions` to be of type `Array` but received type `".concat(_type_of12(options.extensions), "`"));
      return options.files && options.extensions ? options.files.map(function(x) {
        return path6.posix.join(directory, addExtensions(x, options.extensions));
      }) : options.files ? options.files.map(function(x) {
        return path6.posix.join(directory, "**/".concat(x));
      }) : options.extensions ? [
        path6.posix.join(directory, "**/*.".concat(getExtensions(options.extensions)))
      ] : [
        path6.posix.join(directory, "**")
      ];
    };
    module2.exports = function() {
      var _ref = _async_to_generator31(function(input, options) {
        var globs;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (options = _object_spread13({
                cwd: process.cwd()
              }, options), typeof options.cwd != "string")
                throw new TypeError("Expected `cwd` to be of type `string` but received type `".concat(_type_of12(options.cwd), "`"));
              return [
                4,
                Promise.all([].concat(input).map(function() {
                  var _ref2 = _async_to_generator31(function(x) {
                    var isDirectory;
                    return _ts_generator31(this, function(_state2) {
                      switch (_state2.label) {
                        case 0:
                          return [
                            4,
                            pathType.isDirectory(getPath(x, options.cwd))
                          ];
                        case 1:
                          return isDirectory = _state2.sent(), [
                            2,
                            isDirectory ? getGlob(x, options) : x
                          ];
                      }
                    });
                  });
                  return function(x) {
                    return _ref2.apply(this, arguments);
                  };
                }()))
              ];
            case 1:
              return globs = _state.sent(), [
                2,
                [].concat.apply([], globs)
              ];
          }
        });
      });
      return function(input, options) {
        return _ref.apply(this, arguments);
      };
    }();
    module2.exports.sync = function(input, options) {
      if (options = _object_spread13({
        cwd: process.cwd()
      }, options), typeof options.cwd != "string")
        throw new TypeError("Expected `cwd` to be of type `string` but received type `".concat(_type_of12(options.cwd), "`"));
      var globs = [].concat(input).map(function(x) {
        return pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x;
      });
      return [].concat.apply([], globs);
    };
  }
});

// ../../node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../node_modules/ignore/index.js"(exports2, module2) {
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [
        subject
      ];
    }
    var EMPTY = "", SPACE = " ", ESCAPE = "\\", REGEX_TEST_BLANK_LINE = /^\s+$/, REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/, REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/, REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/, REGEX_SPLITALL_CRLF = /\r?\n/g, REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/, SLASH = "/", TMP_KEY_IGNORE = "node-ignore";
    typeof Symbol < "u" && (TMP_KEY_IGNORE = Symbol.for("node-ignore"));
    var KEY_IGNORE = TMP_KEY_IGNORE, define = function(object, key, value) {
      return Object.defineProperty(object, key, {
        value
      });
    }, REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g, RETURN_FALSE = function() {
      return !1;
    }, sanitizeRange = function(range) {
      return range.replace(REGEX_REGEXP_RANGE, function(match2, from, to) {
        return from.charCodeAt(0) <= to.charCodeAt(0) ? match2 : (
          // Invalid range (out of order) which is ok for gitignore rules but
          //   fatal for JavaScript regular expression, so eliminate it.
          EMPTY
        );
      });
    }, cleanRangeBackSlash = function(slashes) {
      var length = slashes.length;
      return slashes.slice(0, length - length % 2);
    }, REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        function(match2) {
          return match2.indexOf("\\") === 0 ? SPACE : EMPTY;
        }
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        function() {
          return SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        function(match2) {
          return "\\".concat(match2);
        }
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        function() {
          return "[^/]";
        }
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        function() {
          return "^";
        }
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        function() {
          return "\\/";
        }
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        function() {
          return "^(?:.*\\/)?";
        }
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function() {
          return /\/(?!$)/.test(this) ? (
            // > Otherwise, Git treats the pattern as a shell glob suitable for
            // >   consumption by fnmatch(3)
            "^"
          ) : (
            // > Prior to 2.22.1
            // > If the pattern does not contain a slash /,
            // >   Git treats it as a shell glob pattern
            // Actually, if there is only a trailing slash,
            //   git also treats it as a shell glob pattern
            // After 2.22.1 (compatible but clearer)
            // > If there is a separator at the beginning or middle (or both)
            // > of the pattern, then the pattern is relative to the directory
            // > level of the particular .gitignore file itself.
            // > Otherwise the pattern may also match at any level below
            // > the .gitignore level.
            "(?:^|\\/)"
          );
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        function(_, index, str) {
          return index + 6 < str.length ? (
            // case: /**/
            // > A slash followed by two consecutive asterisks then a slash matches
            // >   zero or more directories.
            // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
            // '/**/'
            "(?:\\/[^\\/]+)*"
          ) : (
            // case: /**
            // > A trailing `"/**"` matches everything inside.
            // #21: everything inside but it should not include the current folder
            "\\/.+"
          );
        }
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        function(_, p1, p2) {
          var unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        function() {
          return ESCAPE;
        }
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        function() {
          return ESCAPE;
        }
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        function(match2, leadEscape, range, endEscape, close) {
          return leadEscape === ESCAPE ? (
            // '\\[bar]' -> '\\\\[bar\\]'
            "\\[".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close)
          ) : close === "]" && endEscape.length % 2 === 0 ? (
            // A normal case, and it is a range notation
            // '[bar]'
            // '[bar\\\\]'
            "[".concat(sanitizeRange(range)).concat(endEscape, "]")
          ) : "[]";
        }
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        function(match2) {
          return /\/$/.test(match2) ? (
            // foo/ will not match 'foo'
            "".concat(match2, "$")
          ) : (
            // foo matches 'foo' and 'foo/'
            "".concat(match2, "(?=$|\\/$)")
          );
        }
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        function(_, p1) {
          var prefix = p1 ? (
            // '\^':
            // '/*' does not match EMPTY
            // '/*' does not match everything
            // '\\\/':
            // 'abc/*' does not match 'abc/'
            "".concat(p1, "[^/]+")
          ) : (
            // 'a*' matches 'a'
            // 'a*' matches 'aa'
            "[^/]*"
          );
          return "".concat(prefix, "(?=$|\\/$)");
        }
      ]
    ], regexCache = /* @__PURE__ */ Object.create(null), makeRegex = function(pattern, ignoreCase) {
      var source = regexCache[pattern];
      return source || (source = REPLACERS.reduce(function(prev, current) {
        return prev.replace(current[0], current[1].bind(pattern));
      }, pattern), regexCache[pattern] = source), ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    }, isString2 = function(subject) {
      return typeof subject == "string";
    }, checkPattern = function(pattern) {
      return pattern && isString2(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && // > A line starting with # serves as a comment.
      pattern.indexOf("#") !== 0;
    }, splitPattern = function(pattern) {
      return pattern.split(REGEX_SPLITALL_CRLF);
    }, IgnoreRule = function IgnoreRule2(origin, pattern, negative, regex) {
      "use strict";
      _class_call_check15(this, IgnoreRule2), this.origin = origin, this.pattern = pattern, this.negative = negative, this.regex = regex;
    }, createRule = function(pattern, ignoreCase) {
      var origin = pattern, negative = !1;
      pattern.indexOf("!") === 0 && (negative = !0, pattern = pattern.substr(1)), pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      var regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(origin, pattern, negative, regex);
    }, throwError = function(message, Ctor) {
      throw new Ctor(message);
    }, checkPath = function(path6, originalPath, doThrow) {
      if (!isString2(path6))
        return doThrow("path must be a string, but got `".concat(originalPath, "`"), TypeError);
      if (!path6)
        return doThrow("path must not be empty", TypeError);
      if (checkPath.isNotRelative(path6)) {
        var r = "`path.relative()`d";
        return doThrow("path should be a ".concat(r, ' string, but got "').concat(originalPath, '"'), RangeError);
      }
      return !0;
    }, isNotRelative = function(path6) {
      return REGEX_TEST_INVALID_PATH.test(path6);
    };
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = function(p) {
      return p;
    };
    var Ignore2 = /* @__PURE__ */ function() {
      "use strict";
      function Ignore3() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref_ignorecase = _ref.ignorecase, ignorecase = _ref_ignorecase === void 0 ? !0 : _ref_ignorecase, _ref_ignoreCase = _ref.ignoreCase, ignoreCase = _ref_ignoreCase === void 0 ? ignorecase : _ref_ignoreCase, _ref_allowRelativePaths = _ref.allowRelativePaths, allowRelativePaths = _ref_allowRelativePaths === void 0 ? !1 : _ref_allowRelativePaths;
        _class_call_check15(this, Ignore3), define(this, KEY_IGNORE, !0), this._rules = [], this._ignoreCase = ignoreCase, this._allowRelativePaths = allowRelativePaths, this._initCache();
      }
      return _create_class13(Ignore3, [
        {
          key: "_initCache",
          value: function() {
            this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
          }
        },
        {
          key: "_addPattern",
          value: function(pattern) {
            if (pattern && pattern[KEY_IGNORE]) {
              this._rules = this._rules.concat(pattern._rules), this._added = !0;
              return;
            }
            if (checkPattern(pattern)) {
              var rule = createRule(pattern, this._ignoreCase);
              this._added = !0, this._rules.push(rule);
            }
          }
        },
        {
          // @param {Array<string> | string | Ignore} pattern
          key: "add",
          value: function(pattern) {
            return this._added = !1, makeArray(isString2(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this), this._added && this._initCache(), this;
          }
        },
        {
          // legacy
          key: "addPattern",
          value: function(pattern) {
            return this.add(pattern);
          }
        },
        {
          //          |           ignored : unignored
          // negative |   0:0   |   0:1   |   1:0   |   1:1
          // -------- | ------- | ------- | ------- | --------
          //     0    |  TEST   |  TEST   |  SKIP   |    X
          //     1    |  TESTIF |  SKIP   |  TEST   |    X
          // - SKIP: always skip
          // - TEST: always test
          // - TESTIF: only test if checkUnignored
          // - X: that never happen
          // @param {boolean} whether should check if the path is unignored,
          //   setting `checkUnignored` to `false` could reduce additional
          //   path matching.
          // @returns {TestResult} true if a file is ignored
          key: "_testOne",
          value: function(path6, checkUnignored) {
            var ignored2 = !1, unignored = !1;
            return this._rules.forEach(function(rule) {
              var negative = rule.negative;
              if (!(unignored === negative && ignored2 !== unignored || negative && !ignored2 && !unignored && !checkUnignored)) {
                var matched = rule.regex.test(path6);
                matched && (ignored2 = !negative, unignored = negative);
              }
            }), {
              ignored: ignored2,
              unignored
            };
          }
        },
        {
          // @returns {TestResult}
          key: "_test",
          value: function(originalPath, cache2, checkUnignored, slices) {
            var path6 = originalPath && // Supports nullable path
            checkPath.convert(originalPath);
            return checkPath(path6, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError), this._t(path6, cache2, checkUnignored, slices);
          }
        },
        {
          key: "_t",
          value: function(path6, cache2, checkUnignored, slices) {
            if (path6 in cache2)
              return cache2[path6];
            if (slices || (slices = path6.split(SLASH)), slices.pop(), !slices.length)
              return cache2[path6] = this._testOne(path6, checkUnignored);
            var parent = this._t(slices.join(SLASH) + SLASH, cache2, checkUnignored, slices);
            return cache2[path6] = parent.ignored ? (
              // > It is not possible to re-include a file if a parent directory of
              // >   that file is excluded.
              parent
            ) : this._testOne(path6, checkUnignored);
          }
        },
        {
          key: "ignores",
          value: function(path6) {
            return this._test(path6, this._ignoreCache, !1).ignored;
          }
        },
        {
          key: "createFilter",
          value: function() {
            var _this = this;
            return function(path6) {
              return !_this.ignores(path6);
            };
          }
        },
        {
          key: "filter",
          value: function(paths) {
            return makeArray(paths).filter(this.createFilter());
          }
        },
        {
          // @returns {TestResult}
          key: "test",
          value: function(path6) {
            return this._test(path6, this._testCache, !0);
          }
        }
      ]), Ignore3;
    }(), factory = function(options) {
      return new Ignore2(options);
    }, isPathValid = function(path6) {
      return checkPath(path6 && checkPath.convert(path6), path6, RETURN_FALSE);
    };
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    // Detect `process` so that it can run in browsers.
    typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32") && (makePosix = function(str) {
      return /^\\\\\?\\/.test(str) || RegExp('["<>|\\u0000-\\u001F]+', "u").test(str) ? str : str.replace(/\\/g, "/");
    }, checkPath.convert = makePosix, REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i, checkPath.isNotRelative = function(path6) {
      return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path6) || isNotRelative(path6);
    });
    var makePosix, REGIX_IS_WINDOWS_PATH_ABSOLUTE;
  }
});

// ../../node_modules/minimist/index.js
var require_minimist = __commonJS({
  "../../node_modules/minimist/index.js"(exports2, module2) {
    "use strict";
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      return typeof x == "number" || /^0x[0-9a-f]+$/i.test(x) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return key === "constructor" && typeof obj[key] == "function" || key === "__proto__";
    }
    module2.exports = function(args, opts) {
      opts || (opts = {});
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null
      };
      typeof opts.unknown == "function" && (flags.unknownFn = opts.unknown), typeof opts.boolean == "boolean" && opts.boolean ? flags.allBools = !0 : [].concat(opts.boolean).filter(Boolean).forEach(function(key2) {
        flags.bools[key2] = !0;
      });
      var aliases = {};
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]), aliases[key2].forEach(function(x) {
          aliases[x] = [
            key2
          ].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      }), [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = !0, aliases[key2] && [].concat(aliases[key2]).forEach(function(k) {
          flags.strings[k] = !0;
        });
      });
      var defaults3 = opts.default || {}, argv2 = {
        _: []
      };
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setKey(obj, keys, value2) {
        for (var o = obj, i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2))
            return;
          o[key2] === void 0 && (o[key2] = {}), (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype) && (o[key2] = {}), o[key2] === Array.prototype && (o[key2] = []), o = o[key2];
        }
        var lastKey = keys[keys.length - 1];
        isConstructorOrProto(o, lastKey) || ((o === Object.prototype || o === Number.prototype || o === String.prototype) && (o = {}), o === Array.prototype && (o = []), o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] == "boolean" ? o[lastKey] = value2 : Array.isArray(o[lastKey]) ? o[lastKey].push(value2) : o[lastKey] = [
          o[lastKey],
          value2
        ]);
      }
      function setArg(key2, val, arg2) {
        if (!(arg2 && flags.unknownFn && !argDefined(key2, arg2) && flags.unknownFn(arg2) === !1)) {
          var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
          setKey(argv2, key2.split("."), value2), (aliases[key2] || []).forEach(function(x) {
            setKey(argv2, x.split("."), value2);
          });
        }
      }
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults3[key2] === void 0 ? !1 : defaults3[key2]);
      });
      var notFlags = [];
      args.indexOf("--") !== -1 && (notFlags = args.slice(args.indexOf("--") + 1), args = args.slice(0, args.indexOf("--")));
      for (var i = 0; i < args.length; i++) {
        var arg = args[i], key, next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key = m[1];
          var value = m[2];
          flags.bools[key] && (value = value !== "false"), setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg))
          key = arg.match(/^--no-(.+)/)[1], setArg(key, !1, arg);
        else if (/^--.+/.test(arg))
          key = arg.match(/^--(.+)/)[1], next = args[i + 1], next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key] && !flags.allBools && (!aliases[key] || !aliasIsBoolean(key)) ? (setArg(key, next, arg), i += 1) : /^(true|false)$/.test(next) ? (setArg(key, next === "true", arg), i += 1) : setArg(key, flags.strings[key] ? "" : !0, arg);
        else if (/^-[^-]+/.test(arg)) {
          for (var letters = arg.slice(1, -1).split(""), broken = !1, j = 0; j < letters.length; j++) {
            if (next = arg.slice(j + 2), next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
              setArg(letters[j], next.slice(1), arg), broken = !0;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg), broken = !0;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg), broken = !0;
              break;
            } else
              setArg(letters[j], flags.strings[letters[j]] ? "" : !0, arg);
          }
          key = arg.slice(-1)[0], !broken && key !== "-" && (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (!aliases[key] || !aliasIsBoolean(key)) ? (setArg(key, args[i + 1], arg), i += 1) : args[i + 1] && /^(true|false)$/.test(args[i + 1]) ? (setArg(key, args[i + 1] === "true", arg), i += 1) : setArg(key, flags.strings[key] ? "" : !0, arg));
        } else if ((!flags.unknownFn || flags.unknownFn(arg) !== !1) && argv2._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg)), opts.stopEarly) {
          argv2._.push.apply(argv2._, args.slice(i + 1));
          break;
        }
      }
      return Object.keys(defaults3).forEach(function(k) {
        hasKey(argv2, k.split(".")) || (setKey(argv2, k.split("."), defaults3[k]), (aliases[k] || []).forEach(function(x) {
          setKey(argv2, x.split("."), defaults3[k]);
        }));
      }), opts["--"] ? argv2["--"] = notFlags.slice() : notFlags.forEach(function(k) {
        argv2._.push(k);
      }), argv2;
    };
  }
});

// ../../node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "../../node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias"), DOC = Symbol.for("yaml.document"), MAP = Symbol.for("yaml.map"), PAIR = Symbol.for("yaml.pair"), SCALAR = Symbol.for("yaml.scalar"), SEQ = Symbol.for("yaml.seq"), NODE_TYPE = Symbol.for("yaml.node.type"), isAlias = function(node) {
      return !!node && typeof node == "object" && node[NODE_TYPE] === ALIAS;
    }, isDocument = function(node) {
      return !!node && typeof node == "object" && node[NODE_TYPE] === DOC;
    }, isMap = function(node) {
      return !!node && typeof node == "object" && node[NODE_TYPE] === MAP;
    }, isPair = function(node) {
      return !!node && typeof node == "object" && node[NODE_TYPE] === PAIR;
    }, isScalar = function(node) {
      return !!node && typeof node == "object" && node[NODE_TYPE] === SCALAR;
    }, isSeq = function(node) {
      return !!node && typeof node == "object" && node[NODE_TYPE] === SEQ;
    };
    function isCollection(node) {
      if (node && typeof node == "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return !0;
        }
      return !1;
    }
    function isNode(node) {
      if (node && typeof node == "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return !0;
        }
      return !1;
    }
    var hasAnchor = function(node) {
      return (isScalar(node) || isCollection(node)) && !!node.anchor;
    };
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap;
    exports2.isNode = isNode;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar;
    exports2.isSeq = isSeq;
  }
});

// ../../node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../../node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var identity = require_identity(), BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      var visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        var cd2 = visit_(null, node.contents, visitor_, Object.freeze([
          node
        ]));
        cd2 === REMOVE && (node.contents = null);
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path6) {
      var ctrl = callVisitor(key, node, visitor, path6);
      if (identity.isNode(ctrl) || identity.isPair(ctrl))
        return replaceNode(key, path6, ctrl), visit_(key, ctrl, visitor, path6);
      if ((typeof ctrl > "u" ? "undefined" : _type_of12(ctrl)) !== "symbol") {
        if (identity.isCollection(node)) {
          path6 = Object.freeze(path6.concat(node));
          for (var i = 0; i < node.items.length; ++i) {
            var ci = visit_(i, node.items[i], visitor, path6);
            if (typeof ci == "number")
              i = ci - 1;
            else {
              if (ci === BREAK)
                return BREAK;
              ci === REMOVE && (node.items.splice(i, 1), i -= 1);
            }
          }
        } else if (identity.isPair(node)) {
          path6 = Object.freeze(path6.concat(node));
          var ck = visit_("key", node.key, visitor, path6);
          if (ck === BREAK)
            return BREAK;
          ck === REMOVE && (node.key = null);
          var cv = visit_("value", node.value, visitor, path6);
          if (cv === BREAK)
            return BREAK;
          cv === REMOVE && (node.value = null);
        }
      }
      return ctrl;
    }
    function visitAsync(node, visitor) {
      return _visitAsync.apply(this, arguments);
    }
    function _visitAsync() {
      return _visitAsync = /**
      * Apply an async visitor to an AST node or document.
      *
      * Walks through the tree (depth-first) starting from `node`, calling a
      * `visitor` function with three arguments:
      *   - `key`: For sequence values and map `Pair`, the node's index in the
      *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
      *     `null` for the root node.
      *   - `node`: The current node.
      *   - `path`: The ancestry of the current node.
      *
      * The return value of the visitor may be used to control the traversal:
      *   - `Promise`: Must resolve to one of the following values
      *   - `undefined` (default): Do nothing and continue
      *   - `visit.SKIP`: Do not visit the children of this node, continue with next
      *     sibling
      *   - `visit.BREAK`: Terminate traversal completely
      *   - `visit.REMOVE`: Remove the current node, then continue with the next one
      *   - `Node`: Replace the current node, then continue by visiting it
      *   - `number`: While iterating the items of a sequence or map, set the index
      *     of the next step. This is useful especially if the index of the current
      *     node has changed.
      *
      * If `visitor` is a single function, it will be called with all values
      * encountered in the tree, including e.g. `null` values. Alternatively,
      * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
      * `Alias` and `Scalar` node. To define the same visitor function for more than
      * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
      * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
      * specific defined one will be used for each node.
      */
      _async_to_generator31(function(node, visitor) {
        var visitor_, cd2;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return visitor_ = initVisitor(visitor), identity.isDocument(node) ? [
                4,
                visitAsync_(null, node.contents, visitor_, Object.freeze([
                  node
                ]))
              ] : [
                3,
                2
              ];
            case 1:
              return cd2 = _state.sent(), cd2 === REMOVE && (node.contents = null), [
                3,
                4
              ];
            case 2:
              return [
                4,
                visitAsync_(null, node, visitor_, Object.freeze([]))
              ];
            case 3:
              _state.sent(), _state.label = 4;
            case 4:
              return [
                2
              ];
          }
        });
      }), _visitAsync.apply(this, arguments);
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    function visitAsync_(key, node, visitor, path6) {
      return _visitAsync_.apply(this, arguments);
    }
    function _visitAsync_() {
      return _visitAsync_ = _async_to_generator31(function(key, node, visitor, path6) {
        var ctrl, i, ci, ck, cv;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                callVisitor(key, node, visitor, path6)
              ];
            case 1:
              if (ctrl = _state.sent(), identity.isNode(ctrl) || identity.isPair(ctrl))
                return replaceNode(key, path6, ctrl), [
                  2,
                  visitAsync_(key, ctrl, visitor, path6)
                ];
              if ((typeof ctrl > "u" ? "undefined" : _type_of12(ctrl)) === "symbol")
                return [
                  3,
                  9
                ];
              if (!identity.isCollection(node))
                return [
                  3,
                  6
                ];
              path6 = Object.freeze(path6.concat(node)), i = 0, _state.label = 2;
            case 2:
              return i < node.items.length ? [
                4,
                visitAsync_(i, node.items[i], visitor, path6)
              ] : [
                3,
                5
              ];
            case 3:
              if (ci = _state.sent(), typeof ci == "number")
                i = ci - 1;
              else {
                if (ci === BREAK)
                  return [
                    2,
                    BREAK
                  ];
                ci === REMOVE && (node.items.splice(i, 1), i -= 1);
              }
              _state.label = 4;
            case 4:
              return ++i, [
                3,
                2
              ];
            case 5:
              return [
                3,
                9
              ];
            case 6:
              return identity.isPair(node) ? (path6 = Object.freeze(path6.concat(node)), [
                4,
                visitAsync_("key", node.key, visitor, path6)
              ]) : [
                3,
                9
              ];
            case 7:
              return ck = _state.sent(), ck === BREAK ? [
                2,
                BREAK
              ] : (ck === REMOVE && (node.key = null), [
                4,
                visitAsync_("value", node.value, visitor, path6)
              ]);
            case 8:
              if (cv = _state.sent(), cv === BREAK)
                return [
                  2,
                  BREAK
                ];
              cv === REMOVE && (node.value = null), _state.label = 9;
            case 9:
              return [
                2,
                ctrl
              ];
          }
        });
      }), _visitAsync_.apply(this, arguments);
    }
    function initVisitor(visitor) {
      return typeof visitor == "object" && (visitor.Collection || visitor.Node || visitor.Value) ? Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor) : visitor;
    }
    function callVisitor(key, node, visitor, path6) {
      var _visitor_Map, _visitor_Seq, _visitor_Pair, _visitor_Scalar, _visitor_Alias;
      if (typeof visitor == "function")
        return visitor(key, node, path6);
      if (identity.isMap(node))
        return (_visitor_Map = visitor.Map) === null || _visitor_Map === void 0 ? void 0 : _visitor_Map.call(visitor, key, node, path6);
      if (identity.isSeq(node))
        return (_visitor_Seq = visitor.Seq) === null || _visitor_Seq === void 0 ? void 0 : _visitor_Seq.call(visitor, key, node, path6);
      if (identity.isPair(node))
        return (_visitor_Pair = visitor.Pair) === null || _visitor_Pair === void 0 ? void 0 : _visitor_Pair.call(visitor, key, node, path6);
      if (identity.isScalar(node))
        return (_visitor_Scalar = visitor.Scalar) === null || _visitor_Scalar === void 0 ? void 0 : _visitor_Scalar.call(visitor, key, node, path6);
      if (identity.isAlias(node))
        return (_visitor_Alias = visitor.Alias) === null || _visitor_Alias === void 0 ? void 0 : _visitor_Alias.call(visitor, key, node, path6);
    }
    function replaceNode(key, path6, node) {
      var parent = path6[path6.length - 1];
      if (identity.isCollection(parent))
        parent.items[key] = node;
      else if (identity.isPair(parent))
        key === "key" ? parent.key = node : parent.value = node;
      else if (identity.isDocument(parent))
        parent.contents = node;
      else {
        var pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error("Cannot replace node with ".concat(pt, " parent"));
      }
    }
    exports2.visit = visit;
    exports2.visitAsync = visitAsync;
  }
});

// ../../node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../../node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var identity = require_identity(), visit = require_visit(), escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }, escapeTagName = function(tn) {
      return tn.replace(/[!,[\]{}]/g, function(ch) {
        return escapeChars[ch];
      });
    }, Directives = /* @__PURE__ */ function() {
      function Directives2(yaml, tags) {
        _class_call_check15(this, Directives2), this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Directives2.defaultYaml, yaml), this.tags = Object.assign({}, Directives2.defaultTags, tags);
      }
      return _create_class13(Directives2, [
        {
          key: "clone",
          value: function() {
            var copy2 = new Directives2(this.yaml, this.tags);
            return copy2.docStart = this.docStart, copy2;
          }
        },
        {
          /**
          * During parsing, get a Directives instance for the current document and
          * update the stream state according to the current version's spec.
          */
          key: "atDocument",
          value: function() {
            var res = new Directives2(this.yaml, this.tags);
            switch (this.yaml.version) {
              case "1.1":
                this.atNextDocument = !0;
                break;
              case "1.2":
                this.atNextDocument = !1, this.yaml = {
                  explicit: Directives2.defaultYaml.explicit,
                  version: "1.2"
                }, this.tags = Object.assign({}, Directives2.defaultTags);
                break;
            }
            return res;
          }
        },
        {
          /**
          * @param onError - May be called even if the action was successful
          * @returns `true` on success
          */
          key: "add",
          value: function(line, onError) {
            this.atNextDocument && (this.yaml = {
              explicit: Directives2.defaultYaml.explicit,
              version: "1.1"
            }, this.tags = Object.assign({}, Directives2.defaultTags), this.atNextDocument = !1);
            var parts = line.trim().split(/[ \t]+/), name = parts.shift();
            switch (name) {
              case "%TAG": {
                if (parts.length !== 2 && (onError(0, "%TAG directive should contain exactly two parts"), parts.length < 2))
                  return !1;
                var _parts2 = _sliced_to_array15(parts, 2), handle = _parts2[0], prefix = _parts2[1];
                return this.tags[handle] = prefix, !0;
              }
              case "%YAML": {
                if (this.yaml.explicit = !0, parts.length !== 1)
                  return onError(0, "%YAML directive should contain exactly one part"), !1;
                var _parts1 = _sliced_to_array15(parts, 1), version2 = _parts1[0];
                if (version2 === "1.1" || version2 === "1.2")
                  return this.yaml.version = version2, !0;
                var isValid = /^\d+\.\d+$/.test(version2);
                return onError(6, "Unsupported YAML version ".concat(version2), isValid), !1;
              }
              default:
                return onError(0, "Unknown directive ".concat(name), !0), !1;
            }
          }
        },
        {
          /**
          * Resolves a tag, matching handles to those defined in %TAG directives.
          *
          * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
          *   `'!local'` tag, or `null` if unresolvable.
          */
          key: "tagName",
          value: function(source, onError) {
            if (source === "!")
              return "!";
            if (source[0] !== "!")
              return onError("Not a valid tag: ".concat(source)), null;
            if (source[1] === "<") {
              var verbatim = source.slice(2, -1);
              return verbatim === "!" || verbatim === "!!" ? (onError("Verbatim tags aren't resolved, so ".concat(source, " is invalid.")), null) : (source[source.length - 1] !== ">" && onError("Verbatim tags must end with a >"), verbatim);
            }
            var _source_match = _sliced_to_array15(source.match(RegExp("^(.*!)([^!]*)$", "s")), 3), handle = _source_match[1], suffix = _source_match[2];
            suffix || onError("The ".concat(source, " tag has no suffix"));
            var prefix = this.tags[handle];
            if (prefix)
              try {
                return prefix + decodeURIComponent(suffix);
              } catch (error) {
                return onError(String(error)), null;
              }
            return handle === "!" ? source : (onError("Could not resolve tag: ".concat(source)), null);
          }
        },
        {
          /**
          * Given a fully resolved tag, returns its printable string form,
          * taking into account current tag prefixes and defaults.
          */
          key: "tagString",
          value: function(tag) {
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = Object.entries(this.tags)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var _step_value = _sliced_to_array15(_step.value, 2), handle = _step_value[0], prefix = _step_value[1];
                if (tag.startsWith(prefix))
                  return handle + escapeTagName(tag.substring(prefix.length));
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return tag[0] === "!" ? tag : "!<".concat(tag, ">");
          }
        },
        {
          key: "toString",
          value: function(doc) {
            var lines = this.yaml.explicit ? [
              "%YAML ".concat(this.yaml.version || "1.2")
            ] : [], tagEntries = Object.entries(this.tags), tagNames;
            if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
              var tags = {};
              visit.visit(doc.contents, function(_key, node) {
                identity.isNode(node) && node.tag && (tags[node.tag] = !0);
              }), tagNames = Object.keys(tags);
            } else
              tagNames = [];
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _loop = function() {
                var _step_value = _sliced_to_array15(_step.value, 2), handle = _step_value[0], prefix = _step_value[1];
                if (handle === "!!" && prefix === "tag:yaml.org,2002:")
                  return "continue";
                (!doc || tagNames.some(function(tn) {
                  return tn.startsWith(prefix);
                })) && lines.push("%TAG ".concat(handle, " ").concat(prefix));
              }, _iterator = tagEntries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0)
                _loop();
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return lines.join(`
`);
          }
        }
      ]), Directives2;
    }();
    Directives.defaultYaml = {
      explicit: !1,
      version: "1.2"
    };
    Directives.defaultTags = {
      "!!": "tag:yaml.org,2002:"
    };
    exports2.Directives = Directives;
  }
});

// ../../node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../../node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity(), visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        var sa = JSON.stringify(anchor), msg = "Anchor must not contain whitespace or control characters: ".concat(sa);
        throw new Error(msg);
      }
      return !0;
    }
    function anchorNames(root) {
      var anchors = /* @__PURE__ */ new Set();
      return visit.visit(root, {
        Value: function(_key, node) {
          node.anchor && anchors.add(node.anchor);
        }
      }), anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (var i = 1; ; ++i) {
        var name = "".concat(prefix).concat(i);
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      var aliasObjects = [], sourceObjects = /* @__PURE__ */ new Map(), prevAnchors = null;
      return {
        onAnchor: function(source) {
          aliasObjects.push(source), prevAnchors || (prevAnchors = anchorNames(doc));
          var anchor = findNewAnchor(prefix, prevAnchors);
          return prevAnchors.add(anchor), anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: function() {
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = aliasObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var source = _step.value, ref = sourceObjects.get(source);
              if (typeof ref == "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node)))
                ref.node.anchor = ref.anchor;
              else {
                var error = new Error("Failed to resolve repeated object (this should not happen)");
                throw error.source = source, error;
              }
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// ../../node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../../node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val == "object")
        if (Array.isArray(val))
          for (var i = 0, len = val.length; i < len; ++i) {
            var v0 = val[i], v1 = applyReviver(reviver, val, String(i), v0);
            v1 === void 0 ? delete val[i] : v1 !== v0 && (val[i] = v1);
          }
        else if (_instanceof13(val, Map)) {
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = Array.from(val.keys())[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var k = _step.value, v01 = val.get(k), v11 = applyReviver(reviver, val, k, v01);
              v11 === void 0 ? val.delete(k) : v11 !== v01 && val.set(k, v11);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        } else if (_instanceof13(val, Set)) {
          var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = Array.from(val)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var v02 = _step1.value, v12 = applyReviver(reviver, val, v02, v02);
              v12 === void 0 ? val.delete(v02) : v12 !== v02 && (val.delete(v02), val.add(v12));
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        } else {
          var _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
          try {
            for (var _iterator2 = Object.entries(val)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
              var _step_value = _sliced_to_array15(_step2.value, 2), k1 = _step_value[0], v03 = _step_value[1], v13 = applyReviver(reviver, val, k1, v03);
              v13 === void 0 ? delete val[k1] : v13 !== v03 && (val[k1] = v13);
            }
          } catch (err) {
            _didIteratorError22 = !0, _iteratorError22 = err;
          } finally {
            try {
              !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
            } finally {
              if (_didIteratorError22)
                throw _iteratorError22;
            }
          }
        }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// ../../node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../../node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map(function(v, i) {
          return toJS(v, String(i), ctx);
        });
      if (value && typeof value.toJSON == "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        var data = {
          aliasCount: 0,
          count: 1,
          res: void 0
        };
        ctx.anchors.set(value, data), ctx.onCreate = function(res2) {
          data.res = res2, delete ctx.onCreate;
        };
        var res = value.toJSON(arg, ctx);
        return ctx.onCreate && ctx.onCreate(res), res;
      }
      return (typeof value > "u" ? "undefined" : _type_of12(value)) === "bigint" && !(ctx != null && ctx.keep) ? Number(value) : value;
    }
    exports2.toJS = toJS;
  }
});

// ../../node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../../node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    var applyReviver = require_applyReviver(), identity = require_identity(), toJS = require_toJS(), NodeBase = /* @__PURE__ */ function() {
      function NodeBase2(type) {
        _class_call_check15(this, NodeBase2), Object.defineProperty(this, identity.NODE_TYPE, {
          value: type
        });
      }
      return _create_class13(NodeBase2, [
        {
          /** Create a copy of this node.  */
          key: "clone",
          value: function() {
            var copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            return this.range && (copy2.range = this.range.slice()), copy2;
          }
        },
        {
          /** A plain JavaScript representation of this node. */
          key: "toJS",
          value: function(doc) {
            var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, mapAsMap = _ref.mapAsMap, maxAliasCount = _ref.maxAliasCount, onAnchor = _ref.onAnchor, reviver = _ref.reviver;
            if (!identity.isDocument(doc))
              throw new TypeError("A document argument is required");
            var ctx = {
              anchors: /* @__PURE__ */ new Map(),
              doc,
              keep: !0,
              mapAsMap: mapAsMap === !0,
              mapKeyWarned: !1,
              maxAliasCount: typeof maxAliasCount == "number" ? maxAliasCount : 100
            }, res = toJS.toJS(this, "", ctx), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            if (typeof onAnchor == "function")
              try {
                for (var _iterator = ctx.anchors.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var _step_value = _step.value, count = _step_value.count, res1 = _step_value.res;
                  onAnchor(res1, count);
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
            return typeof reviver == "function" ? applyReviver.applyReviver(reviver, {
              "": res
            }, "", res) : res;
          }
        }
      ]), NodeBase2;
    }();
    exports2.NodeBase = NodeBase;
  }
});

// ../../node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../../node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var anchors = require_anchors(), visit = require_visit(), identity = require_identity(), Node = require_Node(), toJS = require_toJS(), Alias = /* @__PURE__ */ function(_Node_NodeBase) {
      _inherits10(Alias2, _Node_NodeBase);
      var _super = _create_super10(Alias2);
      function Alias2(source) {
        _class_call_check15(this, Alias2);
        var _this;
        return _this = _super.call(this, identity.ALIAS), _this.source = source, Object.defineProperty(_assert_this_initialized10(_this), "tag", {
          set: function() {
            throw new Error("Alias nodes cannot have tags");
          }
        }), _this;
      }
      return _create_class13(Alias2, [
        {
          /**
          * Resolve the value of this alias within `doc`, finding the last
          * instance of the `source` anchor before this node.
          */
          key: "resolve",
          value: function(doc) {
            var _this = this, found = void 0;
            return visit.visit(doc, {
              Node: function(_key, node) {
                if (node === _this)
                  return visit.visit.BREAK;
                node.anchor === _this.source && (found = node);
              }
            }), found;
          }
        },
        {
          key: "toJSON",
          value: function(_arg, ctx) {
            if (!ctx)
              return {
                source: this.source
              };
            var anchors2 = ctx.anchors, doc = ctx.doc, maxAliasCount = ctx.maxAliasCount, source = this.resolve(doc);
            if (!source) {
              var msg = "Unresolved alias (the anchor must be set before the alias): ".concat(this.source);
              throw new ReferenceError(msg);
            }
            var data = anchors2.get(source);
            if (data || (toJS.toJS(source, null, ctx), data = anchors2.get(source)), !data || data.res === void 0) {
              var msg1 = "This should not happen: Alias anchor was not resolved?";
              throw new ReferenceError(msg1);
            }
            if (maxAliasCount >= 0 && (data.count += 1, data.aliasCount === 0 && (data.aliasCount = getAliasCount(doc, source, anchors2)), data.count * data.aliasCount > maxAliasCount)) {
              var msg2 = "Excessive alias count indicates a resource exhaustion attack";
              throw new ReferenceError(msg2);
            }
            return data.res;
          }
        },
        {
          key: "toString",
          value: function(ctx, _onComment, _onChompKeep) {
            var src = "*".concat(this.source);
            if (ctx) {
              if (anchors.anchorIsValid(this.source), ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                var msg = "Unresolved alias (the anchor must be set before the alias): ".concat(this.source);
                throw new Error(msg);
              }
              if (ctx.implicitKey)
                return "".concat(src, " ");
            }
            return src;
          }
        }
      ]), Alias2;
    }(Node.NodeBase);
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        var source = node.resolve(doc), anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        var count = 0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = node.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var item = _step.value, c = getAliasCount(doc, item, anchors2);
            c > count && (count = c);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return count;
      } else if (identity.isPair(node)) {
        var kc = getAliasCount(doc, node.key, anchors2), vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// ../../node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../../node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var identity = require_identity(), Node = require_Node(), toJS = require_toJS(), isScalarValue = function(value) {
      return !value || typeof value != "function" && typeof value != "object";
    }, Scalar = /* @__PURE__ */ function(_Node_NodeBase) {
      _inherits10(Scalar2, _Node_NodeBase);
      var _super = _create_super10(Scalar2);
      function Scalar2(value) {
        _class_call_check15(this, Scalar2);
        var _this;
        return _this = _super.call(this, identity.SCALAR), _this.value = value, _this;
      }
      return _create_class13(Scalar2, [
        {
          key: "toJSON",
          value: function(arg, ctx) {
            return ctx != null && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
          }
        },
        {
          key: "toString",
          value: function() {
            return String(this.value);
          }
        }
      ]), Scalar2;
    }(Node.NodeBase);
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// ../../node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../../node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var Alias = require_Alias(), identity = require_identity(), Scalar = require_Scalar(), defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        var match2 = tags.filter(function(t) {
          return t.tag === tagName;
        }), _match_find, tagObj = (_match_find = match2.find(function(t) {
          return !t.format;
        })) !== null && _match_find !== void 0 ? _match_find : match2[0];
        if (!tagObj)
          throw new Error("Tag ".concat(tagName, " not found"));
        return tagObj;
      }
      return tags.find(function(t) {
        var _t_identify;
        return ((_t_identify = t.identify) === null || _t_identify === void 0 ? void 0 : _t_identify.call(t, value)) && !t.format;
      });
    }
    function createNode(value, tagName, ctx) {
      var _tagObj_nodeClass;
      if (identity.isDocument(value) && (value = value.contents), identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        var _ctx_schema_identity_MAP_createNode, _ctx_schema_identity_MAP, map = (_ctx_schema_identity_MAP_createNode = (_ctx_schema_identity_MAP = ctx.schema[identity.MAP]).createNode) === null || _ctx_schema_identity_MAP_createNode === void 0 ? void 0 : _ctx_schema_identity_MAP_createNode.call(_ctx_schema_identity_MAP, ctx.schema, null, ctx);
        return map.items.push(value), map;
      }
      (_instanceof13(value, String) || _instanceof13(value, Number) || _instanceof13(value, Boolean) || typeof BigInt < "u" && _instanceof13(value, BigInt)) && (value = value.valueOf());
      var aliasDuplicateObjects = ctx.aliasDuplicateObjects, onAnchor = ctx.onAnchor, onTagObj = ctx.onTagObj, schema = ctx.schema, sourceObjects = ctx.sourceObjects, ref = void 0;
      if (aliasDuplicateObjects && value && typeof value == "object") {
        if (ref = sourceObjects.get(value), ref)
          return ref.anchor || (ref.anchor = onAnchor(value)), new Alias.Alias(ref.anchor);
        ref = {
          anchor: null,
          node: null
        }, sourceObjects.set(value, ref);
      }
      tagName != null && tagName.startsWith("!!") && (tagName = defaultTagPrefix + tagName.slice(2));
      var tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON == "function" && (value = value.toJSON()), !value || typeof value != "object") {
          var node = new Scalar.Scalar(value);
          return ref && (ref.node = node), node;
        }
        tagObj = _instanceof13(value, Map) ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      onTagObj && (onTagObj(tagObj), delete ctx.onTagObj);
      var node1 = tagObj != null && tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof (tagObj == null || (_tagObj_nodeClass = tagObj.nodeClass) === null || _tagObj_nodeClass === void 0 ? void 0 : _tagObj_nodeClass.from) == "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      return tagName ? node1.tag = tagName : tagObj.default || (node1.tag = tagObj.tag), ref && (ref.node = node1), node1;
    }
    exports2.createNode = createNode;
  }
});

// ../../node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../../node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _to_array2(arr) {
      return _array_with_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_rest16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var createNode = require_createNode(), identity = require_identity(), Node = require_Node();
    function collectionFromPath(schema, path6, value) {
      for (var v = value, i = path6.length - 1; i >= 0; --i) {
        var k = path6[i];
        if (typeof k == "number" && Number.isInteger(k) && k >= 0) {
          var a = [];
          a[k] = v, v = a;
        } else
          v = /* @__PURE__ */ new Map([
            [
              k,
              v
            ]
          ]);
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: !1,
        keepUndefined: !1,
        onAnchor: function() {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = function(path6) {
      return path6 == null || typeof path6 == "object" && !!path6[Symbol.iterator]().next().done;
    }, Collection = /* @__PURE__ */ function(_Node_NodeBase) {
      _inherits10(Collection2, _Node_NodeBase);
      var _super = _create_super10(Collection2);
      function Collection2(type, schema) {
        _class_call_check15(this, Collection2);
        var _this;
        return _this = _super.call(this, type), Object.defineProperty(_assert_this_initialized10(_this), "schema", {
          value: schema,
          configurable: !0,
          enumerable: !1,
          writable: !0
        }), _this;
      }
      return _create_class13(Collection2, [
        {
          /**
          * Create a copy of this collection.
          *
          * @param schema - If defined, overwrites the original's schema
          */
          key: "clone",
          value: function(schema) {
            var copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            return schema && (copy2.schema = schema), copy2.items = copy2.items.map(function(it) {
              return identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it;
            }), this.range && (copy2.range = this.range.slice()), copy2;
          }
        },
        {
          /**
          * Adds a value to the collection. For `!!map` and `!!omap` the value must
          * be a Pair instance or a `{ key, value }` object, which may not have a key
          * that already exists in the map.
          */
          key: "addIn",
          value: function(path6, value) {
            if (isEmptyPath(path6))
              this.add(value);
            else {
              var _path = _to_array2(path6), key = _path[0], rest = _path.slice(1), node = this.get(key, !0);
              if (identity.isCollection(node))
                node.addIn(rest, value);
              else if (node === void 0 && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
              else
                throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
            }
          }
        },
        {
          /**
          * Removes a value from the collection.
          * @returns `true` if the item was found and removed.
          */
          key: "deleteIn",
          value: function(path6) {
            var _path = _to_array2(path6), key = _path[0], rest = _path.slice(1);
            if (rest.length === 0)
              return this.delete(key);
            var node = this.get(key, !0);
            if (identity.isCollection(node))
              return node.deleteIn(rest);
            throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
          }
        },
        {
          /**
          * Returns item at `key`, or `undefined` if not found. By default unwraps
          * scalar values from their surrounding node; to disable set `keepScalar` to
          * `true` (collections are always returned intact).
          */
          key: "getIn",
          value: function(path6, keepScalar) {
            var _path = _to_array2(path6), key = _path[0], rest = _path.slice(1), node = this.get(key, !0);
            return rest.length === 0 ? !keepScalar && identity.isScalar(node) ? node.value : node : identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
          }
        },
        {
          key: "hasAllNullValues",
          value: function(allowScalar) {
            return this.items.every(function(node) {
              if (!identity.isPair(node))
                return !1;
              var n = node.value;
              return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
            });
          }
        },
        {
          /**
          * Checks if the collection includes a value with the key `key`.
          */
          key: "hasIn",
          value: function(path6) {
            var _path = _to_array2(path6), key = _path[0], rest = _path.slice(1);
            if (rest.length === 0)
              return this.has(key);
            var node = this.get(key, !0);
            return identity.isCollection(node) ? node.hasIn(rest) : !1;
          }
        },
        {
          /**
          * Sets a value in this collection. For `!!set`, `value` needs to be a
          * boolean to add/remove the item from the set.
          */
          key: "setIn",
          value: function(path6, value) {
            var _path = _to_array2(path6), key = _path[0], rest = _path.slice(1);
            if (rest.length === 0)
              this.set(key, value);
            else {
              var node = this.get(key, !0);
              if (identity.isCollection(node))
                node.setIn(rest, value);
              else if (node === void 0 && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
              else
                throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
            }
          }
        }
      ]), Collection2;
    }(Node.NodeBase);
    Collection.maxFlowStringSingleLineLength = 60;
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = function(str) {
      return str.replace(/^(?!$)(?: $)?/gm, "#");
    };
    function indentComment(comment, indent) {
      return /^\n+$/.test(comment) ? comment.substring(1) : indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = function(str, indent, comment) {
      return str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    };
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// ../../node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../../node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow", FOLD_BLOCK = "block", FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent) {
      var mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "flow", _ref = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, indentAtStart = _ref.indentAtStart, _ref_lineWidth = _ref.lineWidth, lineWidth = _ref_lineWidth === void 0 ? 80 : _ref_lineWidth, _ref_minContentWidth = _ref.minContentWidth, minContentWidth = _ref_minContentWidth === void 0 ? 20 : _ref_minContentWidth, onFold = _ref.onFold, onOverflow = _ref.onOverflow;
      if (!lineWidth || lineWidth < 0)
        return text;
      var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      var folds = [], escapedFolds = {}, end = lineWidth - indent.length;
      typeof indentAtStart == "number" && (indentAtStart > lineWidth - Math.max(2, minContentWidth) ? folds.push(0) : end = lineWidth - indentAtStart);
      var split = void 0, prev = void 0, overflow = !1, i = -1, escStart = -1, escEnd = -1;
      mode === FOLD_BLOCK && (i = consumeMoreIndentedLines(text, i), i !== -1 && (end = i + endStep));
      for (var ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          switch (escStart = i, text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === `
`)
          mode === FOLD_BLOCK && (i = consumeMoreIndentedLines(text, i)), end = i + endStep, split = void 0;
        else {
          if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "	") {
            var next = text[i + 1];
            next && next !== " " && next !== `
` && next !== "	" && (split = i);
          }
          if (i >= end)
            if (split)
              folds.push(split), end = split + endStep, split = void 0;
            else if (mode === FOLD_QUOTED) {
              for (; prev === " " || prev === "	"; )
                prev = ch, ch = text[i += 1], overflow = !0;
              var j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j), escapedFolds[j] = !0, end = j + endStep, split = void 0;
            } else
              overflow = !0;
        }
        prev = ch;
      }
      if (overflow && onOverflow && onOverflow(), folds.length === 0)
        return text;
      onFold && onFold();
      for (var res = text.slice(0, folds[0]), i1 = 0; i1 < folds.length; ++i1) {
        var fold = folds[i1], end1 = folds[i1 + 1] || text.length;
        fold === 0 ? res = `
`.concat(indent).concat(text.slice(0, end1)) : (mode === FOLD_QUOTED && escapedFolds[fold] && (res += "".concat(text[fold], "\\")), res += `
`.concat(indent).concat(text.slice(fold + 1, end1)));
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i) {
      for (var ch = text[i + 1]; ch === " " || ch === "	"; ) {
        do
          ch = text[i += 1];
        while (ch && ch !== `
`);
        ch = text[i + 1];
      }
      return i;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), foldFlowLines = require_foldFlowLines(), getFoldOptions = function(ctx, isBlock) {
      return {
        indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
        lineWidth: ctx.options.lineWidth,
        minContentWidth: ctx.options.minContentWidth
      };
    }, containsDocumentMarker = function(str) {
      return /^(%|---|\.\.\.)/m.test(str);
    };
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return !1;
      var limit = lineWidth - indentLength, strLen = str.length;
      if (strLen <= limit)
        return !1;
      for (var i = 0, start = 0; i < strLen; ++i)
        if (str[i] === `
`) {
          if (i - start > limit)
            return !0;
          if (start = i + 1, strLen - start <= limit)
            return !1;
        }
      return !0;
    }
    function doubleQuotedString(value, ctx) {
      var json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      for (var implicitKey = ctx.implicitKey, minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength, indent = ctx.indent || (containsDocumentMarker(value) ? "  " : ""), str = "", start = 0, i = 0, ch = json[i]; ch; ch = json[++i])
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n" && (str += json.slice(start, i) + "\\ ", i += 1, start = i, ch = "\\"), ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                var code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    code.substr(0, 2) === "00" ? str += "\\x" + code.substr(2) : str += json.substr(i, 6);
                }
                i += 5, start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength)
                i += 1;
              else {
                for (str += json.slice(start, i) + `

`; json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"'; )
                  str += `
`, i += 2;
                str += indent, json[i + 2] === " " && (str += "\\"), i += 1, start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      return str = start ? str + json.slice(start) : json, implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, !1));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === !1 || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      var indent = ctx.indent || (containsDocumentMarker(value) ? "  " : ""), res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
`.concat(indent)) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
    }
    function quotedString(value, ctx) {
      var singleQuote = ctx.options.singleQuote, qs;
      if (singleQuote === !1)
        qs = doubleQuotedString;
      else {
        var hasDouble = value.includes('"'), hasSingle = value.includes("'");
        hasDouble && !hasSingle ? qs = singleQuotedString : hasSingle && !hasDouble ? qs = doubleQuotedString : qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString(param, ctx, onComment, onChompKeep) {
      var comment = param.comment, type = param.type, value = param.value, _ctx_options = ctx.options, blockQuote = _ctx_options.blockQuote, commentString = _ctx_options.commentString, lineWidth = _ctx_options.lineWidth;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value))
        return quotedString(value, ctx);
      var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : ""), literal = blockQuote === "literal" ? !0 : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? !1 : type === Scalar.Scalar.BLOCK_LITERAL ? !0 : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal ? `|
` : `>
`;
      var chomp, endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        var ch = value[endStart - 1];
        if (ch !== `
` && ch !== "	" && ch !== " ")
          break;
      }
      var end = value.substring(endStart), endNlPos = end.indexOf(`
`);
      endNlPos === -1 ? chomp = "-" : value === end || endNlPos !== end.length - 1 ? (chomp = "+", onChompKeep && onChompKeep()) : chomp = "", end && (value = value.slice(0, -end.length), end[end.length - 1] === `
` && (end = end.slice(0, -1)), end = end.replace(blockEndNewlines, "$&".concat(indent)));
      var startWithSpace = !1, startEnd, startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        var ch1 = value[startEnd];
        if (ch1 === " ")
          startWithSpace = !0;
        else if (ch1 === `
`)
          startNlPos = startEnd;
        else
          break;
      }
      var start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      start && (value = value.substring(start.length), start = start.replace(/\n+/g, "$&".concat(indent)));
      var indentSize = indent ? "2" : "1", header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
      if (comment && (header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " ")), onComment && onComment()), literal)
        return value = value.replace(/\n+/g, "$&".concat(indent)), "".concat(header, `
`).concat(indent).concat(start).concat(value).concat(end);
      value = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(indent));
      var body = foldFlowLines.foldFlowLines("".concat(start).concat(value).concat(end), indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, !0));
      return "".concat(header, `
`).concat(indent).concat(body);
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      var type = item.type, value = item.value, actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, indentStep = ctx.indentStep, inFlow = ctx.inFlow;
      if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value))
        return quotedString(value, ctx);
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value))
        return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`))
        return blockString(item, ctx, onComment, onChompKeep);
      if (containsDocumentMarker(value)) {
        if (indent === "")
          return ctx.forceBlockIndent = !0, blockString(item, ctx, onComment, onChompKeep);
        if (implicitKey && indent === indentStep)
          return quotedString(value, ctx);
      }
      var str = value.replace(/\n+/g, `$&
`.concat(indent));
      if (actualString) {
        var test = function(tag) {
          var _tag_test;
          return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_tag_test = tag.test) === null || _tag_test === void 0 ? void 0 : _tag_test.test(str));
        }, _ctx_doc_schema = ctx.doc.schema, compat = _ctx_doc_schema.compat, tags = _ctx_doc_schema.tags;
        if (tags.some(test) || compat != null && compat.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow, ss = typeof item.value == "string" ? item : Object.assign({}, item, {
        value: String(item.value)
      }), type = item.type;
      type !== Scalar.Scalar.QUOTE_DOUBLE && RegExp("[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\uD800-\uDFFF]", "u").test(ss.value) && (type = Scalar.Scalar.QUOTE_DOUBLE);
      var _stringify = function(_type2) {
        switch (_type2) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : (
              // blocks are not valid inside flow containers
              blockString(ss, ctx, onComment, onChompKeep)
            );
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      }, res = _stringify(type);
      if (res === null) {
        var _ctx_options = ctx.options, defaultKeyType = _ctx_options.defaultKeyType, defaultStringType = _ctx_options.defaultStringType, t = implicitKey && defaultKeyType || defaultStringType;
        if (res = _stringify(t), res === null)
          throw new Error("Unsupported default string type ".concat(t));
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// ../../node_modules/yaml/dist/stringify/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    var anchors = require_anchors(), identity = require_identity(), stringifyComment = require_stringifyComment(), stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      var opt = Object.assign({
        blockQuote: !0,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: !1,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: !0,
        indentSeq: !0,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: !1,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: !0
      }, doc.schema.toStringOptions, options), inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = !1;
          break;
        case "flow":
          inFlow = !0;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent == "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        var match2 = tags.filter(function(t) {
          return t.tag === item.tag;
        }), _match_find;
        if (match2.length > 0)
          return (_match_find = match2.find(function(t) {
            return t.format === item.format;
          })) !== null && _match_find !== void 0 ? _match_find : match2[0];
      }
      var tagObj = void 0, obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        var match1 = tags.filter(function(t) {
          var _t_identify;
          return (_t_identify = t.identify) === null || _t_identify === void 0 ? void 0 : _t_identify.call(t, obj);
        }), _match_find1;
        tagObj = (_match_find1 = match1.find(function(t) {
          return t.format === item.format;
        })) !== null && _match_find1 !== void 0 ? _match_find1 : match1.find(function(t) {
          return !t.format;
        });
      } else
        obj = item, tagObj = tags.find(function(t) {
          return t.nodeClass && _instanceof13(obj, t.nodeClass);
        });
      if (!tagObj) {
        var _obj_constructor, _obj_constructor_name, name = (_obj_constructor_name = obj == null || (_obj_constructor = obj.constructor) === null || _obj_constructor === void 0 ? void 0 : _obj_constructor.name) !== null && _obj_constructor_name !== void 0 ? _obj_constructor_name : typeof obj > "u" ? "undefined" : _type_of12(obj);
        throw new Error("Tag not resolved for ".concat(name, " value"));
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, param) {
      var anchors$1 = param.anchors, doc = param.doc;
      if (!doc.directives)
        return "";
      var props = [], anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      anchor && anchors.anchorIsValid(anchor) && (anchors$1.add(anchor), props.push("&".concat(anchor)));
      var tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      return tag && props.push(doc.directives.tagString(tag)), props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        var _ctx_resolvedAliases;
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (!((_ctx_resolvedAliases = ctx.resolvedAliases) === null || _ctx_resolvedAliases === void 0) && _ctx_resolvedAliases.has(item))
          throw new TypeError("Cannot stringify circular structure without alias nodes");
        ctx.resolvedAliases ? ctx.resolvedAliases.add(item) : ctx.resolvedAliases = /* @__PURE__ */ new Set([
          item
        ]), item = item.resolve(ctx.doc);
      }
      var tagObj = void 0, node = identity.isNode(item) ? item : ctx.doc.createNode(item, {
        onTagObj: function(o) {
          return tagObj = o;
        }
      });
      tagObj || (tagObj = getTagObject(ctx.doc.schema.tags, node));
      var props = stringifyProps(node, tagObj, ctx), _ctx_indentAtStart;
      props.length > 0 && (ctx.indentAtStart = ((_ctx_indentAtStart = ctx.indentAtStart) !== null && _ctx_indentAtStart !== void 0 ? _ctx_indentAtStart : 0) + props.length + 1);
      var str = typeof tagObj.stringify == "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      return props ? identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? "".concat(props, " ").concat(str) : "".concat(props, `
`).concat(ctx.indent).concat(str) : str;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity(), Scalar = require_Scalar(), stringify = require_stringify2(), stringifyComment = require_stringifyComment();
    function stringifyPair(param, ctx, onComment, onChompKeep) {
      var key = param.key, value = param.value, allNullValues = ctx.allNullValues, doc = ctx.doc, indent = ctx.indent, indentStep = ctx.indentStep, _ctx_options = ctx.options, commentString = _ctx_options.commentString, indentSeq = _ctx_options.indentSeq, simpleKeys = _ctx_options.simpleKeys, keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment)
          throw new Error("With simple keys, key nodes cannot have comments");
        if (identity.isCollection(key)) {
          var msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      var explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key == "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: !1,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      var keyCommentDone = !1, chompKeep = !1, str = stringify.stringify(key, ctx, function() {
        return keyCommentDone = !0;
      }, function() {
        return chompKeep = !0;
      });
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = !0;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null)
          return keyCommentDone && onComment && onComment(), str === "" ? "?" : explicitKey ? "? ".concat(str) : str;
      } else if (allNullValues && !simpleKeys || value == null && explicitKey)
        return str = "? ".concat(str), keyComment && !keyCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)) : chompKeep && onChompKeep && onChompKeep(), str;
      keyCommentDone && (keyComment = null), explicitKey ? (keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment))), str = "? ".concat(str, `
`).concat(indent, ":")) : (str = "".concat(str, ":"), keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment))));
      var vsb, vcb, valueComment;
      identity.isNode(value) ? (vsb = !!value.spaceBefore, vcb = value.commentBefore, valueComment = value.comment) : (vsb = !1, vcb = null, valueComment = null, value && typeof value == "object" && (value = doc.createNode(value))), ctx.implicitKey = !1, !explicitKey && !keyComment && identity.isScalar(value) && (ctx.indentAtStart = str.length + 1), chompKeep = !1, !indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor && (ctx.indent = ctx.indent.substring(2));
      var valueCommentDone = !1, valueStr = stringify.stringify(value, ctx, function() {
        return valueCommentDone = !0;
      }, function() {
        return chompKeep = !0;
      }), ws = " ";
      if (keyComment || vsb || vcb) {
        if (ws = vsb ? `
` : "", vcb) {
          var cs = commentString(vcb);
          ws += `
`.concat(stringifyComment.indentComment(cs, ctx.indent));
        }
        valueStr === "" && !ctx.inFlow ? ws === `
` && (ws = `

`) : ws += `
`.concat(ctx.indent);
      } else if (!explicitKey && identity.isCollection(value)) {
        var vs0 = valueStr[0], nl0 = valueStr.indexOf(`
`), hasNewline = nl0 !== -1, _ctx_inFlow, _ref, flow = (_ref = (_ctx_inFlow = ctx.inFlow) !== null && _ctx_inFlow !== void 0 ? _ctx_inFlow : value.flow) !== null && _ref !== void 0 ? _ref : value.items.length === 0;
        if (hasNewline || !flow) {
          var hasPropsLine = !1;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            var sp0 = valueStr.indexOf(" ");
            vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!" && (sp0 = valueStr.indexOf(" ", sp0 + 1)), (sp0 === -1 || nl0 < sp0) && (hasPropsLine = !0);
          }
          hasPropsLine || (ws = `
`.concat(ctx.indent));
        }
      } else
        (valueStr === "" || valueStr[0] === `
`) && (ws = "");
      return str += ws + valueStr, ctx.inFlow ? valueCommentDone && onComment && onComment() : valueComment && !valueCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment)) : chompKeep && onChompKeep && onChompKeep(), str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// ../../node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../../node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function debug(logLevel) {
      for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        messages[_key - 1] = arguments[_key];
      var _console;
      logLevel === "debug" && (_console = console).log.apply(_console, _to_consumable_array16(messages));
    }
    function warn(logLevel, warning) {
      (logLevel === "debug" || logLevel === "warn") && (typeof process < "u" && process.emitWarning ? process.emitWarning(warning) : console.warn(warning));
    }
    exports2.debug = debug;
    exports2.warn = warn;
  }
});

// ../../node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var log2 = require_log(), stringify = require_stringify2(), identity = require_identity(), Scalar = require_Scalar(), toJS = require_toJS(), MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map, param) {
      var key = param.key, value = param.value;
      if (ctx != null && ctx.doc.schema.merge && isMergeKey(key)) {
        value = identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        if (identity.isSeq(value))
          try {
            for (var _iterator = value.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var it = _step.value;
              mergeToJSMap(ctx, map, it);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        else if (Array.isArray(value))
          try {
            for (var _iterator1 = value[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var it1 = _step1.value;
              mergeToJSMap(ctx, map, it1);
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        else
          mergeToJSMap(ctx, map, value);
      } else {
        var jsKey = toJS.toJS(key, "", ctx);
        if (_instanceof13(map, Map))
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        else if (_instanceof13(map, Set))
          map.add(jsKey);
        else {
          var stringKey = stringifyKey(key, jsKey, ctx), jsValue = toJS.toJS(value, stringKey, ctx);
          stringKey in map ? Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: !0,
            enumerable: !0,
            configurable: !0
          }) : map[stringKey] = jsValue;
        }
      }
      return map;
    }
    var isMergeKey = function(key) {
      return key === MERGE_KEY || identity.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
    };
    function mergeToJSMap(ctx, map, value) {
      var source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      var srcMap = source.toJSON(null, ctx, Map), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = srcMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _step_value = _sliced_to_array15(_step.value, 2), key = _step_value[0], _$value = _step_value[1];
          _instanceof13(map, Map) ? map.has(key) || map.set(key, _$value) : _instanceof13(map, Set) ? map.add(key) : Object.prototype.hasOwnProperty.call(map, key) || Object.defineProperty(map, key, {
            value: _$value,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey != "object")
        return String(jsKey);
      if (identity.isNode(key) && (ctx != null && ctx.doc)) {
        var strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = ctx.anchors.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var node = _step.value;
            strCtx.anchors.add(node.anchor);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        strCtx.inFlow = !0, strCtx.inStringifyKey = !0;
        var strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          var jsonStr = JSON.stringify(strKey);
          jsonStr.length > 40 && (jsonStr = jsonStr.substring(0, 36) + '..."'), log2.warn(ctx.doc.options.logLevel, "Keys with collection values will be stringified due to JS Object restrictions: ".concat(jsonStr, ". Set mapAsMap: true to use object keys.")), ctx.mapKeyWarned = !0;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// ../../node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../../node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    var createNode = require_createNode(), stringifyPair = require_stringifyPair(), addPairToJSMap = require_addPairToJSMap(), identity = require_identity();
    function createPair(key, value, ctx) {
      var k = createNode.createNode(key, void 0, ctx), v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = /* @__PURE__ */ function() {
      function Pair2(key) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _class_call_check15(this, Pair2), Object.defineProperty(this, identity.NODE_TYPE, {
          value: identity.PAIR
        }), this.key = key, this.value = value;
      }
      return _create_class13(Pair2, [
        {
          key: "clone",
          value: function(schema) {
            var _this = this, key = _this.key, value = _this.value;
            return identity.isNode(key) && (key = key.clone(schema)), identity.isNode(value) && (value = value.clone(schema)), new Pair2(key, value);
          }
        },
        {
          key: "toJSON",
          value: function(_, ctx) {
            var pair = ctx != null && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
            return addPairToJSMap.addPairToJSMap(ctx, pair, this);
          }
        },
        {
          key: "toString",
          value: function(ctx, onComment, onChompKeep) {
            return ctx != null && ctx.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
          }
        }
      ]), Pair2;
    }();
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var Collection = require_Collection(), identity = require_identity(), stringify = require_stringify2(), stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      var _ctx_inFlow, flow = (_ctx_inFlow = ctx.inFlow) !== null && _ctx_inFlow !== void 0 ? _ctx_inFlow : collection.flow, stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection(param, ctx, param1) {
      for (var _loop = function(i2) {
        var item = items[i2], comment2 = null;
        if (identity.isNode(item))
          !chompKeep && item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, chompKeep), item.comment && (comment2 = item.comment);
        else if (identity.isPair(item)) {
          var ik = identity.isNode(item.key) ? item.key : null;
          ik && (!chompKeep && ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, chompKeep));
        }
        chompKeep = !1;
        var str2 = stringify.stringify(item, itemCtx, function() {
          return comment2 = null;
        }, function() {
          return chompKeep = !0;
        });
        comment2 && (str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2))), chompKeep && comment2 && (chompKeep = !1), lines.push(blockItemPrefix + str2);
      }, comment = param.comment, items = param.items, blockItemPrefix = param1.blockItemPrefix, flowChars = param1.flowChars, itemIndent = param1.itemIndent, onChompKeep = param1.onChompKeep, onComment = param1.onComment, indent = ctx.indent, commentString = ctx.options.commentString, itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        type: null
      }), chompKeep = !1, lines = [], i = 0; i < items.length; ++i)
        _loop(i);
      var str;
      if (lines.length === 0)
        str = flowChars.start + flowChars.end;
      else {
        str = lines[0];
        for (var i1 = 1; i1 < lines.length; ++i1) {
          var line = lines[i1];
          str += line ? `
`.concat(indent).concat(line) : `
`;
        }
      }
      return comment ? (str += `
` + stringifyComment.indentComment(commentString(comment), indent), onComment && onComment()) : chompKeep && onChompKeep && onChompKeep(), str;
    }
    function stringifyFlowCollection(param, ctx, param1) {
      var _loop = function(i2) {
        var item = items[i2], comment2 = null;
        if (identity.isNode(item))
          item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, !1), item.comment && (comment2 = item.comment);
        else if (identity.isPair(item)) {
          var ik = identity.isNode(item.key) ? item.key : null;
          ik && (ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, !1), ik.comment && (reqNewline = !0));
          var iv = identity.isNode(item.value) ? item.value : null;
          iv ? (iv.comment && (comment2 = iv.comment), iv.commentBefore && (reqNewline = !0)) : item.value == null && (ik != null && ik.comment) && (comment2 = ik.comment);
        }
        comment2 && (reqNewline = !0);
        var str2 = stringify.stringify(item, itemCtx, function() {
          return comment2 = null;
        });
        i2 < items.length - 1 && (str2 += ","), comment2 && (str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2))), !reqNewline && (lines.length > linesAtValue || str2.includes(`
`)) && (reqNewline = !0), lines.push(str2), linesAtValue = lines.length;
      }, comment = param.comment, items = param.items, flowChars = param1.flowChars, itemIndent = param1.itemIndent, onComment = param1.onComment, indent = ctx.indent, indentStep = ctx.indentStep, fcPadding = ctx.flowCollectionPadding, commentString = ctx.options.commentString;
      itemIndent += indentStep;
      for (var itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: !0,
        type: null
      }), reqNewline = !1, linesAtValue = 0, lines = [], i = 0; i < items.length; ++i)
        _loop(i);
      var str, start = flowChars.start, end = flowChars.end;
      if (lines.length === 0)
        str = start + end;
      else {
        if (!reqNewline) {
          var len = lines.reduce(function(sum, line2) {
            return sum + line2.length + 2;
          }, 2);
          reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
          str = start;
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var line = _step.value;
              str += line ? `
`.concat(indentStep).concat(indent).concat(line) : `
`;
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          str += `
`.concat(indent).concat(end);
        } else
          str = "".concat(start).concat(fcPadding).concat(lines.join(" ")).concat(fcPadding).concat(end);
      }
      return comment && (str += stringifyComment.lineComment(str, indent, commentString(comment)), onComment && onComment()), str;
    }
    function addCommentBefore(param, lines, comment, chompKeep) {
      var indent = param.indent, commentString = param.options.commentString;
      if (comment && chompKeep && (comment = comment.replace(/^\n+/, "")), comment) {
        var ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var stringifyCollection = require_stringifyCollection(), addPairToJSMap = require_addPairToJSMap(), Collection = require_Collection(), identity = require_identity(), Pair = require_Pair(), Scalar = require_Scalar();
    function findPair(items, key) {
      var k = identity.isScalar(key) ? key.value : key, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var it = _step.value;
          if (identity.isPair(it) && (it.key === key || it.key === k || identity.isScalar(it.key) && it.key.value === k))
            return it;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
    }
    var YAMLMap = /* @__PURE__ */ function(_Collection_Collection) {
      _inherits10(YAMLMap2, _Collection_Collection);
      var _super = _create_super10(YAMLMap2);
      function YAMLMap2(schema) {
        _class_call_check15(this, YAMLMap2);
        var _this;
        return _this = _super.call(this, identity.MAP, schema), _this.items = [], _this;
      }
      return _create_class13(YAMLMap2, [
        {
          /**
          * Adds a value to the collection.
          *
          * @param overwrite - If not set `true`, using a key that is already in the
          *   collection will throw. Otherwise, overwrites the previous value.
          */
          key: "add",
          value: function(pair, overwrite) {
            var _this_schema, _pair;
            identity.isPair(pair) ? _pair = pair : !pair || typeof pair != "object" || !("key" in pair) ? _pair = new Pair.Pair(pair, pair == null ? void 0 : pair.value) : _pair = new Pair.Pair(pair.key, pair.value);
            var prev = findPair(this.items, _pair.key), sortEntries = (_this_schema = this.schema) === null || _this_schema === void 0 ? void 0 : _this_schema.sortMapEntries;
            if (prev) {
              if (!overwrite)
                throw new Error("Key ".concat(_pair.key, " already set"));
              identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value) ? prev.value.value = _pair.value : prev.value = _pair.value;
            } else if (sortEntries) {
              var i = this.items.findIndex(function(item) {
                return sortEntries(_pair, item) < 0;
              });
              i === -1 ? this.items.push(_pair) : this.items.splice(i, 0, _pair);
            } else
              this.items.push(_pair);
          }
        },
        {
          key: "delete",
          value: function(key) {
            var it = findPair(this.items, key);
            if (!it)
              return !1;
            var del = this.items.splice(this.items.indexOf(it), 1);
            return del.length > 0;
          }
        },
        {
          key: "get",
          value: function(key, keepScalar) {
            var it = findPair(this.items, key), node = it == null ? void 0 : it.value, _ref;
            return (_ref = !keepScalar && identity.isScalar(node) ? node.value : node) !== null && _ref !== void 0 ? _ref : void 0;
          }
        },
        {
          key: "has",
          value: function(key) {
            return !!findPair(this.items, key);
          }
        },
        {
          key: "set",
          value: function(key, value) {
            this.add(new Pair.Pair(key, value), !0);
          }
        },
        {
          /**
          * @param ctx - Conversion context, originally set in Document#toJS()
          * @param {Class} Type - If set, forces the returned collection type
          * @returns Instance of Type, Map, or Object
          */
          key: "toJSON",
          value: function(_, ctx, Type) {
            var map = Type ? new Type() : ctx != null && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
            ctx != null && ctx.onCreate && ctx.onCreate(map);
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var item = _step.value;
                addPairToJSMap.addPairToJSMap(ctx, map, item);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return map;
          }
        },
        {
          key: "toString",
          value: function(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var item = _step.value;
                if (!identity.isPair(item))
                  throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return !ctx.allNullValues && this.hasAllNullValues(!1) && (ctx = Object.assign({}, ctx, {
              allNullValues: !0
            })), stringifyCollection.stringifyCollection(this, ctx, {
              blockItemPrefix: "",
              flowChars: {
                start: "{",
                end: "}"
              },
              itemIndent: ctx.indent || "",
              onChompKeep,
              onComment
            });
          }
        }
      ], [
        {
          key: "tagName",
          get: function() {
            return "tag:yaml.org,2002:map";
          }
        },
        {
          key: "from",
          value: (
            /**
            * A generic collection parsing method that can be extended
            * to other node classes that inherit from YAMLMap
            */
            function(schema, obj, ctx) {
              var keepUndefined = ctx.keepUndefined, replacer = ctx.replacer, map = new this(schema), add = function(key2, value2) {
                if (typeof replacer == "function")
                  value2 = replacer.call(obj, key2, value2);
                else if (Array.isArray(replacer) && !replacer.includes(key2))
                  return;
                (value2 !== void 0 || keepUndefined) && map.items.push(Pair.createPair(key2, value2, ctx));
              };
              if (_instanceof13(obj, Map)) {
                var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                try {
                  for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                    var _step_value = _sliced_to_array15(_step.value, 2), key = _step_value[0], value = _step_value[1];
                    add(key, value);
                  }
                } catch (err) {
                  _didIteratorError2 = !0, _iteratorError2 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                }
              } else if (obj && typeof obj == "object") {
                var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
                try {
                  for (var _iterator1 = Object.keys(obj)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                    var key1 = _step1.value;
                    add(key1, obj[key1]);
                  }
                } catch (err) {
                  _didIteratorError12 = !0, _iteratorError12 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
                  } finally {
                    if (_didIteratorError12)
                      throw _iteratorError12;
                  }
                }
              }
              return typeof schema.sortMapEntries == "function" && map.items.sort(schema.sortMapEntries), map;
            }
          )
        }
      ]), YAMLMap2;
    }(Collection.Collection);
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// ../../node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../../node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity(), YAMLMap = require_YAMLMap(), map = {
      collection: "map",
      default: !0,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: function(map2, onError) {
        return identity.isMap(map2) || onError("Expected a mapping for this tag"), map2;
      },
      createNode: function(schema, obj, ctx) {
        return YAMLMap.YAMLMap.from(schema, obj, ctx);
      }
    };
    exports2.map = map;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var createNode = require_createNode(), stringifyCollection = require_stringifyCollection(), Collection = require_Collection(), identity = require_identity(), Scalar = require_Scalar(), toJS = require_toJS(), YAMLSeq = /* @__PURE__ */ function(_Collection_Collection) {
      _inherits10(YAMLSeq2, _Collection_Collection);
      var _super = _create_super10(YAMLSeq2);
      function YAMLSeq2(schema) {
        _class_call_check15(this, YAMLSeq2);
        var _this;
        return _this = _super.call(this, identity.SEQ, schema), _this.items = [], _this;
      }
      return _create_class13(YAMLSeq2, [
        {
          key: "add",
          value: function(value) {
            this.items.push(value);
          }
        },
        {
          /**
          * Removes a value from the collection.
          *
          * `key` must contain a representation of an integer for this to succeed.
          * It may be wrapped in a `Scalar`.
          *
          * @returns `true` if the item was found and removed.
          */
          key: "delete",
          value: function(key) {
            var idx = asItemIndex(key);
            if (typeof idx != "number")
              return !1;
            var del = this.items.splice(idx, 1);
            return del.length > 0;
          }
        },
        {
          key: "get",
          value: function(key, keepScalar) {
            var idx = asItemIndex(key);
            if (typeof idx == "number") {
              var it = this.items[idx];
              return !keepScalar && identity.isScalar(it) ? it.value : it;
            }
          }
        },
        {
          /**
          * Checks if the collection includes a value with the key `key`.
          *
          * `key` must contain a representation of an integer for this to succeed.
          * It may be wrapped in a `Scalar`.
          */
          key: "has",
          value: function(key) {
            var idx = asItemIndex(key);
            return typeof idx == "number" && idx < this.items.length;
          }
        },
        {
          /**
          * Sets a value in this collection. For `!!set`, `value` needs to be a
          * boolean to add/remove the item from the set.
          *
          * If `key` does not contain a representation of an integer, this will throw.
          * It may be wrapped in a `Scalar`.
          */
          key: "set",
          value: function(key, value) {
            var idx = asItemIndex(key);
            if (typeof idx != "number")
              throw new Error("Expected a valid index, not ".concat(key, "."));
            var prev = this.items[idx];
            identity.isScalar(prev) && Scalar.isScalarValue(value) ? prev.value = value : this.items[idx] = value;
          }
        },
        {
          key: "toJSON",
          value: function(_, ctx) {
            var seq = [];
            ctx != null && ctx.onCreate && ctx.onCreate(seq);
            var i = 0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var item = _step.value;
                seq.push(toJS.toJS(item, String(i++), ctx));
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return seq;
          }
        },
        {
          key: "toString",
          value: function(ctx, onComment, onChompKeep) {
            return ctx ? stringifyCollection.stringifyCollection(this, ctx, {
              blockItemPrefix: "- ",
              flowChars: {
                start: "[",
                end: "]"
              },
              itemIndent: (ctx.indent || "") + "  ",
              onChompKeep,
              onComment
            }) : JSON.stringify(this);
          }
        }
      ], [
        {
          key: "tagName",
          get: function() {
            return "tag:yaml.org,2002:seq";
          }
        },
        {
          key: "from",
          value: function(schema, obj, ctx) {
            var replacer = ctx.replacer, seq = new this(schema);
            if (obj && Symbol.iterator in Object(obj)) {
              var i = 0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var it = _step.value;
                  if (typeof replacer == "function") {
                    var key = _instanceof13(obj, Set) ? it : String(i++);
                    it = replacer.call(obj, key, it);
                  }
                  seq.items.push(createNode.createNode(it, void 0, ctx));
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
            }
            return seq;
          }
        }
      ]), YAMLSeq2;
    }(Collection.Collection);
    function asItemIndex(key) {
      var idx = identity.isScalar(key) ? key.value : key;
      return idx && typeof idx == "string" && (idx = Number(idx)), typeof idx == "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// ../../node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../../node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity(), YAMLSeq = require_YAMLSeq(), seq = {
      collection: "seq",
      default: !0,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: function(seq2, onError) {
        return identity.isSeq(seq2) || onError("Expected a sequence for this tag"), seq2;
      },
      createNode: function(schema, obj, ctx) {
        return YAMLSeq.YAMLSeq.from(schema, obj, ctx);
      }
    };
    exports2.seq = seq;
  }
});

// ../../node_modules/yaml/dist/schema/common/string.js
var require_string2 = __commonJS({
  "../../node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString(), string = {
      identify: function(value) {
        return typeof value == "string";
      },
      default: !0,
      tag: "tag:yaml.org,2002:str",
      resolve: function(str) {
        return str;
      },
      stringify: function(item, ctx, onComment, onChompKeep) {
        return ctx = Object.assign({
          actualString: !0
        }, ctx), stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// ../../node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../../node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), nullTag = {
      identify: function(value) {
        return value == null;
      },
      createNode: function() {
        return new Scalar.Scalar(null);
      },
      default: !0,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: function() {
        return new Scalar.Scalar(null);
      },
      stringify: function(param, ctx) {
        var source = param.source;
        return typeof source == "string" && nullTag.test.test(source) ? source : ctx.options.nullStr;
      }
    };
    exports2.nullTag = nullTag;
  }
});

// ../../node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../../node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), boolTag = {
      identify: function(value) {
        return typeof value == "boolean";
      },
      default: !0,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: function(str) {
        return new Scalar.Scalar(str[0] === "t" || str[0] === "T");
      },
      stringify: function(param, ctx) {
        var source = param.source, value = param.value;
        if (source && boolTag.test.test(source)) {
          var sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function stringifyNumber(param) {
      var format = param.format, minFractionDigits = param.minFractionDigits, tag = param.tag, value = param.value;
      if ((typeof value > "u" ? "undefined" : _type_of12(value)) === "bigint")
        return String(value);
      var num = typeof value == "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      var n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        var i = n.indexOf(".");
        i < 0 && (i = n.length, n += ".");
        for (var d = minFractionDigits - (n.length - i - 1); d-- > 0; )
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// ../../node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../../node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), stringifyNumber = require_stringifyNumber(), floatNaN = {
      identify: function(value) {
        return typeof value == "number";
      },
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: function(str) {
        return str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber.stringifyNumber
    }, floatExp = {
      identify: function(value) {
        return typeof value == "number";
      },
      default: !0,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: function(str) {
        return parseFloat(str);
      },
      stringify: function(node) {
        var num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    }, float = {
      identify: function(value) {
        return typeof value == "number";
      },
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve: function(str) {
        var node = new Scalar.Scalar(parseFloat(str)), dot = str.indexOf(".");
        return dot !== -1 && str[str.length - 1] === "0" && (node.minFractionDigits = str.length - dot - 1), node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../../node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    var stringifyNumber = require_stringifyNumber(), intIdentify = function(value) {
      return (typeof value > "u" ? "undefined" : _type_of12(value)) === "bigint" || Number.isInteger(value);
    }, intResolve = function(str, offset, radix, param) {
      var intAsBigInt = param.intAsBigInt;
      return intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    };
    function intStringify(node, radix, prefix) {
      var value = node.value;
      return intIdentify(value) && value >= 0 ? prefix + value.toString(radix) : stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: function(value) {
        return intIdentify(value) && value >= 0;
      },
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: function(str, _onError, opt) {
        return intResolve(str, 2, 8, opt);
      },
      stringify: function(node) {
        return intStringify(node, 8, "0o");
      }
    }, int = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: function(str, _onError, opt) {
        return intResolve(str, 0, 10, opt);
      },
      stringify: stringifyNumber.stringifyNumber
    }, intHex = {
      identify: function(value) {
        return intIdentify(value) && value >= 0;
      },
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: function(str, _onError, opt) {
        return intResolve(str, 2, 16, opt);
      },
      stringify: function(node) {
        return intStringify(node, 16, "0x");
      }
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../../node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map = require_map(), _null = require_null(), seq = require_seq(), string = require_string2(), bool = require_bool(), float = require_float(), int = require_int(), schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../../node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    var Scalar = require_Scalar(), map = require_map(), seq = require_seq();
    function intIdentify(value) {
      return (typeof value > "u" ? "undefined" : _type_of12(value)) === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = function(param) {
      var value = param.value;
      return JSON.stringify(value);
    }, jsonScalars = [
      {
        identify: function(value) {
          return typeof value == "string";
        },
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: function(str) {
          return str;
        },
        stringify: stringifyJSON
      },
      {
        identify: function(value) {
          return value == null;
        },
        createNode: function() {
          return new Scalar.Scalar(null);
        },
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: function() {
          return null;
        },
        stringify: stringifyJSON
      },
      {
        identify: function(value) {
          return typeof value == "boolean";
        },
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: function(str) {
          return str === "true";
        },
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: function(str, _onError, param) {
          var intAsBigInt = param.intAsBigInt;
          return intAsBigInt ? BigInt(str) : parseInt(str, 10);
        },
        stringify: function(param) {
          var value = param.value;
          return intIdentify(value) ? value.toString() : JSON.stringify(value);
        }
      },
      {
        identify: function(value) {
          return typeof value == "number";
        },
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: function(str) {
          return parseFloat(str);
        },
        stringify: stringifyJSON
      }
    ], jsonError = {
      default: !0,
      tag: "",
      test: /^/,
      resolve: function(str, onError) {
        return onError("Unresolved plain scalar ".concat(JSON.stringify(str))), str;
      }
    }, schema = [
      map.map,
      seq.seq
    ].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var Scalar = require_Scalar(), stringifyString = require_stringifyString(), binary = {
      identify: function(value) {
        return _instanceof13(value, Uint8Array);
      },
      default: !1,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve: function(src, onError) {
        if (typeof Buffer == "function")
          return Buffer.from(src, "base64");
        if (typeof atob == "function") {
          for (var str = atob(src.replace(/[\n\r]/g, "")), buffer = new Uint8Array(str.length), i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else
          return onError("This environment does not support reading binary tags; either Buffer or atob is required"), src;
      },
      stringify: function(param, ctx, onComment, onChompKeep) {
        var comment = param.comment, type = param.type, value = param.value, buf = value, str;
        if (typeof Buffer == "function")
          str = _instanceof13(buf, Buffer) ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        else if (typeof btoa == "function") {
          for (var s = "", i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        if (type || (type = Scalar.Scalar.BLOCK_LITERAL), type !== Scalar.Scalar.QUOTE_DOUBLE) {
          for (var lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth), n = Math.ceil(str.length / lineWidth), lines = new Array(n), i1 = 0, o = 0; i1 < n; ++i1, o += lineWidth)
            lines[i1] = str.substr(o, lineWidth);
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
        }
        return stringifyString.stringifyString({
          comment,
          type,
          value: str
        }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var identity = require_identity(), Pair = require_Pair(), Scalar = require_Scalar(), YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq))
        for (var i = 0; i < seq.items.length; ++i) {
          var item = seq.items[i];
          if (!identity.isPair(item)) {
            if (identity.isMap(item)) {
              item.items.length > 1 && onError("Each pair must have its own sequence indicator");
              var pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
              if (item.commentBefore && (pair.key.commentBefore = pair.key.commentBefore ? "".concat(item.commentBefore, `
`).concat(pair.key.commentBefore) : item.commentBefore), item.comment) {
                var _pair_value, cn = (_pair_value = pair.value) !== null && _pair_value !== void 0 ? _pair_value : pair.key;
                cn.comment = cn.comment ? "".concat(item.comment, `
`).concat(cn.comment) : item.comment;
              }
              item = pair;
            }
            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
          }
        }
      else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      var replacer = ctx.replacer, pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      var i = 0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      if (iterable && Symbol.iterator in Object(iterable))
        try {
          for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var it = _step.value;
            typeof replacer == "function" && (it = replacer.call(iterable, String(i++), it));
            var key = void 0, value = void 0;
            if (Array.isArray(it))
              if (it.length === 2)
                key = it[0], value = it[1];
              else
                throw new TypeError("Expected [key, value] tuple: ".concat(it));
            else if (it && _instanceof13(it, Object)) {
              var keys = Object.keys(it);
              if (keys.length === 1)
                key = keys[0], value = it[key];
              else
                throw new TypeError("Expected tuple with one key, not ".concat(keys.length, " keys"));
            } else
              key = it;
            pairs2.items.push(Pair.createPair(key, value, ctx));
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: !1,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var identity = require_identity(), toJS = require_toJS(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), pairs = require_pairs(), YAMLOMap = /* @__PURE__ */ function(_YAMLSeq_YAMLSeq) {
      _inherits10(YAMLOMap2, _YAMLSeq_YAMLSeq);
      var _super = _create_super10(YAMLOMap2);
      function YAMLOMap2() {
        _class_call_check15(this, YAMLOMap2);
        var _this;
        return _this = _super.call(this), _this.add = YAMLMap.YAMLMap.prototype.add.bind(_assert_this_initialized10(_this)), _this.delete = YAMLMap.YAMLMap.prototype.delete.bind(_assert_this_initialized10(_this)), _this.get = YAMLMap.YAMLMap.prototype.get.bind(_assert_this_initialized10(_this)), _this.has = YAMLMap.YAMLMap.prototype.has.bind(_assert_this_initialized10(_this)), _this.set = YAMLMap.YAMLMap.prototype.set.bind(_assert_this_initialized10(_this)), _this.tag = YAMLOMap2.tag, _this;
      }
      return _create_class13(YAMLOMap2, [
        {
          /**
          * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
          * but TypeScript won't allow widening the signature of a child method.
          */
          key: "toJSON",
          value: function(_, ctx) {
            if (!ctx)
              return _get4(_get_prototype_of10(YAMLOMap2.prototype), "toJSON", this).call(this, _);
            var map = /* @__PURE__ */ new Map();
            ctx != null && ctx.onCreate && ctx.onCreate(map);
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var pair = _step.value, key = void 0, value = void 0;
                if (identity.isPair(pair) ? (key = toJS.toJS(pair.key, "", ctx), value = toJS.toJS(pair.value, key, ctx)) : key = toJS.toJS(pair, "", ctx), map.has(key))
                  throw new Error("Ordered maps must not include duplicate keys");
                map.set(key, value);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            return map;
          }
        }
      ], [
        {
          key: "from",
          value: function(schema, iterable, ctx) {
            var pairs$1 = pairs.createPairs(schema, iterable, ctx), omap2 = new this();
            return omap2.items = pairs$1.items, omap2;
          }
        }
      ]), YAMLOMap2;
    }(YAMLSeq.YAMLSeq);
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: function(value) {
        return _instanceof13(value, Map);
      },
      nodeClass: YAMLOMap,
      default: !1,
      tag: "tag:yaml.org,2002:omap",
      resolve: function(seq, onError) {
        var pairs$1 = pairs.resolvePairs(seq, onError), seenKeys = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = pairs$1.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var key = _step.value.key;
            identity.isScalar(key) && (seenKeys.includes(key.value) ? onError("Ordered maps must not include duplicate keys: ".concat(key.value)) : seenKeys.push(key.value));
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: function(schema, iterable, ctx) {
        return YAMLOMap.from(schema, iterable, ctx);
      }
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify(param, ctx) {
      var value = param.value, source = param.source, boolObj = value ? trueTag : falseTag;
      return source && boolObj.test.test(source) ? source : value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: function(value) {
        return value === !0;
      },
      default: !0,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: function() {
        return new Scalar.Scalar(!0);
      },
      stringify: boolStringify
    }, falseTag = {
      identify: function(value) {
        return value === !1;
      },
      default: !0,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: function() {
        return new Scalar.Scalar(!1);
      },
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), stringifyNumber = require_stringifyNumber(), floatNaN = {
      identify: function(value) {
        return typeof value == "number";
      },
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: function(str) {
        return str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber.stringifyNumber
    }, floatExp = {
      identify: function(value) {
        return typeof value == "number";
      },
      default: !0,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: function(str) {
        return parseFloat(str.replace(/_/g, ""));
      },
      stringify: function(node) {
        var num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    }, float = {
      identify: function(value) {
        return typeof value == "number";
      },
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve: function(str) {
        var node = new Scalar.Scalar(parseFloat(str.replace(/_/g, ""))), dot = str.indexOf(".");
        if (dot !== -1) {
          var f = str.substring(dot + 1).replace(/_/g, "");
          f[f.length - 1] === "0" && (node.minFractionDigits = f.length);
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    var stringifyNumber = require_stringifyNumber(), intIdentify = function(value) {
      return (typeof value > "u" ? "undefined" : _type_of12(value)) === "bigint" || Number.isInteger(value);
    };
    function intResolve(str, offset, radix, param) {
      var intAsBigInt = param.intAsBigInt, sign = str[0];
      if ((sign === "-" || sign === "+") && (offset += 1), str = str.substring(offset).replace(/_/g, ""), intAsBigInt) {
        switch (radix) {
          case 2:
            str = "0b".concat(str);
            break;
          case 8:
            str = "0o".concat(str);
            break;
          case 16:
            str = "0x".concat(str);
            break;
        }
        var n = BigInt(str);
        return sign === "-" ? BigInt(-1) * n : n;
      }
      var n1 = parseInt(str, radix);
      return sign === "-" ? -1 * n1 : n1;
    }
    function intStringify(node, radix, prefix) {
      var value = node.value;
      if (intIdentify(value)) {
        var str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: function(str, _onError, opt) {
        return intResolve(str, 2, 2, opt);
      },
      stringify: function(node) {
        return intStringify(node, 2, "0b");
      }
    }, intOct = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: function(str, _onError, opt) {
        return intResolve(str, 1, 8, opt);
      },
      stringify: function(node) {
        return intStringify(node, 8, "0");
      }
    }, int = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: function(str, _onError, opt) {
        return intResolve(str, 0, 10, opt);
      },
      stringify: stringifyNumber.stringifyNumber
    }, intHex = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: function(str, _onError, opt) {
        return intResolve(str, 2, 16, opt);
      },
      stringify: function(node) {
        return intStringify(node, 16, "0x");
      }
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _get4(target, property, receiver) {
      return typeof Reflect < "u" && Reflect.get ? _get4 = Reflect.get : _get4 = function(target2, property2, receiver2) {
        var base = _super_prop_base4(target2, property2);
        if (base) {
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
        }
      }, _get4(target, property, receiver || target);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _super_prop_base4(object, property) {
      for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of10(object), object !== null); )
        ;
      return object;
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var identity = require_identity(), Pair = require_Pair(), YAMLMap = require_YAMLMap(), YAMLSet = /* @__PURE__ */ function(_YAMLMap_YAMLMap) {
      _inherits10(YAMLSet2, _YAMLMap_YAMLMap);
      var _super = _create_super10(YAMLSet2);
      function YAMLSet2(schema) {
        _class_call_check15(this, YAMLSet2);
        var _this;
        return _this = _super.call(this, schema), _this.tag = YAMLSet2.tag, _this;
      }
      return _create_class13(YAMLSet2, [
        {
          key: "add",
          value: function(key) {
            var pair;
            identity.isPair(key) ? pair = key : key && typeof key == "object" && "key" in key && "value" in key && key.value === null ? pair = new Pair.Pair(key.key, null) : pair = new Pair.Pair(key, null);
            var prev = YAMLMap.findPair(this.items, pair.key);
            prev || this.items.push(pair);
          }
        },
        {
          /**
          * If `keepPair` is `true`, returns the Pair matching `key`.
          * Otherwise, returns the value of that Pair's key.
          */
          key: "get",
          value: function(key, keepPair) {
            var pair = YAMLMap.findPair(this.items, key);
            return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
          }
        },
        {
          key: "set",
          value: function(key, value) {
            if (typeof value != "boolean")
              throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(typeof value > "u" ? "undefined" : _type_of12(value)));
            var prev = YAMLMap.findPair(this.items, key);
            prev && !value ? this.items.splice(this.items.indexOf(prev), 1) : !prev && value && this.items.push(new Pair.Pair(key));
          }
        },
        {
          key: "toJSON",
          value: function(_, ctx) {
            return _get4(_get_prototype_of10(YAMLSet2.prototype), "toJSON", this).call(this, _, ctx, Set);
          }
        },
        {
          key: "toString",
          value: function(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            if (this.hasAllNullValues(!0))
              return _get4(_get_prototype_of10(YAMLSet2.prototype), "toString", this).call(this, Object.assign({}, ctx, {
                allNullValues: !0
              }), onComment, onChompKeep);
            throw new Error("Set items must all have null values");
          }
        }
      ], [
        {
          key: "from",
          value: function(schema, iterable, ctx) {
            var replacer = ctx.replacer, set4 = new this(schema), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            if (iterable && Symbol.iterator in Object(iterable))
              try {
                for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var value = _step.value;
                  typeof replacer == "function" && (value = replacer.call(iterable, value, value)), set4.items.push(Pair.createPair(value, null, ctx));
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
            return set4;
          }
        }
      ]), YAMLSet2;
    }(YAMLMap.YAMLMap);
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set3 = {
      collection: "map",
      identify: function(value) {
        return _instanceof13(value, Set);
      },
      nodeClass: YAMLSet,
      default: !1,
      tag: "tag:yaml.org,2002:set",
      createNode: function(schema, iterable, ctx) {
        return YAMLSet.from(schema, iterable, ctx);
      },
      resolve: function(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(!0))
            return Object.assign(new YAMLSet(), map);
          onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set3;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      var sign = str[0], parts = sign === "-" || sign === "+" ? str.substring(1) : str, num = function(n) {
        return asBigInt ? BigInt(n) : Number(n);
      }, res = parts.replace(/_/g, "").split(":").reduce(function(res2, p) {
        return res2 * num(60) + num(p);
      }, num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      var value = node.value, num = function(n) {
        return n;
      };
      if ((typeof value > "u" ? "undefined" : _type_of12(value)) === "bigint")
        num = function(n) {
          return BigInt(n);
        };
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      var sign = "";
      value < 0 && (sign = "-", value *= num(-1));
      var _60 = num(60), parts = [
        value % _60
      ];
      return value < 60 ? parts.unshift(0) : (value = (value - parts[0]) / _60, parts.unshift(value % _60), value >= 60 && (value = (value - parts[0]) / _60, parts.unshift(value))), sign + parts.map(function(n) {
        return String(n).padStart(2, "0");
      }).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: function(value) {
        return (typeof value > "u" ? "undefined" : _type_of12(value)) === "bigint" || Number.isInteger(value);
      },
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: function(str, _onError, param) {
        var intAsBigInt = param.intAsBigInt;
        return parseSexagesimal(str, intAsBigInt);
      },
      stringify: stringifySexagesimal
    }, floatTime = {
      identify: function(value) {
        return typeof value == "number";
      },
      default: !0,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: function(str) {
        return parseSexagesimal(str, !1);
      },
      stringify: stringifySexagesimal
    }, timestamp = {
      identify: function(value) {
        return _instanceof13(value, Date);
      },
      default: !0,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve: function(str) {
        var match2 = str.match(timestamp.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        var _match_map = _sliced_to_array15(match2.map(Number), 7), year = _match_map[1], month = _match_map[2], day = _match_map[3], hour = _match_map[4], minute = _match_map[5], second = _match_map[6], millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0, date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec), tz = match2[8];
        if (tz && tz !== "Z") {
          var d = parseSexagesimal(tz, !1);
          Math.abs(d) < 30 && (d *= 60), date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: function(param) {
        var value = param.value;
        return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
      }
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map = require_map(), _null = require_null(), seq = require_seq(), string = require_string2(), binary = require_binary(), bool = require_bool2(), float = require_float2(), int = require_int2(), omap = require_omap(), pairs = require_pairs(), set3 = require_set(), timestamp = require_timestamp(), schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set3.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../../node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map = require_map(), _null = require_null(), seq = require_seq(), string = require_string2(), bool = require_bool(), float = require_float(), int = require_int(), schema = require_schema(), schema$1 = require_schema2(), binary = require_binary(), omap = require_omap(), pairs = require_pairs(), schema$2 = require_schema3(), set3 = require_set(), timestamp = require_timestamp(), schemas = /* @__PURE__ */ new Map([
      [
        "core",
        schema.schema
      ],
      [
        "failsafe",
        [
          map.map,
          seq.seq,
          string.string
        ]
      ],
      [
        "json",
        schema$1.schema
      ],
      [
        "yaml11",
        schema$2.schema
      ],
      [
        "yaml-1.1",
        schema$2.schema
      ]
    ]), tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set3.set,
      timestamp: timestamp.timestamp
    }, coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set3.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName) {
      var tags = schemas.get(schemaName);
      if (!tags)
        if (Array.isArray(customTags))
          tags = [];
        else {
          var keys = Array.from(schemas.keys()).filter(function(key) {
            return key !== "yaml11";
          }).map(function(key) {
            return JSON.stringify(key);
          }).join(", ");
          throw new Error('Unknown schema "'.concat(schemaName, '"; use one of ').concat(keys, " or define customTags array"));
        }
      if (Array.isArray(customTags)) {
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = customTags[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var tag = _step.value;
            tags = tags.concat(tag);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      } else
        typeof customTags == "function" && (tags = customTags(tags.slice()));
      return tags.map(function(tag2) {
        if (typeof tag2 != "string")
          return tag2;
        var tagObj = tagsByName[tag2];
        if (tagObj)
          return tagObj;
        var keys2 = Object.keys(tagsByName).map(function(key) {
          return JSON.stringify(key);
        }).join(", ");
        throw new Error('Unknown custom tag "'.concat(tag2, '"; use one of ').concat(keys2));
      });
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// ../../node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../../node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    var identity = require_identity(), map = require_map(), seq = require_seq(), string = require_string2(), tags = require_tags(), sortMapEntriesByKey = function(a, b) {
      return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    }, Schema = /* @__PURE__ */ function() {
      function Schema2(param) {
        var compat = param.compat, customTags = param.customTags, merge = param.merge, resolveKnownTags = param.resolveKnownTags, schema = param.schema, sortMapEntries = param.sortMapEntries, toStringDefaults = param.toStringDefaults;
        _class_call_check15(this, Schema2), this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null, this.merge = !!merge, this.name = typeof schema == "string" && schema || "core", this.knownTags = resolveKnownTags ? tags.coreKnownTags : {}, this.tags = tags.getTags(customTags, this.name), this.toStringOptions = toStringDefaults ?? null, Object.defineProperty(this, identity.MAP, {
          value: map.map
        }), Object.defineProperty(this, identity.SCALAR, {
          value: string.string
        }), Object.defineProperty(this, identity.SEQ, {
          value: seq.seq
        }), this.sortMapEntries = typeof sortMapEntries == "function" ? sortMapEntries : sortMapEntries === !0 ? sortMapEntriesByKey : null;
      }
      return _create_class13(Schema2, [
        {
          key: "clone",
          value: function() {
            var copy2 = Object.create(Schema2.prototype, Object.getOwnPropertyDescriptors(this));
            return copy2.tags = this.tags.slice(), copy2;
          }
        }
      ]), Schema2;
    }();
    exports2.Schema = Schema;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity(), stringify = require_stringify2(), stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      var _doc_directives, lines = [], hasDirectives = options.directives === !0;
      if (options.directives !== !1 && doc.directives) {
        var dir = doc.directives.toString(doc);
        dir ? (lines.push(dir), hasDirectives = !0) : doc.directives.docStart && (hasDirectives = !0);
      }
      hasDirectives && lines.push("---");
      var ctx = stringify.createStringifyContext(doc, options), commentString = ctx.options.commentString;
      if (doc.commentBefore) {
        lines.length !== 1 && lines.unshift("");
        var cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      var chompKeep = !1, contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives && lines.push(""), doc.contents.commentBefore) {
            var cs1 = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs1, ""));
          }
          ctx.forceBlockIndent = !!doc.comment, contentComment = doc.contents.comment;
        }
        var onChompKeep = contentComment ? void 0 : function() {
          return chompKeep = !0;
        }, body = stringify.stringify(doc.contents, ctx, function() {
          return contentComment = null;
        }, onChompKeep);
        contentComment && (body += stringifyComment.lineComment(body, "", commentString(contentComment))), (body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---" ? lines[lines.length - 1] = "--- ".concat(body) : lines.push(body);
      } else
        lines.push(stringify.stringify(doc.contents, ctx));
      if (!((_doc_directives = doc.directives) === null || _doc_directives === void 0) && _doc_directives.docEnd)
        if (doc.comment) {
          var cs2 = commentString(doc.comment);
          cs2.includes(`
`) ? (lines.push("..."), lines.push(stringifyComment.indentComment(cs2, ""))) : lines.push("... ".concat(cs2));
        } else
          lines.push("...");
      else {
        var dc = doc.comment;
        dc && chompKeep && (dc = dc.replace(/^\n+/, "")), dc && ((!chompKeep || contentComment) && lines[lines.length - 1] !== "" && lines.push(""), lines.push(stringifyComment.indentComment(commentString(dc), "")));
      }
      return lines.join(`
`) + `
`;
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// ../../node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../../node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var Alias = require_Alias(), Collection = require_Collection(), identity = require_identity(), Pair = require_Pair(), toJS = require_toJS(), Schema = require_Schema(), stringifyDocument = require_stringifyDocument(), anchors = require_anchors(), applyReviver = require_applyReviver(), createNode = require_createNode(), directives = require_directives(), Document = /* @__PURE__ */ function() {
      function Document2(value, replacer, options) {
        _class_call_check15(this, Document2), this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, identity.NODE_TYPE, {
          value: identity.DOC
        });
        var _replacer = null;
        typeof replacer == "function" || Array.isArray(replacer) ? _replacer = replacer : options === void 0 && replacer && (options = replacer, replacer = void 0);
        var opt = Object.assign({
          intAsBigInt: !1,
          keepSourceTokens: !1,
          logLevel: "warn",
          prettyErrors: !0,
          strict: !0,
          uniqueKeys: !0,
          version: "1.2"
        }, options);
        this.options = opt;
        var version2 = opt.version;
        options != null && options._directives ? (this.directives = options._directives.atDocument(), this.directives.yaml.explicit && (version2 = this.directives.yaml.version)) : this.directives = new directives.Directives({
          version: version2
        }), this.setSchema(version2, options), this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      return _create_class13(Document2, [
        {
          /**
          * Create a deep copy of this Document and its contents.
          *
          * Custom Node values that inherit from `Object` still refer to their original instances.
          */
          key: "clone",
          value: function() {
            var copy2 = Object.create(Document2.prototype, _define_property21({}, identity.NODE_TYPE, {
              value: identity.DOC
            }));
            return copy2.commentBefore = this.commentBefore, copy2.comment = this.comment, copy2.errors = this.errors.slice(), copy2.warnings = this.warnings.slice(), copy2.options = Object.assign({}, this.options), this.directives && (copy2.directives = this.directives.clone()), copy2.schema = this.schema.clone(), copy2.contents = identity.isNode(this.contents) ? this.contents.clone(copy2.schema) : this.contents, this.range && (copy2.range = this.range.slice()), copy2;
          }
        },
        {
          /** Adds a value to the document. */
          key: "add",
          value: function(value) {
            assertCollection(this.contents) && this.contents.add(value);
          }
        },
        {
          /** Adds a value to the document. */
          key: "addIn",
          value: function(path6, value) {
            assertCollection(this.contents) && this.contents.addIn(path6, value);
          }
        },
        {
          /**
          * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
          *
          * If `node` already has an anchor, `name` is ignored.
          * Otherwise, the `node.anchor` value will be set to `name`,
          * or if an anchor with that name is already present in the document,
          * `name` will be used as a prefix for a new unique anchor.
          * If `name` is undefined, the generated anchor will use 'a' as a prefix.
          */
          key: "createAlias",
          value: function(node, name) {
            if (!node.anchor) {
              var prev = anchors.anchorNames(this);
              node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
              !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
            }
            return new Alias.Alias(node.anchor);
          }
        },
        {
          key: "createNode",
          value: function(value, replacer, options) {
            var _replacer = void 0;
            if (typeof replacer == "function")
              value = replacer.call({
                "": value
              }, "", value), _replacer = replacer;
            else if (Array.isArray(replacer)) {
              var keyToStr = function(v) {
                return typeof v == "number" || _instanceof13(v, String) || _instanceof13(v, Number);
              }, asStr = replacer.filter(keyToStr).map(String);
              asStr.length > 0 && (replacer = replacer.concat(asStr)), _replacer = replacer;
            } else
              options === void 0 && replacer && (options = replacer, replacer = void 0);
            var _ref = options ?? {}, aliasDuplicateObjects = _ref.aliasDuplicateObjects, anchorPrefix = _ref.anchorPrefix, flow = _ref.flow, keepUndefined = _ref.keepUndefined, onTagObj = _ref.onTagObj, tag = _ref.tag, _anchors_createNodeAnchors = anchors.createNodeAnchors(
              this,
              // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
              anchorPrefix || "a"
            ), onAnchor = _anchors_createNodeAnchors.onAnchor, setAnchors = _anchors_createNodeAnchors.setAnchors, sourceObjects = _anchors_createNodeAnchors.sourceObjects, ctx = {
              aliasDuplicateObjects: aliasDuplicateObjects ?? !0,
              keepUndefined: keepUndefined ?? !1,
              onAnchor,
              onTagObj,
              replacer: _replacer,
              schema: this.schema,
              sourceObjects
            }, node = createNode.createNode(value, tag, ctx);
            return flow && identity.isCollection(node) && (node.flow = !0), setAnchors(), node;
          }
        },
        {
          /**
          * Convert a key and a value into a `Pair` using the current schema,
          * recursively wrapping all values as `Scalar` or `Collection` nodes.
          */
          key: "createPair",
          value: function(key, value) {
            var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, k = this.createNode(key, null, options), v = this.createNode(value, null, options);
            return new Pair.Pair(k, v);
          }
        },
        {
          /**
          * Removes a value from the document.
          * @returns `true` if the item was found and removed.
          */
          key: "delete",
          value: function(key) {
            return assertCollection(this.contents) ? this.contents.delete(key) : !1;
          }
        },
        {
          /**
          * Removes a value from the document.
          * @returns `true` if the item was found and removed.
          */
          key: "deleteIn",
          value: function(path6) {
            return Collection.isEmptyPath(path6) ? this.contents == null ? !1 : (this.contents = null, !0) : assertCollection(this.contents) ? this.contents.deleteIn(path6) : !1;
          }
        },
        {
          /**
          * Returns item at `key`, or `undefined` if not found. By default unwraps
          * scalar values from their surrounding node; to disable set `keepScalar` to
          * `true` (collections are always returned intact).
          */
          key: "get",
          value: function(key, keepScalar) {
            return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
          }
        },
        {
          /**
          * Returns item at `path`, or `undefined` if not found. By default unwraps
          * scalar values from their surrounding node; to disable set `keepScalar` to
          * `true` (collections are always returned intact).
          */
          key: "getIn",
          value: function(path6, keepScalar) {
            return Collection.isEmptyPath(path6) ? !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents : identity.isCollection(this.contents) ? this.contents.getIn(path6, keepScalar) : void 0;
          }
        },
        {
          /**
          * Checks if the document includes a value with the key `key`.
          */
          key: "has",
          value: function(key) {
            return identity.isCollection(this.contents) ? this.contents.has(key) : !1;
          }
        },
        {
          /**
          * Checks if the document includes a value at `path`.
          */
          key: "hasIn",
          value: function(path6) {
            return Collection.isEmptyPath(path6) ? this.contents !== void 0 : identity.isCollection(this.contents) ? this.contents.hasIn(path6) : !1;
          }
        },
        {
          /**
          * Sets a value in this document. For `!!set`, `value` needs to be a
          * boolean to add/remove the item from the set.
          */
          key: "set",
          value: function(key, value) {
            this.contents == null ? this.contents = Collection.collectionFromPath(this.schema, [
              key
            ], value) : assertCollection(this.contents) && this.contents.set(key, value);
          }
        },
        {
          /**
          * Sets a value in this document. For `!!set`, `value` needs to be a
          * boolean to add/remove the item from the set.
          */
          key: "setIn",
          value: function(path6, value) {
            Collection.isEmptyPath(path6) ? this.contents = value : this.contents == null ? this.contents = Collection.collectionFromPath(this.schema, Array.from(path6), value) : assertCollection(this.contents) && this.contents.setIn(path6, value);
          }
        },
        {
          /**
          * Change the YAML version and schema used by the document.
          * A `null` version disables support for directives, explicit tags, anchors, and aliases.
          * It also requires the `schema` option to be given as a `Schema` instance value.
          *
          * Overrides all previously set schema options.
          */
          key: "setSchema",
          value: function(version2) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            typeof version2 == "number" && (version2 = String(version2));
            var opt;
            switch (version2) {
              case "1.1":
                this.directives ? this.directives.yaml.version = "1.1" : this.directives = new directives.Directives({
                  version: "1.1"
                }), opt = {
                  merge: !0,
                  resolveKnownTags: !1,
                  schema: "yaml-1.1"
                };
                break;
              case "1.2":
              case "next":
                this.directives ? this.directives.yaml.version = version2 : this.directives = new directives.Directives({
                  version: version2
                }), opt = {
                  merge: !1,
                  resolveKnownTags: !0,
                  schema: "core"
                };
                break;
              case null:
                this.directives && delete this.directives, opt = null;
                break;
              default: {
                var sv = JSON.stringify(version2);
                throw new Error("Expected '1.1', '1.2' or null as first argument, but found: ".concat(sv));
              }
            }
            if (_instanceof13(options.schema, Object))
              this.schema = options.schema;
            else if (opt)
              this.schema = new Schema.Schema(Object.assign(opt, options));
            else
              throw new Error("With a null YAML version, the { schema: Schema } option is required");
          }
        },
        {
          // json & jsonArg are only used from toJSON()
          key: "toJS",
          value: function() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, json = _ref.json, jsonArg = _ref.jsonArg, mapAsMap = _ref.mapAsMap, maxAliasCount = _ref.maxAliasCount, onAnchor = _ref.onAnchor, reviver = _ref.reviver, ctx = {
              anchors: /* @__PURE__ */ new Map(),
              doc: this,
              keep: !json,
              mapAsMap: mapAsMap === !0,
              mapKeyWarned: !1,
              maxAliasCount: typeof maxAliasCount == "number" ? maxAliasCount : 100
            }, res = toJS.toJS(this.contents, jsonArg ?? "", ctx), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            if (typeof onAnchor == "function")
              try {
                for (var _iterator = ctx.anchors.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var _step_value = _step.value, count = _step_value.count, res1 = _step_value.res;
                  onAnchor(res1, count);
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
            return typeof reviver == "function" ? applyReviver.applyReviver(reviver, {
              "": res
            }, "", res) : res;
          }
        },
        {
          /**
          * A JSON representation of the document `contents`.
          *
          * @param jsonArg Used by `JSON.stringify` to indicate the array index or
          *   property name.
          */
          key: "toJSON",
          value: function(jsonArg, onAnchor) {
            return this.toJS({
              json: !0,
              jsonArg,
              mapAsMap: !1,
              onAnchor
            });
          }
        },
        {
          /** A YAML representation of the document. */
          key: "toString",
          value: function() {
            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (this.errors.length > 0)
              throw new Error("Document with errors cannot be stringified");
            if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
              var s = JSON.stringify(options.indent);
              throw new Error('"indent" option must be a positive integer, not '.concat(s));
            }
            return stringifyDocument.stringifyDocument(this, options);
          }
        }
      ]), Document2;
    }();
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return !0;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// ../../node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "../../node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _construct4(Parent, args, Class) {
      return _is_native_reflect_construct10() ? _construct4 = Reflect.construct : _construct4 = function(Parent2, args2, Class2) {
        var a = [
          null
        ];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
        return Class2 && _set_prototype_of10(instance, Class2.prototype), instance;
      }, _construct4.apply(null, arguments);
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _is_native_function4(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _wrap_native_super4(Class) {
      var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return _wrap_native_super4 = function(Class2) {
        if (Class2 === null || !_is_native_function4(Class2))
          return Class2;
        if (typeof Class2 != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache < "u") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct4(Class2, arguments, _get_prototype_of10(this).constructor);
        }
        return Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), _set_prototype_of10(Wrapper, Class2);
      }, _wrap_native_super4(Class);
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var YAMLError = /* @__PURE__ */ function(Error1) {
      _inherits10(YAMLError2, Error1);
      var _super = _create_super10(YAMLError2);
      function YAMLError2(name, pos, code, message) {
        _class_call_check15(this, YAMLError2);
        var _this;
        return _this = _super.call(this), _this.name = name, _this.code = code, _this.message = message, _this.pos = pos, _this;
      }
      return YAMLError2;
    }(_wrap_native_super4(Error)), YAMLParseError = /* @__PURE__ */ function(YAMLError2) {
      _inherits10(YAMLParseError2, YAMLError2);
      var _super = _create_super10(YAMLParseError2);
      function YAMLParseError2(pos, code, message) {
        return _class_call_check15(this, YAMLParseError2), _super.call(this, "YAMLParseError", pos, code, message);
      }
      return YAMLParseError2;
    }(YAMLError), YAMLWarning = /* @__PURE__ */ function(YAMLError2) {
      _inherits10(YAMLWarning2, YAMLError2);
      var _super = _create_super10(YAMLWarning2);
      function YAMLWarning2(pos, code, message) {
        return _class_call_check15(this, YAMLWarning2), _super.call(this, "YAMLWarning", pos, code, message);
      }
      return YAMLWarning2;
    }(YAMLError), prettifyError = function(src, lc) {
      return function(error) {
        if (error.pos[0] !== -1) {
          error.linePos = error.pos.map(function(pos) {
            return lc.linePos(pos);
          });
          var _error_linePos_ = error.linePos[0], line = _error_linePos_.line, col = _error_linePos_.col;
          error.message += " at line ".concat(line, ", column ").concat(col);
          var ci = col - 1, lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
          if (ci >= 60 && lineStr.length > 80) {
            var trimStart = Math.min(ci - 39, lineStr.length - 79);
            lineStr = "\u2026" + lineStr.substring(trimStart), ci -= trimStart - 1;
          }
          if (lineStr.length > 80 && (lineStr = lineStr.substring(0, 79) + "\u2026"), line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
            var prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
            prev.length > 80 && (prev = prev.substring(0, 79) + `\u2026
`), lineStr = prev + lineStr;
          }
          if (/[^ ]/.test(lineStr)) {
            var count = 1, end = error.linePos[1];
            end && end.line === line && end.col > col && (count = Math.max(1, Math.min(end.col - col, 80 - ci)));
            var pointer = " ".repeat(ci) + "^".repeat(count);
            error.message += `:

`.concat(lineStr, `
`).concat(pointer, `
`);
          }
        }
      };
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, param) {
      var flow = param.flow, indicator = param.indicator, next = param.next, offset = param.offset, onError = param.onError, startOnNewline = param.startOnNewline, spaceBefore = !1, atNewline = startOnNewline, hasSpace = startOnNewline, comment = "", commentSep = "", hasNewline = !1, hasNewlineAfterProp = !1, reqSpace = !1, anchor = null, tag = null, comma = null, found = null, start = null, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var token = _step.value;
          switch (reqSpace && (token.type !== "space" && token.type !== "newline" && token.type !== "comma" && onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), reqSpace = !1), token.type) {
            case "space":
              !flow && atNewline && indicator !== "doc-start" && token.source[0] === "	" && onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), hasSpace = !0;
              break;
            case "comment": {
              hasSpace || onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              var cb = token.source.substring(1) || " ";
              comment ? comment += commentSep + cb : comment = cb, commentSep = "", atNewline = !1;
              break;
            }
            case "newline":
              atNewline ? comment ? comment += token.source : spaceBefore = !0 : commentSep += token.source, atNewline = !0, hasNewline = !0, (anchor || tag) && (hasNewlineAfterProp = !0), hasSpace = !0;
              break;
            case "anchor":
              anchor && onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), token.source.endsWith(":") && onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), anchor = token, start === null && (start = token.offset), atNewline = !1, hasSpace = !1, reqSpace = !0;
              break;
            case "tag": {
              tag && onError(token, "MULTIPLE_TAGS", "A node can have at most one tag"), tag = token, start === null && (start = token.offset), atNewline = !1, hasSpace = !1, reqSpace = !0;
              break;
            }
            case indicator:
              (anchor || tag) && onError(token, "BAD_PROP_ORDER", "Anchors and tags must be after the ".concat(token.source, " indicator")), found && onError(token, "UNEXPECTED_TOKEN", "Unexpected ".concat(token.source, " in ").concat(flow ?? "collection")), found = token, atNewline = !1, hasSpace = !1;
              break;
            case "comma":
              if (flow) {
                comma && onError(token, "UNEXPECTED_TOKEN", "Unexpected , in ".concat(flow)), comma = token, atNewline = !1, hasSpace = !1;
                break;
              }
            default:
              onError(token, "UNEXPECTED_TOKEN", "Unexpected ".concat(token.type, " token")), atNewline = !1, hasSpace = !1;
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      var last = tokens[tokens.length - 1], end = last ? last.offset + last.source.length : offset;
      return reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "") && onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// ../../node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../../node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes(`
`))
            return !0;
          if (key.end) {
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = key.end[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var st = _step.value;
                if (st.type === "newline")
                  return !0;
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
          }
          return !1;
        case "flow-collection":
          var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = key.items[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var it = _step1.value, _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
              try {
                for (var _iterator2 = it.start[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
                  var st1 = _step2.value;
                  if (st1.type === "newline")
                    return !0;
                }
              } catch (err) {
                _didIteratorError22 = !0, _iteratorError22 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
                } finally {
                  if (_didIteratorError22)
                    throw _iteratorError22;
                }
              }
              if (it.sep) {
                var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
                try {
                  for (var _iterator3 = it.sep[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
                    var st2 = _step3.value;
                    if (st2.type === "newline")
                      return !0;
                  }
                } catch (err) {
                  _didIteratorError3 = !0, _iteratorError3 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
                  } finally {
                    if (_didIteratorError3)
                      throw _iteratorError3;
                  }
                }
              }
              if (containsNewline(it.key) || containsNewline(it.value))
                return !0;
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
          return !1;
        default:
          return !0;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// ../../node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "../../node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if ((fc == null ? void 0 : fc.type) === "flow-collection") {
        var end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          var msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, !0);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// ../../node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../../node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      var uniqueKeys = ctx.options.uniqueKeys;
      if (uniqueKeys === !1)
        return !1;
      var isEqual = typeof uniqueKeys == "function" ? uniqueKeys : function(a, b) {
        return a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
      };
      return items.some(function(pair) {
        return isEqual(pair.key, search);
      });
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair(), YAMLMap = require_YAMLMap(), resolveProps = require_resolve_props(), utilContainsNewline = require_util_contains_newline(), utilFlowIndentCheck = require_util_flow_indent_check(), utilMapIncludes = require_util_map_includes(), startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap(param, ctx, bm, onError, tag) {
      var composeNode = param.composeNode, composeEmptyNode = param.composeEmptyNode, _tag_nodeClass, NodeClass = (_tag_nodeClass = tag == null ? void 0 : tag.nodeClass) !== null && _tag_nodeClass !== void 0 ? _tag_nodeClass : YAMLMap.YAMLMap, map = new NodeClass(ctx.schema);
      ctx.atRoot && (ctx.atRoot = !1);
      var offset = bm.offset, commentEnd = null, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = bm.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var collItem = _step.value, _keyProps_found, start = collItem.start, key = collItem.key, sep2 = collItem.sep, value = collItem.value, keyProps = resolveProps.resolveProps(start, {
            indicator: "explicit-key-ind",
            next: key ?? (sep2 == null ? void 0 : sep2[0]),
            offset,
            onError,
            startOnNewline: !0
          }), implicitKey = !keyProps.found;
          if (implicitKey) {
            if (key && (key.type === "block-seq" ? onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in key && key.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg)), !keyProps.anchor && !keyProps.tag && !sep2) {
              commentEnd = keyProps.end, keyProps.comment && (map.comment ? map.comment += `
` + keyProps.comment : map.comment = keyProps.comment);
              continue;
            }
            (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) && onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          } else
            ((_keyProps_found = keyProps.found) === null || _keyProps_found === void 0 ? void 0 : _keyProps_found.indent) !== bm.indent && onError(offset, "BAD_INDENT", startColMsg);
          var keyStart = keyProps.end, keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
          ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError), utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          var valueProps = resolveProps.resolveProps(sep2 ?? [], {
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !key || key.type === "block-scalar"
          });
          if (offset = valueProps.end, valueProps.found) {
            implicitKey && ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline && onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), ctx.options.strict && keyProps.start < valueProps.found.offset - 1024 && onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
            var valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep2, null, valueProps, onError);
            ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError), offset = valueNode.range[2];
            var pair = new Pair.Pair(keyNode, valueNode);
            ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
          } else {
            implicitKey && onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), valueProps.comment && (keyNode.comment ? keyNode.comment += `
` + valueProps.comment : keyNode.comment = valueProps.comment);
            var pair1 = new Pair.Pair(keyNode);
            ctx.options.keepSourceTokens && (pair1.srcToken = collItem), map.items.push(pair1);
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return commentEnd && commentEnd < offset && onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content"), map.range = [
        bm.offset,
        offset,
        commentEnd ?? offset
      ], map;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq(), resolveProps = require_resolve_props(), utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq(param, ctx, bs, onError, tag) {
      var composeNode = param.composeNode, composeEmptyNode = param.composeEmptyNode, _tag_nodeClass, NodeClass = (_tag_nodeClass = tag == null ? void 0 : tag.nodeClass) !== null && _tag_nodeClass !== void 0 ? _tag_nodeClass : YAMLSeq.YAMLSeq, seq = new NodeClass(ctx.schema);
      ctx.atRoot && (ctx.atRoot = !1);
      var offset = bs.offset, commentEnd = null, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = bs.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _step_value = _step.value, start = _step_value.start, value = _step_value.value, props = resolveProps.resolveProps(start, {
            indicator: "seq-item-ind",
            next: value,
            offset,
            onError,
            startOnNewline: !0
          });
          if (!props.found)
            if (props.anchor || props.tag || value)
              value && value.type === "block-seq" ? onError(props.end, "BAD_INDENT", "All sequence items must start at the same column") : onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
            else {
              commentEnd = props.end, props.comment && (seq.comment = props.comment);
              continue;
            }
          var node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
          ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError), offset = node.range[2], seq.items.push(node);
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return seq.range = [
        bs.offset,
        offset,
        commentEnd ?? offset
      ], seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      var comment = "";
      if (end) {
        var hasSpace = !1, sep2 = "", _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = end[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var token = _step.value, source = token.source, type = token.type;
            switch (type) {
              case "space":
                hasSpace = !0;
                break;
              case "comment": {
                reqSpace && !hasSpace && onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                var cb = source.substring(1) || " ";
                comment ? comment += sep2 + cb : comment = cb, sep2 = "";
                break;
              }
              case "newline":
                comment && (sep2 += source), hasSpace = !0;
                break;
              default:
                onError(token, "UNEXPECTED_TOKEN", "Unexpected ".concat(type, " at node end"));
            }
            offset += source.length;
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
      return {
        comment,
        offset
      };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_array2(arr) {
      return _array_with_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var identity = require_identity(), Pair = require_Pair(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), resolveEnd = require_resolve_end(), resolveProps = require_resolve_props(), utilContainsNewline = require_util_contains_newline(), utilMapIncludes = require_util_map_includes(), blockMsg = "Block collections are not allowed within flow collections", isBlock = function(token) {
      return token && (token.type === "block-map" || token.type === "block-seq");
    };
    function resolveFlowCollection(param, ctx, fc, onError, tag) {
      var composeNode = param.composeNode, composeEmptyNode = param.composeEmptyNode, isMap = fc.start.source === "{", fcName = isMap ? "flow map" : "flow sequence", _tag_nodeClass, NodeClass = (_tag_nodeClass = tag == null ? void 0 : tag.nodeClass) !== null && _tag_nodeClass !== void 0 ? _tag_nodeClass : isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq, coll = new NodeClass(ctx.schema);
      coll.flow = !0;
      var atRoot = ctx.atRoot;
      atRoot && (ctx.atRoot = !1);
      for (var offset = fc.offset + fc.start.source.length, i = 0; i < fc.items.length; ++i) {
        var collItem = fc.items[i], start = collItem.start, key = collItem.key, sep2 = collItem.sep, value = collItem.value, props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? (sep2 == null ? void 0 : sep2[0]),
          offset,
          onError,
          startOnNewline: !1
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep2 && !value) {
            i === 0 && props.comma ? onError(props.comma, "UNEXPECTED_TOKEN", "Unexpected , in ".concat(fcName)) : i < fc.items.length - 1 && onError(props.start, "UNEXPECTED_TOKEN", "Unexpected empty item in ".concat(fcName)), props.comment && (coll.comment ? coll.comment += `
` + props.comment : coll.comment = props.comment), offset = props.end;
            continue;
          }
          !isMap && ctx.options.strict && utilContainsNewline.containsNewline(key) && onError(
            key,
            // checked by containsNewline()
            "MULTILINE_IMPLICIT_KEY",
            "Implicit keys of flow sequence pairs need to be on a single line"
          );
        }
        if (i === 0)
          props.comma && onError(props.comma, "UNEXPECTED_TOKEN", "Unexpected , in ".concat(fcName));
        else if (props.comma || onError(props.start, "MISSING_CHAR", "Missing , between ".concat(fcName, " items")), props.comment) {
          var prevItemComment = "", _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            loop:
              for (var _iterator = start[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var st = _step.value;
                switch (st.type) {
                  case "comma":
                  case "space":
                    break;
                  case "comment":
                    prevItemComment = st.source.substring(1);
                    break loop;
                  default:
                    break loop;
                }
              }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          if (prevItemComment) {
            var prev = coll.items[coll.items.length - 1], _prev_value;
            identity.isPair(prev) && (prev = (_prev_value = prev.value) !== null && _prev_value !== void 0 ? _prev_value : prev.key), prev.comment ? prev.comment += `
` + prevItemComment : prev.comment = prevItemComment, props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
        if (!isMap && !sep2 && !props.found) {
          var valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep2, null, props, onError);
          coll.items.push(valueNode), offset = valueNode.range[2], isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          var keyStart = props.end, keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          isBlock(key) && onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          var valueProps = resolveProps.resolveProps(sep2 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !1
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
              if (sep2)
                try {
                  for (var _iterator1 = sep2[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                    var st1 = _step1.value;
                    if (st1 === valueProps.found)
                      break;
                    if (st1.type === "newline") {
                      onError(st1, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                      break;
                    }
                  }
                } catch (err) {
                  _didIteratorError12 = !0, _iteratorError12 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
                  } finally {
                    if (_didIteratorError12)
                      throw _iteratorError12;
                  }
                }
              props.start < valueProps.found.offset - 1024 && onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else
            value && ("source" in value && value.source && value.source[0] === ":" ? onError(value, "MISSING_CHAR", "Missing space after : in ".concat(fcName)) : onError(valueProps.start, "MISSING_CHAR", "Missing , or : between ".concat(fcName, " items")));
          var valueNode1 = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
          valueNode1 ? isBlock(value) && onError(valueNode1.range, "BLOCK_IN_FLOW", blockMsg) : valueProps.comment && (keyNode.comment ? keyNode.comment += `
` + valueProps.comment : keyNode.comment = valueProps.comment);
          var pair = new Pair.Pair(keyNode, valueNode1);
          if (ctx.options.keepSourceTokens && (pair.srcToken = collItem), isMap) {
            var map = coll;
            utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique"), map.items.push(pair);
          } else {
            var map1 = new YAMLMap.YAMLMap(ctx.schema);
            map1.flow = !0, map1.items.push(pair), coll.items.push(map1);
          }
          offset = valueNode1 ? valueNode1.range[2] : valueProps.end;
        }
      }
      var expectedEnd = isMap ? "}" : "]", _fc_end = _to_array2(fc.end), ce = _fc_end[0], ee = _fc_end.slice(1), cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        var name = fcName[0].toUpperCase() + fcName.substring(1), msg = atRoot ? "".concat(name, " must end with a ").concat(expectedEnd) : "".concat(name, " in block collection must be sufficiently indented and end with a ").concat(expectedEnd);
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg), ce && ce.source.length !== 1 && ee.unshift(ce);
      }
      if (ee.length > 0) {
        var end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        end.comment && (coll.comment ? coll.comment += `
` + end.comment : coll.comment = end.comment), coll.range = [
          fc.offset,
          cePos,
          end.offset
        ];
      } else
        coll.range = [
          fc.offset,
          cePos,
          cePos
        ];
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../../node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity(), Scalar = require_Scalar(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), resolveBlockMap = require_resolve_block_map(), resolveBlockSeq = require_resolve_block_seq(), resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      var coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag), Coll = coll.constructor;
      return tagName === "!" || tagName === Coll.tagName ? (coll.tag = Coll.tagName, coll) : (tagName && (coll.tag = tagName), coll);
    }
    function composeCollection(CN, ctx, token, tagToken, onError) {
      var _tag_resolve, tagName = tagToken ? ctx.directives.tagName(tagToken.source, function(msg) {
        return onError(tagToken, "TAG_RESOLVE_FAILED", msg);
      }) : null, expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq" || !expType)
        return resolveCollection(CN, ctx, token, onError, tagName);
      var tag = ctx.schema.tags.find(function(t) {
        return t.tag === tagName && t.collection === expType;
      });
      if (!tag) {
        var kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType)
          ctx.schema.tags.push(Object.assign({}, kt, {
            default: !1
          })), tag = kt;
        else
          return kt != null && kt.collection ? onError(tagToken, "BAD_COLLECTION_TYPE", "".concat(kt.tag, " used for ").concat(expType, " collection, but expects ").concat(kt.collection), !0) : onError(tagToken, "TAG_RESOLVE_FAILED", "Unresolved tag: ".concat(tagName), !0), resolveCollection(CN, ctx, token, onError, tagName);
      }
      var coll = resolveCollection(CN, ctx, token, onError, tagName, tag), _tag_resolve1, res = (_tag_resolve1 = (_tag_resolve = tag.resolve) === null || _tag_resolve === void 0 ? void 0 : _tag_resolve.call(tag, coll, function(msg) {
        return onError(tagToken, "TAG_RESOLVE_FAILED", msg);
      }, ctx.options)) !== null && _tag_resolve1 !== void 0 ? _tag_resolve1 : coll, node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      return node.range = coll.range, node.tag = tagName, tag != null && tag.format && (node.format = tag.format), node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var Scalar = require_Scalar();
    function resolveBlockScalar(scalar, strict, onError) {
      var start = scalar.offset, header = parseBlockScalarHeader(scalar, strict, onError);
      if (!header)
        return {
          value: "",
          type: null,
          comment: "",
          range: [
            start,
            start,
            start
          ]
        };
      for (var type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL, lines = scalar.source ? splitLines(scalar.source) : [], chompStart = lines.length, i = lines.length - 1; i >= 0; --i) {
        var content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        var value = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "", end = start + header.length;
        return scalar.source && (end += scalar.source.length), {
          value,
          type,
          comment: header.comment,
          range: [
            start,
            end,
            end
          ]
        };
      }
      for (var trimIndent = scalar.indent + header.indent, offset = scalar.offset + header.length, contentStart = 0, i1 = 0; i1 < chompStart; ++i1) {
        var _lines_i = _sliced_to_array15(lines[i1], 2), indent = _lines_i[0], content1 = _lines_i[1];
        if (content1 === "" || content1 === "\r")
          header.indent === 0 && indent.length > trimIndent && (trimIndent = indent.length);
        else {
          if (indent.length < trimIndent) {
            var message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          header.indent === 0 && (trimIndent = indent.length), contentStart = i1;
          break;
        }
        offset += indent.length + content1.length + 1;
      }
      for (var i2 = lines.length - 1; i2 >= chompStart; --i2)
        lines[i2][0].length > trimIndent && (chompStart = i2 + 1);
      for (var value1 = "", sep2 = "", prevMoreIndented = !1, i3 = 0; i3 < contentStart; ++i3)
        value1 += lines[i3][0].slice(trimIndent) + `
`;
      for (var i4 = contentStart; i4 < chompStart; ++i4) {
        var _lines_i1 = _sliced_to_array15(lines[i4], 2), indent1 = _lines_i1[0], content2 = _lines_i1[1];
        offset += indent1.length + content2.length + 1;
        var crlf = content2[content2.length - 1] === "\r";
        if (crlf && (content2 = content2.slice(0, -1)), content2 && indent1.length < trimIndent) {
          var src = header.indent ? "explicit indentation indicator" : "first line", message1 = "Block scalar lines must not be less indented than their ".concat(src);
          onError(offset - content2.length - (crlf ? 2 : 1), "BAD_INDENT", message1), indent1 = "";
        }
        type === Scalar.Scalar.BLOCK_LITERAL ? (value1 += sep2 + indent1.slice(trimIndent) + content2, sep2 = `
`) : indent1.length > trimIndent || content2[0] === "	" ? (sep2 === " " ? sep2 = `
` : !prevMoreIndented && sep2 === `
` && (sep2 = `

`), value1 += sep2 + indent1.slice(trimIndent) + content2, sep2 = `
`, prevMoreIndented = !0) : content2 === "" ? sep2 === `
` ? value1 += `
` : sep2 = `
` : (value1 += sep2 + content2, sep2 = " ", prevMoreIndented = !1);
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (var i5 = chompStart; i5 < lines.length; ++i5)
            value1 += `
` + lines[i5][0].slice(trimIndent);
          value1[value1.length - 1] !== `
` && (value1 += `
`);
          break;
        default:
          value1 += `
`;
      }
      var end1 = start + header.length + scalar.source.length;
      return {
        value: value1,
        type,
        comment: header.comment,
        range: [
          start,
          end1,
          end1
        ]
      };
    }
    function parseBlockScalarHeader(param, strict, onError) {
      var offset = param.offset, props = param.props;
      if (props[0].type !== "block-scalar-header")
        return onError(props[0], "IMPOSSIBLE", "Block scalar header not found"), null;
      for (var source = props[0].source, mode = source[0], indent = 0, chomp = "", error = -1, i = 1; i < source.length; ++i) {
        var ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          var n = Number(ch);
          !indent && n ? indent = n : error === -1 && (error = offset + i);
        }
      }
      error !== -1 && onError(error, "UNEXPECTED_TOKEN", "Block scalar header includes extra characters: ".concat(source));
      for (var hasSpace = !1, comment = "", length = source.length, i1 = 1; i1 < props.length; ++i1) {
        var token = props[i1];
        switch (token.type) {
          case "space":
            hasSpace = !0;
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              var message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length, comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message), length += token.source.length;
            break;
          default: {
            var message1 = "Unexpected token in block scalar header: ".concat(token.type);
            onError(token, "UNEXPECTED_TOKEN", message1);
            var ts = token.source;
            ts && typeof ts == "string" && (length += ts.length);
          }
        }
      }
      return {
        mode,
        indent,
        chomp,
        comment,
        length
      };
    }
    function splitLines(source) {
      for (var split = source.split(/\n( *)/), first = split[0], m = first.match(/^( *)/), line0 = m != null && m[1] ? [
        m[1],
        first.slice(m[1].length)
      ] : [
        "",
        first
      ], lines = [
        line0
      ], i = 1; i < split.length; i += 2)
        lines.push([
          split[i],
          split[i + 1]
        ]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      var offset = scalar.offset, type = scalar.type, source = scalar.source, end = scalar.end, _type2, value, _onError = function(rel, code, msg) {
        return onError(offset + rel, code, msg);
      };
      switch (type) {
        case "scalar":
          _type2 = Scalar.Scalar.PLAIN, value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type2 = Scalar.Scalar.QUOTE_SINGLE, value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type2 = Scalar.Scalar.QUOTE_DOUBLE, value = doubleQuotedValue(source, _onError);
          break;
        default:
          return onError(scalar, "UNEXPECTED_TOKEN", "Expected a flow scalar value, but found: ".concat(type)), {
            value: "",
            type: null,
            comment: "",
            range: [
              offset,
              offset + source.length,
              offset + source.length
            ]
          };
      }
      var valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type2,
        comment: re.comment,
        range: [
          offset,
          valueEnd,
          re.offset
        ]
      };
    }
    function plainValue(source, onError) {
      var badChar = "";
      switch (source[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = "block scalar indicator ".concat(source[0]);
          break;
        }
        case "@":
        case "`": {
          badChar = "reserved character ".concat(source[0]);
          break;
        }
      }
      return badChar && onError(0, "BAD_SCALAR_START", "Plain value cannot start with ".concat(badChar)), foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      return (source[source.length - 1] !== "'" || source.length === 1) && onError(source.length, "MISSING_CHAR", "Missing closing 'quote"), foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      var first, line;
      try {
        first = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
      } catch {
        first = RegExp("(.*?)[ \\t]*\\r?\\n", "sy"), line = RegExp("[ \\t]*(.*?)[ \\t]*\\r?\\n", "sy");
      }
      var match2 = first.exec(source);
      if (!match2)
        return source;
      var res = match2[1], sep2 = " ", pos = first.lastIndex;
      for (line.lastIndex = pos; match2 = line.exec(source); )
        match2[1] === "" ? sep2 === `
` ? res += sep2 : sep2 = `
` : (res += sep2 + match2[1], sep2 = " "), pos = line.lastIndex;
      var last = RegExp("[ \\t]*(.*)", "sy");
      last.lastIndex = pos, match2 = last.exec(source);
      var _match_;
      return res + sep2 + ((_match_ = match2 == null ? void 0 : match2[1]) !== null && _match_ !== void 0 ? _match_ : "");
    }
    function doubleQuotedValue(source, onError) {
      for (var res = "", i = 1; i < source.length - 1; ++i) {
        var ch = source[i];
        if (!(ch === "\r" && source[i + 1] === `
`))
          if (ch === `
`) {
            var _foldNewline = foldNewline(source, i), fold = _foldNewline.fold, offset = _foldNewline.offset;
            res += fold, i = offset;
          } else if (ch === "\\") {
            var next = source[++i], cc = escapeCodes[next];
            if (cc)
              res += cc;
            else if (next === `
`)
              for (next = source[i + 1]; next === " " || next === "	"; )
                next = source[++i + 1];
            else if (next === "\r" && source[i + 1] === `
`)
              for (next = source[++i + 1]; next === " " || next === "	"; )
                next = source[++i + 1];
            else if (next === "x" || next === "u" || next === "U") {
              var length = {
                x: 2,
                u: 4,
                U: 8
              }[next];
              res += parseCharCode(source, i + 1, length, onError), i += length;
            } else {
              var raw = source.substr(i - 1, 2);
              onError(i - 1, "BAD_DQ_ESCAPE", "Invalid escape sequence ".concat(raw)), res += raw;
            }
          } else if (ch === " " || ch === "	") {
            for (var wsStart = i, next1 = source[i + 1]; next1 === " " || next1 === "	"; )
              next1 = source[++i + 1];
            next1 !== `
` && !(next1 === "\r" && source[i + 2] === `
`) && (res += i > wsStart ? source.slice(wsStart, i + 1) : ch);
          } else
            res += ch;
      }
      return (source[source.length - 1] !== '"' || source.length === 1) && onError(source.length, "MISSING_CHAR", 'Missing closing "quote'), res;
    }
    function foldNewline(source, offset) {
      for (var fold = "", ch = source[offset + 1]; (ch === " " || ch === "	" || ch === `
` || ch === "\r") && !(ch === "\r" && source[offset + 2] !== `
`); )
        ch === `
` && (fold += `
`), offset += 1, ch = source[offset + 1];
      return fold || (fold = " "), {
        fold,
        offset
      };
    }
    var escapeCodes = {
      0: "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: `
`,
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      var cc = source.substr(offset, length), ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc), code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        var raw = source.substr(offset - 2, length + 2);
        return onError(offset - 2, "BAD_DQ_ESCAPE", "Invalid escape sequence ".concat(raw)), raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../../node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var identity = require_identity(), Scalar = require_Scalar(), resolveBlockScalar = require_resolve_block_scalar(), resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      var _ref = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError), value = _ref.value, type = _ref.type, comment = _ref.comment, range = _ref.range, tagName = tagToken ? ctx.directives.tagName(tagToken.source, function(msg2) {
        return onError(tagToken, "TAG_RESOLVE_FAILED", msg2);
      }) : null, tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[identity.SCALAR], scalar;
      try {
        var res = tag.resolve(value, function(msg2) {
          return onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg2);
        }, ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        var msg = _instanceof13(error, Error) ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), scalar = new Scalar.Scalar(value);
      }
      return scalar.range = range, scalar.source = value, type && (scalar.type = type), tagName && (scalar.tag = tagName), tag.format && (scalar.format = tag.format), comment && (scalar.comment = comment), scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      var _tag_test;
      if (tagName === "!")
        return schema[identity.SCALAR];
      var matchWithTest = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = schema.tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var tag = _step.value;
          if (!tag.collection && tag.tag === tagName)
            if (tag.default && tag.test)
              matchWithTest.push(tag);
            else
              return tag;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
      try {
        for (var _iterator1 = matchWithTest[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
          var tag1 = _step1.value;
          if (!((_tag_test = tag1.test) === null || _tag_test === void 0) && _tag_test.test(value))
            return tag1;
        }
      } catch (err) {
        _didIteratorError12 = !0, _iteratorError12 = err;
      } finally {
        try {
          !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError12)
            throw _iteratorError12;
        }
      }
      var kt = schema.knownTags[tagName];
      return kt && !kt.collection ? (schema.tags.push(Object.assign({}, kt, {
        default: !1,
        test: void 0
      })), kt) : (onError(tagToken, "TAG_RESOLVE_FAILED", "Unresolved tag: ".concat(tagName), tagName !== "tag:yaml.org,2002:str"), schema[identity.SCALAR]);
    }
    function findScalarTagByTest(param, value, token, onError) {
      var directives = param.directives, schema = param.schema, tag = schema.tags.find(function(tag2) {
        var _tag_test;
        return tag2.default && ((_tag_test = tag2.test) === null || _tag_test === void 0 ? void 0 : _tag_test.test(value));
      }) || schema[identity.SCALAR];
      if (schema.compat) {
        var _schema_compat_find, compat = (_schema_compat_find = schema.compat.find(function(tag2) {
          var _tag_test;
          return tag2.default && ((_tag_test = tag2.test) === null || _tag_test === void 0 ? void 0 : _tag_test.test(value));
        })) !== null && _schema_compat_find !== void 0 ? _schema_compat_find : schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          var ts = directives.tagString(tag.tag), cs = directives.tagString(compat.tag), msg = "Value may be parsed as either ".concat(ts, " or ").concat(cs);
          onError(token, "TAG_RESOLVE_FAILED", msg, !0);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// ../../node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../../node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos === null && (pos = before.length);
        for (var i = pos - 1; i >= 0; --i) {
          var st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          for (st = before[++i]; (st == null ? void 0 : st.type) === "space"; )
            offset += st.source.length, st = before[++i];
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../../node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias(), composeCollection = require_compose_collection(), composeScalar = require_compose_scalar(), resolveEnd = require_resolve_end(), utilEmptyScalarPosition = require_util_empty_scalar_position(), CN = {
      composeNode,
      composeEmptyNode
    };
    function composeNode(ctx, token, props, onError) {
      var spaceBefore = props.spaceBefore, comment = props.comment, anchor = props.anchor, tag = props.tag, node, isSrcToken = !0;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError), (anchor || tag) && onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
          break;
        default: {
          var message = token.type === "error" ? token.message : "Unsupported token (type: ".concat(token.type, ")");
          onError(token, "UNEXPECTED_TOKEN", message), node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError), isSrcToken = !1;
        }
      }
      return anchor && node.anchor === "" && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string"), spaceBefore && (node.spaceBefore = !0), comment && (token.type === "scalar" && token.source === "" ? node.comment = comment : node.commentBefore = comment), ctx.options.keepSourceTokens && isSrcToken && (node.srcToken = token), node;
    }
    function composeEmptyNode(ctx, offset, before, pos, param, onError) {
      var spaceBefore = param.spaceBefore, comment = param.comment, anchor = param.anchor, tag = param.tag, end = param.end, token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      }, node = composeScalar.composeScalar(ctx, token, tag, onError);
      return anchor && (node.anchor = anchor.source.substring(1), node.anchor === "" && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string")), spaceBefore && (node.spaceBefore = !0), comment && (node.comment = comment, node.range[2] = end), node;
    }
    function composeAlias(param, param1, onError) {
      var options = param.options, offset = param1.offset, source = param1.source, end = param1.end, alias = new Alias.Alias(source.substring(1));
      alias.source === "" && onError(offset, "BAD_ALIAS", "Alias cannot be an empty string"), alias.source.endsWith(":") && onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
      var valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      return alias.range = [
        offset,
        valueEnd,
        re.offset
      ], re.comment && (alias.comment = re.comment), alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// ../../node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document(), composeNode = require_compose_node(), resolveEnd = require_resolve_end(), resolveProps = require_resolve_props();
    function composeDoc(options, directives, param, onError) {
      var offset = param.offset, start = param.start, value = param.value, end = param.end, opts = Object.assign({
        _directives: directives
      }, options), doc = new Document.Document(void 0, opts), ctx = {
        atRoot: !0,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      }, props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? (end == null ? void 0 : end[0]),
        offset,
        onError,
        startOnNewline: !0
      });
      props.found && (doc.directives.docStart = !0, value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline && onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      var contentEnd = doc.contents.range[2], re = resolveEnd.resolveEnd(end, contentEnd, !1, onError);
      return re.comment && (doc.comment = re.comment), doc.range = [
        offset,
        contentEnd,
        re.offset
      ], doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// ../../node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../../node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function _ts_values(o) {
      var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length == "number")
        return {
          next: function() {
            return o && i >= o.length && (o = void 0), {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    var directives = require_directives(), Document = require_Document(), errors = require_errors(), identity = require_identity(), composeDoc = require_compose_doc(), resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src == "number")
        return [
          src,
          src + 1
        ];
      if (Array.isArray(src))
        return src.length === 2 ? src : [
          src[0],
          src[1]
        ];
      var offset = src.offset, source = src.source;
      return [
        offset,
        offset + (typeof source == "string" ? source.length : 1)
      ];
    }
    function parsePrelude(prelude) {
      for (var comment = "", atComment = !1, afterEmptyLine = !1, i = 0; i < prelude.length; ++i) {
        var source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " "), atComment = !0, afterEmptyLine = !1;
            break;
          case "%":
            var _prelude_;
            ((_prelude_ = prelude[i + 1]) === null || _prelude_ === void 0 ? void 0 : _prelude_[0]) !== "#" && (i += 1), atComment = !1;
            break;
          default:
            atComment || (afterEmptyLine = !0), atComment = !1;
        }
      }
      return {
        comment,
        afterEmptyLine
      };
    }
    var Composer = /* @__PURE__ */ function() {
      function Composer2() {
        var _this = this, options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, Composer2), this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = function(source, code, message, warning) {
          var pos = getErrorPos(source);
          warning ? _this.warnings.push(new errors.YAMLWarning(pos, code, message)) : _this.errors.push(new errors.YAMLParseError(pos, code, message));
        }, this.directives = new directives.Directives({
          version: options.version || "1.2"
        }), this.options = options;
      }
      return _create_class13(Composer2, [
        {
          key: "decorate",
          value: function(doc, afterDoc) {
            var _parsePrelude = parsePrelude(this.prelude), comment = _parsePrelude.comment, afterEmptyLine = _parsePrelude.afterEmptyLine;
            if (comment) {
              var dc = doc.contents;
              if (afterDoc)
                doc.comment = doc.comment ? "".concat(doc.comment, `
`).concat(comment) : comment;
              else if (afterEmptyLine || doc.directives.docStart || !dc)
                doc.commentBefore = comment;
              else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                var it = dc.items[0];
                identity.isPair(it) && (it = it.key);
                var cb = it.commentBefore;
                it.commentBefore = cb ? "".concat(comment, `
`).concat(cb) : comment;
              } else {
                var cb1 = dc.commentBefore;
                dc.commentBefore = cb1 ? "".concat(comment, `
`).concat(cb1) : comment;
              }
            }
            afterDoc ? (Array.prototype.push.apply(doc.errors, this.errors), Array.prototype.push.apply(doc.warnings, this.warnings)) : (doc.errors = this.errors, doc.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
          }
        },
        {
          /**
          * Current stream status information.
          *
          * Mostly useful at the end of input for an empty stream.
          */
          key: "streamInfo",
          value: function() {
            return {
              comment: parsePrelude(this.prelude).comment,
              directives: this.directives,
              errors: this.errors,
              warnings: this.warnings
            };
          }
        },
        {
          key: "compose",
          value: (
            /**
            * Compose tokens into documents.
            *
            * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
            * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
            */
            function(tokens) {
              var forceDoc, endOffset, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, token, err, _arguments = arguments;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    forceDoc = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : !1, endOffset = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : -1, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
                  case 1:
                    _state.trys.push([
                      1,
                      6,
                      7,
                      8
                    ]), _iterator = tokens[Symbol.iterator](), _state.label = 2;
                  case 2:
                    return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                      3,
                      5
                    ] : (token = _step.value, [
                      5,
                      _ts_values(this.next(token))
                    ]);
                  case 3:
                    _state.sent(), _state.label = 4;
                  case 4:
                    return _iteratorNormalCompletion2 = !0, [
                      3,
                      2
                    ];
                  case 5:
                    return [
                      3,
                      8
                    ];
                  case 6:
                    return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                      3,
                      8
                    ];
                  case 7:
                    try {
                      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                    } finally {
                      if (_didIteratorError2)
                        throw _iteratorError2;
                    }
                    return [
                      7
                    ];
                  case 8:
                    return [
                      5,
                      _ts_values(this.end(forceDoc, endOffset))
                    ];
                  case 9:
                    return _state.sent(), [
                      2
                    ];
                }
              });
            }
          )
        },
        {
          key: "next",
          value: (
            /** Advance the composer by one CST token. */
            function(token) {
              var _this, _, doc, msg, error, msg1, end, dc;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    switch (_this = this, process.env.LOG_STREAM && console.dir(token, {
                      depth: null
                    }), _ = token.type, _) {
                      case "directive":
                        return [
                          3,
                          1
                        ];
                      case "document":
                        return [
                          3,
                          2
                        ];
                      case "byte-order-mark":
                        return [
                          3,
                          5
                        ];
                      case "space":
                        return [
                          3,
                          5
                        ];
                      case "comment":
                        return [
                          3,
                          6
                        ];
                      case "newline":
                        return [
                          3,
                          6
                        ];
                      case "error":
                        return [
                          3,
                          7
                        ];
                      case "doc-end":
                        return [
                          3,
                          8
                        ];
                    }
                    return [
                      3,
                      9
                    ];
                  case 1:
                    return this.directives.add(token.source, function(offset, message, warning) {
                      var pos = getErrorPos(token);
                      pos[0] += offset, _this.onError(pos, "BAD_DIRECTIVE", message, warning);
                    }), this.prelude.push(token.source), this.atDirectives = !0, [
                      3,
                      10
                    ];
                  case 2:
                    return doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError), this.atDirectives && !doc.directives.docStart && this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(doc, !1), this.doc ? [
                      4,
                      this.doc
                    ] : [
                      3,
                      4
                    ];
                  case 3:
                    _state.sent(), _state.label = 4;
                  case 4:
                    return this.doc = doc, this.atDirectives = !1, [
                      3,
                      10
                    ];
                  case 5:
                    return [
                      3,
                      10
                    ];
                  case 6:
                    return this.prelude.push(token.source), [
                      3,
                      10
                    ];
                  case 7:
                    return msg = token.source ? "".concat(token.message, ": ").concat(JSON.stringify(token.source)) : token.message, error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg), this.atDirectives || !this.doc ? this.errors.push(error) : this.doc.errors.push(error), [
                      3,
                      10
                    ];
                  case 8:
                    return this.doc ? (this.doc.directives.docEnd = !0, end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError), this.decorate(this.doc, !0), end.comment && (dc = this.doc.comment, this.doc.comment = dc ? "".concat(dc, `
`).concat(end.comment) : end.comment), this.doc.range[2] = end.offset, [
                      3,
                      10
                    ]) : (msg1 = "Unexpected doc-end without preceding document", this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg1)), [
                      3,
                      10
                    ]);
                  case 9:
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", "Unsupported token ".concat(token.type))), _state.label = 10;
                  case 10:
                    return [
                      2
                    ];
                }
              });
            }
          )
        },
        {
          key: "end",
          value: (
            /**
            * Call at end of input to yield any remaining document.
            *
            * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
            * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
            */
            function() {
              var forceDoc, endOffset, opts, doc, _arguments = arguments;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return forceDoc = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : !1, endOffset = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : -1, this.doc ? (this.decorate(this.doc, !0), [
                      4,
                      this.doc
                    ]) : [
                      3,
                      2
                    ];
                  case 1:
                    return _state.sent(), this.doc = null, [
                      3,
                      4
                    ];
                  case 2:
                    return forceDoc ? (opts = Object.assign({
                      _directives: this.directives
                    }, this.options), doc = new Document.Document(void 0, opts), this.atDirectives && this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line"), doc.range = [
                      0,
                      endOffset,
                      endOffset
                    ], this.decorate(doc, !1), [
                      4,
                      doc
                    ]) : [
                      3,
                      4
                    ];
                  case 3:
                    _state.sent(), _state.label = 4;
                  case 4:
                    return [
                      2
                    ];
                }
              });
            }
          )
        }
      ]), Composer2;
    }();
    exports2.Composer = Composer;
  }
});

// ../../node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar(), resolveFlowScalar = require_resolve_flow_scalar(), errors = require_errors(), stringifyString = require_stringifyString();
    function resolveAsScalar(token) {
      var strict = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, onError = arguments.length > 2 ? arguments[2] : void 0;
      if (token) {
        var _onError = function(pos, code, message) {
          var offset = typeof pos == "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([
              offset,
              offset + 1
            ], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      var _context_implicitKey = context.implicitKey, implicitKey = _context_implicitKey === void 0 ? !1 : _context_implicitKey, indent = context.indent, _context_inFlow = context.inFlow, inFlow = _context_inFlow === void 0 ? !1 : _context_inFlow, _context_offset = context.offset, offset = _context_offset === void 0 ? -1 : _context_offset, _context_type = context.type, type = _context_type === void 0 ? "PLAIN" : _context_type, source = stringifyString.stringifyString({
        type,
        value
      }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: {
          blockQuote: !0,
          lineWidth: -1
        }
      }), _context_end, end = (_context_end = context.end) !== null && _context_end !== void 0 ? _context_end : [
        {
          type: "newline",
          offset: -1,
          indent,
          source: `
`
        }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          var he = source.indexOf(`
`), head = source.substring(0, he), body = source.substring(he + 1) + `
`, props = [
            {
              type: "block-scalar-header",
              offset,
              indent,
              source: head
            }
          ];
          return addEndtoBlockProps(props, end) || props.push({
            type: "newline",
            offset: -1,
            indent,
            source: `
`
          }), {
            type: "block-scalar",
            offset,
            indent,
            props,
            source: body
          };
        }
        case '"':
          return {
            type: "double-quoted-scalar",
            offset,
            indent,
            source,
            end
          };
        case "'":
          return {
            type: "single-quoted-scalar",
            offset,
            indent,
            source,
            end
          };
        default:
          return {
            type: "scalar",
            offset,
            indent,
            source,
            end
          };
      }
    }
    function setScalarValue(token, value) {
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _context_afterKey = context.afterKey, afterKey = _context_afterKey === void 0 ? !1 : _context_afterKey, _context_implicitKey = context.implicitKey, implicitKey = _context_implicitKey === void 0 ? !1 : _context_implicitKey, _context_inFlow = context.inFlow, inFlow = _context_inFlow === void 0 ? !1 : _context_inFlow, type = context.type, indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent == "number" && (indent += 2), !type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            var header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      var source = stringifyString.stringifyString({
        type,
        value
      }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: {
          blockQuote: !0,
          lineWidth: -1
        }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      var he = source.indexOf(`
`), head = source.substring(0, he), body = source.substring(he + 1) + `
`;
      if (token.type === "block-scalar") {
        var header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head, token.source = body;
      } else {
        var offset = token.offset, indent = "indent" in token ? token.indent : -1, props = [
          {
            type: "block-scalar-header",
            offset,
            indent,
            source: head
          }
        ];
        addEndtoBlockProps(props, "end" in token ? token.end : void 0) || props.push({
          type: "newline",
          offset: -1,
          indent,
          source: `
`
        });
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = Object.keys(token)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var key = _step.value;
            key !== "type" && key !== "offset" && delete token[key];
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        Object.assign(token, {
          type: "block-scalar",
          indent,
          props,
          source: body
        });
      }
    }
    function addEndtoBlockProps(props, end) {
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      if (end)
        try {
          for (var _iterator = end[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var st = _step.value;
            switch (st.type) {
              case "space":
              case "comment":
                props.push(st);
                break;
              case "newline":
                return props.push(st), !0;
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      return !1;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type, token.source = source;
          break;
        case "block-scalar": {
          var end = token.props.slice(1), oa = source.length;
          token.props[0].type === "block-scalar-header" && (oa -= token.props[0].source.length);
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = end[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var tok = _step.value;
              tok.offset += oa;
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          delete token.props, Object.assign(token, {
            type,
            source,
            end
          });
          break;
        }
        case "block-map":
        case "block-seq": {
          var offset = token.offset + source.length, nl = {
            type: "newline",
            offset,
            indent: token.indent,
            source: `
`
          };
          delete token.items, Object.assign(token, {
            type,
            source,
            end: [
              nl
            ]
          });
          break;
        }
        default: {
          var indent = "indent" in token ? token.indent : -1, end1 = "end" in token && Array.isArray(token.end) ? token.end.filter(function(st) {
            return st.type === "space" || st.type === "comment" || st.type === "newline";
          }) : [], _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = Object.keys(token)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var key = _step1.value;
              key !== "type" && key !== "offset" && delete token[key];
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
          Object.assign(token, {
            type,
            indent,
            source,
            end: end1
          });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// ../../node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = function(cst) {
      return "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    };
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          var res = "", _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = token.props[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var tok = _step.value;
              res += stringifyToken(tok);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          var res1 = "", _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = token.items[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var item = _step1.value;
              res1 += stringifyItem(item);
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
          return res1;
        }
        case "flow-collection": {
          var res2 = token.start.source, _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
          try {
            for (var _iterator2 = token.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
              var item1 = _step2.value;
              res2 += stringifyItem(item1);
            }
          } catch (err) {
            _didIteratorError22 = !0, _iteratorError22 = err;
          } finally {
            try {
              !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
            } finally {
              if (_didIteratorError22)
                throw _iteratorError22;
            }
          }
          var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
          try {
            for (var _iterator3 = token.end[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
              var st = _step3.value;
              res2 += st.source;
            }
          } catch (err) {
            _didIteratorError3 = !0, _iteratorError3 = err;
          } finally {
            try {
              !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
            } finally {
              if (_didIteratorError3)
                throw _iteratorError3;
            }
          }
          return res2;
        }
        case "document": {
          var res3 = stringifyItem(token), _iteratorNormalCompletion4 = !0, _didIteratorError4 = !1, _iteratorError4 = void 0;
          if (token.end)
            try {
              for (var _iterator4 = token.end[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = !0) {
                var st1 = _step4.value;
                res3 += st1.source;
              }
            } catch (err) {
              _didIteratorError4 = !0, _iteratorError4 = err;
            } finally {
              try {
                !_iteratorNormalCompletion4 && _iterator4.return != null && _iterator4.return();
              } finally {
                if (_didIteratorError4)
                  throw _iteratorError4;
              }
            }
          return res3;
        }
        default: {
          var res4 = token.source, _iteratorNormalCompletion5 = !0, _didIteratorError5 = !1, _iteratorError5 = void 0;
          if ("end" in token && token.end)
            try {
              for (var _iterator5 = token.end[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = !0) {
                var st2 = _step5.value;
                res4 += st2.source;
              }
            } catch (err) {
              _didIteratorError5 = !0, _iteratorError5 = err;
            } finally {
              try {
                !_iteratorNormalCompletion5 && _iterator5.return != null && _iterator5.return();
              } finally {
                if (_didIteratorError5)
                  throw _iteratorError5;
              }
            }
          return res4;
        }
      }
    }
    function stringifyItem(param) {
      var start = param.start, key = param.key, sep2 = param.sep, value = param.value, res = "", _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = start[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var st = _step.value;
          res += st.source;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      key && (res += stringifyToken(key));
      var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
      if (sep2)
        try {
          for (var _iterator1 = sep2[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var st1 = _step1.value;
            res += st1.source;
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
      return value && (res += stringifyToken(value)), res;
    }
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      "type" in cst && cst.type === "document" && (cst = {
        start: cst.start,
        value: cst.value
      }), _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = function(cst, path6) {
      var item = cst, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = path6[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _step_value = _sliced_to_array15(_step.value, 2), field = _step_value[0], index = _step_value[1], tok = item == null ? void 0 : item[field];
          if (tok && "items" in tok)
            item = tok.items[index];
          else
            return;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return item;
    };
    visit.parentCollection = function(cst, path6) {
      var parent = visit.itemAtPath(cst, path6.slice(0, -1)), field = path6[path6.length - 1][0], coll = parent == null ? void 0 : parent[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path6, item, visitor) {
      var ctrl = visitor(item, path6);
      if ((typeof ctrl > "u" ? "undefined" : _type_of12(ctrl)) === "symbol")
        return ctrl;
      for (var _i = 0, _iter = [
        "key",
        "value"
      ]; _i < _iter.length; _i++) {
        var field = _iter[_i], token = item[field];
        if (token && "items" in token) {
          for (var i = 0; i < token.items.length; ++i) {
            var ci = _visit(Object.freeze(path6.concat([
              [
                field,
                i
              ]
            ])), token.items[i], visitor);
            if (typeof ci == "number")
              i = ci - 1;
            else {
              if (ci === BREAK)
                return BREAK;
              ci === REMOVE && (token.items.splice(i, 1), i -= 1);
            }
          }
          typeof ctrl == "function" && field === "key" && (ctrl = ctrl(item, path6));
        }
      }
      return typeof ctrl == "function" ? ctrl(item, path6) : ctrl;
    }
    exports2.visit = visit;
  }
});

// ../../node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../../node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar(), cstStringify = require_cst_stringify(), cstVisit = require_cst_visit(), BOM = "\uFEFF", DOCUMENT = "", FLOW_END = "", SCALAR = "", isCollection = function(token) {
      return !!token && "items" in token;
    }, isScalar = function(token) {
      return !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    };
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case `
`:
        case `\r
`:
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// ../../node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function _ts_values(o) {
      var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length == "number")
        return {
          next: function() {
            return o && i >= o.length && (o = void 0), {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case `
`:
        case "\r":
        case "	":
          return !0;
        default:
          return !1;
      }
    }
    var hexDigits = "0123456789ABCDEFabcdef".split(""), tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(""), invalidFlowScalarChars = ",[]{}".split(""), invalidAnchorChars = ` ,[]{}
\r	`.split(""), isNotAnchorChar = function(ch) {
      return !ch || invalidAnchorChars.includes(ch);
    }, Lexer = /* @__PURE__ */ function() {
      function Lexer2() {
        _class_call_check15(this, Lexer2), this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
      }
      return _create_class13(Lexer2, [
        {
          key: "lex",
          value: (
            /**
            * Generate YAML tokens from the `source` string. If `incomplete`,
            * a part of the last line may be left as a buffer for the next call.
            *
            * @returns A generator of lexical tokens
            */
            function(source) {
              var incomplete, _this_next, next, _arguments = arguments;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    incomplete = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : !1, source && (this.buffer = this.buffer ? this.buffer + source : source, this.lineEndPos = null), this.atEnd = !incomplete, next = (_this_next = this.next) !== null && _this_next !== void 0 ? _this_next : "stream", _state.label = 1;
                  case 1:
                    return next && (incomplete || this.hasChars(1)) ? [
                      5,
                      _ts_values(this.parseNext(next))
                    ] : [
                      3,
                      3
                    ];
                  case 2:
                    return next = _state.sent(), [
                      3,
                      1
                    ];
                  case 3:
                    return [
                      2
                    ];
                }
              });
            }
          )
        },
        {
          key: "atLineEnd",
          value: function() {
            for (var i = this.pos, ch = this.buffer[i]; ch === " " || ch === "	"; )
              ch = this.buffer[++i];
            return !ch || ch === "#" || ch === `
` ? !0 : ch === "\r" ? this.buffer[i + 1] === `
` : !1;
          }
        },
        {
          key: "charAt",
          value: function(n) {
            return this.buffer[this.pos + n];
          }
        },
        {
          key: "continueScalar",
          value: function(offset) {
            var ch = this.buffer[offset];
            if (this.indentNext > 0) {
              for (var indent = 0; ch === " "; )
                ch = this.buffer[++indent + offset];
              if (ch === "\r") {
                var next = this.buffer[indent + offset + 1];
                if (next === `
` || !next && !this.atEnd)
                  return offset + indent + 1;
              }
              return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
            }
            if (ch === "-" || ch === ".") {
              var dt = this.buffer.substr(offset, 3);
              if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
                return -1;
            }
            return offset;
          }
        },
        {
          key: "getLine",
          value: function() {
            var end = this.lineEndPos;
            return (typeof end != "number" || end !== -1 && end < this.pos) && (end = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = end), end === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[end - 1] === "\r" && (end -= 1), this.buffer.substring(this.pos, end));
          }
        },
        {
          key: "hasChars",
          value: function(n) {
            return this.pos + n <= this.buffer.length;
          }
        },
        {
          key: "setNext",
          value: function(state) {
            return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = state, null;
          }
        },
        {
          key: "peek",
          value: function(n) {
            return this.buffer.substr(this.pos, n);
          }
        },
        {
          key: "parseNext",
          value: function(next) {
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  switch (next) {
                    case "stream":
                      return [
                        3,
                        1
                      ];
                    case "line-start":
                      return [
                        3,
                        3
                      ];
                    case "block-start":
                      return [
                        3,
                        5
                      ];
                    case "doc":
                      return [
                        3,
                        7
                      ];
                    case "flow":
                      return [
                        3,
                        9
                      ];
                    case "quoted-scalar":
                      return [
                        3,
                        11
                      ];
                    case "block-scalar":
                      return [
                        3,
                        13
                      ];
                    case "plain-scalar":
                      return [
                        3,
                        15
                      ];
                  }
                  return [
                    3,
                    17
                  ];
                case 1:
                  return [
                    5,
                    _ts_values(this.parseStream())
                  ];
                case 2:
                  return [
                    2,
                    _state.sent()
                  ];
                case 3:
                  return [
                    5,
                    _ts_values(this.parseLineStart())
                  ];
                case 4:
                  return [
                    2,
                    _state.sent()
                  ];
                case 5:
                  return [
                    5,
                    _ts_values(this.parseBlockStart())
                  ];
                case 6:
                  return [
                    2,
                    _state.sent()
                  ];
                case 7:
                  return [
                    5,
                    _ts_values(this.parseDocument())
                  ];
                case 8:
                  return [
                    2,
                    _state.sent()
                  ];
                case 9:
                  return [
                    5,
                    _ts_values(this.parseFlowCollection())
                  ];
                case 10:
                  return [
                    2,
                    _state.sent()
                  ];
                case 11:
                  return [
                    5,
                    _ts_values(this.parseQuotedScalar())
                  ];
                case 12:
                  return [
                    2,
                    _state.sent()
                  ];
                case 13:
                  return [
                    5,
                    _ts_values(this.parseBlockScalar())
                  ];
                case 14:
                  return [
                    2,
                    _state.sent()
                  ];
                case 15:
                  return [
                    5,
                    _ts_values(this.parsePlainScalar())
                  ];
                case 16:
                  return [
                    2,
                    _state.sent()
                  ];
                case 17:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "parseStream",
          value: function() {
            var line, dirEnd, cs, ch, ch1, n, _, sp;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return line = this.getLine(), line === null ? [
                    2,
                    this.setNext("stream")
                  ] : line[0] !== cst.BOM ? [
                    3,
                    2
                  ] : [
                    5,
                    _ts_values(this.pushCount(1))
                  ];
                case 1:
                  _state.sent(), line = line.substring(1), _state.label = 2;
                case 2:
                  if (line[0] !== "%")
                    return [
                      3,
                      6
                    ];
                  for (dirEnd = line.length, cs = line.indexOf("#"), cs !== -1 && (ch = line[cs - 1], (ch === " " || ch === "	") && (dirEnd = cs - 1)); ch1 = line[dirEnd - 1], ch1 === " " || ch1 === "	"; )
                    dirEnd -= 1;
                  return [
                    5,
                    _ts_values(this.pushCount(dirEnd))
                  ];
                case 3:
                  return _ = _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 4:
                  return n = _ + _state.sent(), [
                    5,
                    _ts_values(this.pushCount(line.length - n))
                  ];
                case 5:
                  return _state.sent(), this.pushNewline(), [
                    2,
                    "stream"
                  ];
                case 6:
                  return this.atLineEnd() ? [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ] : [
                    3,
                    10
                  ];
                case 7:
                  return sp = _state.sent(), [
                    5,
                    _ts_values(this.pushCount(line.length - sp))
                  ];
                case 8:
                  return _state.sent(), [
                    5,
                    _ts_values(this.pushNewline())
                  ];
                case 9:
                  return _state.sent(), [
                    2,
                    "stream"
                  ];
                case 10:
                  return [
                    4,
                    cst.DOCUMENT
                  ];
                case 11:
                  return _state.sent(), [
                    5,
                    _ts_values(this.parseLineStart())
                  ];
                case 12:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          }
        },
        {
          key: "parseLineStart",
          value: function() {
            var ch, s, _;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return ch = this.charAt(0), !ch && !this.atEnd ? [
                    2,
                    this.setNext("line-start")
                  ] : ch === "-" || ch === "." ? !this.atEnd && !this.hasChars(4) ? [
                    2,
                    this.setNext("line-start")
                  ] : (s = this.peek(3), s === "---" && isEmpty(this.charAt(3)) ? [
                    5,
                    _ts_values(this.pushCount(3))
                  ] : [
                    3,
                    2
                  ]) : [
                    3,
                    4
                  ];
                case 1:
                  return _state.sent(), this.indentValue = 0, this.indentNext = 0, [
                    2,
                    "doc"
                  ];
                case 2:
                  return s === "..." && isEmpty(this.charAt(3)) ? [
                    5,
                    _ts_values(this.pushCount(3))
                  ] : [
                    3,
                    4
                  ];
                case 3:
                  return _state.sent(), [
                    2,
                    "stream"
                  ];
                case 4:
                  return _ = this, [
                    5,
                    _ts_values(this.pushSpaces(!1))
                  ];
                case 5:
                  return _.indentValue = _state.sent(), this.indentNext > this.indentValue && !isEmpty(this.charAt(1)) && (this.indentNext = this.indentValue), [
                    5,
                    _ts_values(this.parseBlockStart())
                  ];
                case 6:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          }
        },
        {
          key: "parseBlockStart",
          value: function() {
            var _this_peek, ch0, ch1, n, _;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return _this_peek = _sliced_to_array15(this.peek(2), 2), ch0 = _this_peek[0], ch1 = _this_peek[1], !ch1 && !this.atEnd ? [
                    2,
                    this.setNext("block-start")
                  ] : (ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1) ? [
                    5,
                    _ts_values(this.pushCount(1))
                  ] : [
                    3,
                    4
                  ];
                case 1:
                  return _ = _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 2:
                  return n = _ + _state.sent(), this.indentNext = this.indentValue + 1, this.indentValue += n, [
                    5,
                    _ts_values(this.parseBlockStart())
                  ];
                case 3:
                  return [
                    2,
                    _state.sent()
                  ];
                case 4:
                  return [
                    2,
                    "doc"
                  ];
              }
            });
          }
        },
        {
          key: "parseDocument",
          value: function() {
            var line, n, _;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 1:
                  return _state.sent(), line = this.getLine(), line === null ? [
                    2,
                    this.setNext("doc")
                  ] : [
                    5,
                    _ts_values(this.pushIndicators())
                  ];
                case 2:
                  switch (n = _state.sent(), _ = line[n], _) {
                    case "#":
                      return [
                        3,
                        3
                      ];
                    case // fallthrough
                    void 0:
                      return [
                        3,
                        5
                      ];
                    case "{":
                      return [
                        3,
                        8
                      ];
                    case "[":
                      return [
                        3,
                        8
                      ];
                    case "}":
                      return [
                        3,
                        10
                      ];
                    case "]":
                      return [
                        3,
                        10
                      ];
                    case "*":
                      return [
                        3,
                        12
                      ];
                    case '"':
                      return [
                        3,
                        14
                      ];
                    case "'":
                      return [
                        3,
                        14
                      ];
                    case "|":
                      return [
                        3,
                        16
                      ];
                    case ">":
                      return [
                        3,
                        16
                      ];
                  }
                  return [
                    3,
                    22
                  ];
                case 3:
                  return [
                    5,
                    _ts_values(this.pushCount(line.length - n))
                  ];
                case 4:
                  _state.sent(), _state.label = 5;
                case 5:
                  return [
                    5,
                    _ts_values(this.pushNewline())
                  ];
                case 6:
                  return _state.sent(), [
                    5,
                    _ts_values(this.parseLineStart())
                  ];
                case 7:
                  return [
                    2,
                    _state.sent()
                  ];
                case 8:
                  return [
                    5,
                    _ts_values(this.pushCount(1))
                  ];
                case 9:
                  return _state.sent(), this.flowKey = !1, this.flowLevel = 1, [
                    2,
                    "flow"
                  ];
                case 10:
                  return [
                    5,
                    _ts_values(this.pushCount(1))
                  ];
                case 11:
                  return _state.sent(), [
                    2,
                    "doc"
                  ];
                case 12:
                  return [
                    5,
                    _ts_values(this.pushUntil(isNotAnchorChar))
                  ];
                case 13:
                  return _state.sent(), [
                    2,
                    "doc"
                  ];
                case 14:
                  return [
                    5,
                    _ts_values(this.parseQuotedScalar())
                  ];
                case 15:
                  return [
                    2,
                    _state.sent()
                  ];
                case 16:
                  return [
                    5,
                    _ts_values(this.parseBlockScalarHeader())
                  ];
                case 17:
                  return n += _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 18:
                  return n += _state.sent(), [
                    5,
                    _ts_values(this.pushCount(line.length - n))
                  ];
                case 19:
                  return _state.sent(), [
                    5,
                    _ts_values(this.pushNewline())
                  ];
                case 20:
                  return _state.sent(), [
                    5,
                    _ts_values(this.parseBlockScalar())
                  ];
                case 21:
                  return [
                    2,
                    _state.sent()
                  ];
                case 22:
                  return [
                    5,
                    _ts_values(this.parsePlainScalar())
                  ];
                case 23:
                  return [
                    2,
                    _state.sent()
                  ];
                case 24:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "parseFlowCollection",
          value: function() {
            var nl, sp, indent, line, atFlowEndMarker, n, _, next;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  indent = -1, _state.label = 1;
                case 1:
                  return [
                    5,
                    _ts_values(this.pushNewline())
                  ];
                case 2:
                  return nl = _state.sent(), nl > 0 ? [
                    5,
                    _ts_values(this.pushSpaces(!1))
                  ] : [
                    3,
                    4
                  ];
                case 3:
                  return sp = _state.sent(), this.indentValue = indent = sp, [
                    3,
                    5
                  ];
                case 4:
                  sp = 0, _state.label = 5;
                case 5:
                  return [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 6:
                  sp += _state.sent(), _state.label = 7;
                case 7:
                  if (nl + sp > 0)
                    return [
                      3,
                      1
                    ];
                  _state.label = 8;
                case 8:
                  return line = this.getLine(), line === null ? [
                    2,
                    this.setNext("flow")
                  ] : indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3]) ? (atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}"), atFlowEndMarker ? [
                    3,
                    11
                  ] : (this.flowLevel = 0, [
                    4,
                    cst.FLOW_END
                  ])) : [
                    3,
                    11
                  ];
                case 9:
                  return _state.sent(), [
                    5,
                    _ts_values(this.parseLineStart())
                  ];
                case 10:
                  return [
                    2,
                    _state.sent()
                  ];
                case 11:
                  n = 0, _state.label = 12;
                case 12:
                  return line[n] !== "," ? [
                    3,
                    15
                  ] : [
                    5,
                    _ts_values(this.pushCount(1))
                  ];
                case 13:
                  return n += _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 14:
                  return n += _state.sent(), this.flowKey = !1, [
                    3,
                    12
                  ];
                case 15:
                  return [
                    5,
                    _ts_values(this.pushIndicators())
                  ];
                case 16:
                  switch (n += _state.sent(), _ = line[n], _) {
                    case void 0:
                      return [
                        3,
                        17
                      ];
                    case "#":
                      return [
                        3,
                        18
                      ];
                    case "{":
                      return [
                        3,
                        20
                      ];
                    case "[":
                      return [
                        3,
                        20
                      ];
                    case "}":
                      return [
                        3,
                        22
                      ];
                    case "]":
                      return [
                        3,
                        22
                      ];
                    case "*":
                      return [
                        3,
                        24
                      ];
                    case '"':
                      return [
                        3,
                        26
                      ];
                    case "'":
                      return [
                        3,
                        26
                      ];
                    case ":":
                      return [
                        3,
                        28
                      ];
                  }
                  return [
                    3,
                    31
                  ];
                case 17:
                  return [
                    2,
                    "flow"
                  ];
                case 18:
                  return [
                    5,
                    _ts_values(this.pushCount(line.length - n))
                  ];
                case 19:
                  return _state.sent(), [
                    2,
                    "flow"
                  ];
                case 20:
                  return [
                    5,
                    _ts_values(this.pushCount(1))
                  ];
                case 21:
                  return _state.sent(), this.flowKey = !1, this.flowLevel += 1, [
                    2,
                    "flow"
                  ];
                case 22:
                  return [
                    5,
                    _ts_values(this.pushCount(1))
                  ];
                case 23:
                  return _state.sent(), this.flowKey = !0, this.flowLevel -= 1, [
                    2,
                    this.flowLevel ? "flow" : "doc"
                  ];
                case 24:
                  return [
                    5,
                    _ts_values(this.pushUntil(isNotAnchorChar))
                  ];
                case 25:
                  return _state.sent(), [
                    2,
                    "flow"
                  ];
                case 26:
                  return this.flowKey = !0, [
                    5,
                    _ts_values(this.parseQuotedScalar())
                  ];
                case 27:
                  return [
                    2,
                    _state.sent()
                  ];
                case 28:
                  return next = this.charAt(1), this.flowKey || isEmpty(next) || next === "," ? (this.flowKey = !1, [
                    5,
                    _ts_values(this.pushCount(1))
                  ]) : [
                    3,
                    31
                  ];
                case 29:
                  return _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 30:
                  return _state.sent(), [
                    2,
                    "flow"
                  ];
                case 31:
                  return this.flowKey = !1, [
                    5,
                    _ts_values(this.parsePlainScalar())
                  ];
                case 32:
                  return [
                    2,
                    _state.sent()
                  ];
                case 33:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "parseQuotedScalar",
          value: function() {
            var quote2, end, n, qb, nl, cs;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (quote2 = this.charAt(0), end = this.buffer.indexOf(quote2, this.pos + 1), quote2 === "'")
                    for (; end !== -1 && this.buffer[end + 1] === "'"; )
                      end = this.buffer.indexOf("'", end + 2);
                  else
                    for (; end !== -1; ) {
                      for (n = 0; this.buffer[end - 1 - n] === "\\"; )
                        n += 1;
                      if (n % 2 === 0)
                        break;
                      end = this.buffer.indexOf('"', end + 1);
                    }
                  if (qb = this.buffer.substring(0, end), nl = qb.indexOf(`
`, this.pos), nl !== -1) {
                    for (; nl !== -1 && (cs = this.continueScalar(nl + 1), cs !== -1); )
                      nl = qb.indexOf(`
`, cs);
                    nl !== -1 && (end = nl - (qb[nl - 1] === "\r" ? 2 : 1));
                  }
                  if (end === -1) {
                    if (!this.atEnd)
                      return [
                        2,
                        this.setNext("quoted-scalar")
                      ];
                    end = this.buffer.length;
                  }
                  return [
                    5,
                    _ts_values(this.pushToIndex(end + 1, !1))
                  ];
                case 1:
                  return _state.sent(), [
                    2,
                    this.flowLevel ? "flow" : "doc"
                  ];
              }
            });
          }
        },
        {
          key: "parseBlockScalarHeader",
          value: function() {
            var i, ch;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  for (this.blockScalarIndent = -1, this.blockScalarKeep = !1, i = this.pos; ; )
                    if (ch = this.buffer[++i], ch === "+")
                      this.blockScalarKeep = !0;
                    else if (ch > "0" && ch <= "9")
                      this.blockScalarIndent = Number(ch) - 1;
                    else if (ch !== "-")
                      break;
                  return [
                    5,
                    _ts_values(this.pushUntil(function(ch2) {
                      return isEmpty(ch2) || ch2 === "#";
                    }))
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          }
        },
        {
          key: "parseBlockScalar",
          value: function() {
            var nl, indent, ch, i, next, cs, i1, ch1, lastChar;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  nl = this.pos - 1, indent = 0;
                  loop:
                    for (i = this.pos; ch = this.buffer[i]; ++i)
                      switch (ch) {
                        case " ":
                          indent += 1;
                          break;
                        case `
`:
                          nl = i, indent = 0;
                          break;
                        case "\r": {
                          if (next = this.buffer[i + 1], !next && !this.atEnd)
                            return [
                              2,
                              this.setNext("block-scalar")
                            ];
                          if (next === `
`)
                            break;
                        }
                        default:
                          break loop;
                      }
                  if (!ch && !this.atEnd)
                    return [
                      2,
                      this.setNext("block-scalar")
                    ];
                  if (indent >= this.indentNext) {
                    this.blockScalarIndent === -1 ? this.indentNext = indent : this.indentNext += this.blockScalarIndent;
                    do {
                      if (cs = this.continueScalar(nl + 1), cs === -1)
                        break;
                      nl = this.buffer.indexOf(`
`, cs);
                    } while (nl !== -1);
                    if (nl === -1) {
                      if (!this.atEnd)
                        return [
                          2,
                          this.setNext("block-scalar")
                        ];
                      nl = this.buffer.length;
                    }
                  }
                  if (!this.blockScalarKeep)
                    do {
                      for (i1 = nl - 1, ch1 = this.buffer[i1], ch1 === "\r" && (ch1 = this.buffer[--i1]), lastChar = i1; ch1 === " " || ch1 === "	"; )
                        ch1 = this.buffer[--i1];
                      if (ch1 === `
` && i1 >= this.pos && i1 + 1 + indent > lastChar)
                        nl = i1;
                      else
                        break;
                    } while (!0);
                  return [
                    4,
                    cst.SCALAR
                  ];
                case 1:
                  return _state.sent(), [
                    5,
                    _ts_values(this.pushToIndex(nl + 1, !0))
                  ];
                case 2:
                  return _state.sent(), [
                    5,
                    _ts_values(this.parseLineStart())
                  ];
                case 3:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          }
        },
        {
          key: "parsePlainScalar",
          value: function() {
            var inFlow, end, i, ch, next, next1, cs;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  for (inFlow = this.flowLevel > 0, end = this.pos - 1, i = this.pos - 1; ch = this.buffer[++i]; )
                    if (ch === ":") {
                      if (next = this.buffer[i + 1], isEmpty(next) || inFlow && next === ",")
                        break;
                      end = i;
                    } else if (isEmpty(ch)) {
                      if (next1 = this.buffer[i + 1], ch === "\r" && (next1 === `
` ? (i += 1, ch = `
`, next1 = this.buffer[i + 1]) : end = i), next1 === "#" || inFlow && invalidFlowScalarChars.includes(next1))
                        break;
                      if (ch === `
`) {
                        if (cs = this.continueScalar(i + 1), cs === -1)
                          break;
                        i = Math.max(i, cs - 2);
                      }
                    } else {
                      if (inFlow && invalidFlowScalarChars.includes(ch))
                        break;
                      end = i;
                    }
                  return !ch && !this.atEnd ? [
                    2,
                    this.setNext("plain-scalar")
                  ] : [
                    4,
                    cst.SCALAR
                  ];
                case 1:
                  return _state.sent(), [
                    5,
                    _ts_values(this.pushToIndex(end + 1, !0))
                  ];
                case 2:
                  return _state.sent(), [
                    2,
                    inFlow ? "flow" : "doc"
                  ];
              }
            });
          }
        },
        {
          key: "pushCount",
          value: function(n) {
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return n > 0 ? [
                    4,
                    this.buffer.substr(this.pos, n)
                  ] : [
                    3,
                    2
                  ];
                case 1:
                  return _state.sent(), this.pos += n, [
                    2,
                    n
                  ];
                case 2:
                  return [
                    2,
                    0
                  ];
              }
            });
          }
        },
        {
          key: "pushToIndex",
          value: function(i, allowEmpty) {
            var s;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return s = this.buffer.slice(this.pos, i), s ? [
                    4,
                    s
                  ] : [
                    3,
                    2
                  ];
                case 1:
                  return _state.sent(), this.pos += s.length, [
                    2,
                    s.length
                  ];
                case 2:
                  return allowEmpty ? [
                    4,
                    ""
                  ] : [
                    3,
                    4
                  ];
                case 3:
                  _state.sent(), _state.label = 4;
                case 4:
                  return [
                    2,
                    0
                  ];
              }
            });
          }
        },
        {
          key: "pushIndicators",
          value: function() {
            var _, _1, _2, _3, _4, inFlow, ch1, _5, _6;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  switch (_ = this.charAt(0), _) {
                    case "!":
                      return [
                        3,
                        1
                      ];
                    case "&":
                      return [
                        3,
                        5
                      ];
                    case "-":
                      return [
                        3,
                        9
                      ];
                    case // this is an error
                    "?":
                      return [
                        3,
                        9
                      ];
                    case // this is an error outside flow collections
                    ":":
                      return [
                        3,
                        9
                      ];
                  }
                  return [
                    3,
                    13
                  ];
                case 1:
                  return [
                    5,
                    _ts_values(this.pushTag())
                  ];
                case 2:
                  return _1 = _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 3:
                  return _2 = _1 + _state.sent(), [
                    5,
                    _ts_values(this.pushIndicators())
                  ];
                case 4:
                  return [
                    2,
                    _2 + _state.sent()
                  ];
                case 5:
                  return [
                    5,
                    _ts_values(this.pushUntil(isNotAnchorChar))
                  ];
                case 6:
                  return _3 = _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 7:
                  return _4 = _3 + _state.sent(), [
                    5,
                    _ts_values(this.pushIndicators())
                  ];
                case 8:
                  return [
                    2,
                    _4 + _state.sent()
                  ];
                case 9:
                  return inFlow = this.flowLevel > 0, ch1 = this.charAt(1), isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1) ? (inFlow ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, [
                    5,
                    _ts_values(this.pushCount(1))
                  ]) : [
                    3,
                    13
                  ];
                case 10:
                  return _5 = _state.sent(), [
                    5,
                    _ts_values(this.pushSpaces(!0))
                  ];
                case 11:
                  return _6 = _5 + _state.sent(), [
                    5,
                    _ts_values(this.pushIndicators())
                  ];
                case 12:
                  return [
                    2,
                    _6 + _state.sent()
                  ];
                case 13:
                  return [
                    2,
                    0
                  ];
              }
            });
          }
        },
        {
          key: "pushTag",
          value: function() {
            var i, ch, i1, ch1;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (this.charAt(1) !== "<")
                    return [
                      3,
                      2
                    ];
                  for (i = this.pos + 2, ch = this.buffer[i]; !isEmpty(ch) && ch !== ">"; )
                    ch = this.buffer[++i];
                  return [
                    5,
                    _ts_values(this.pushToIndex(ch === ">" ? i + 1 : i, !1))
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
                case 2:
                  for (i1 = this.pos + 1, ch1 = this.buffer[i1]; ch1; )
                    if (tagChars.includes(ch1))
                      ch1 = this.buffer[++i1];
                    else if (ch1 === "%" && hexDigits.includes(this.buffer[i1 + 1]) && hexDigits.includes(this.buffer[i1 + 2]))
                      ch1 = this.buffer[i1 += 3];
                    else
                      break;
                  return [
                    5,
                    _ts_values(this.pushToIndex(i1, !1))
                  ];
                case 3:
                  return [
                    2,
                    _state.sent()
                  ];
                case 4:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "pushNewline",
          value: function() {
            var ch;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return ch = this.buffer[this.pos], ch !== `
` ? [
                    3,
                    2
                  ] : [
                    5,
                    _ts_values(this.pushCount(1))
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
                case 2:
                  return ch === "\r" && this.charAt(1) === `
` ? [
                    5,
                    _ts_values(this.pushCount(2))
                  ] : [
                    3,
                    4
                  ];
                case 3:
                  return [
                    2,
                    _state.sent()
                  ];
                case 4:
                  return [
                    2,
                    0
                  ];
                case 5:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "pushSpaces",
          value: function(allowTabs) {
            var i, ch, n;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  i = this.pos - 1;
                  do
                    ch = this.buffer[++i];
                  while (ch === " " || allowTabs && ch === "	");
                  return n = i - this.pos, n > 0 ? [
                    4,
                    this.buffer.substr(this.pos, n)
                  ] : [
                    3,
                    2
                  ];
                case 1:
                  _state.sent(), this.pos = i, _state.label = 2;
                case 2:
                  return [
                    2,
                    n
                  ];
              }
            });
          }
        },
        {
          key: "pushUntil",
          value: function(test) {
            var i, ch;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  for (i = this.pos, ch = this.buffer[i]; !test(ch); )
                    ch = this.buffer[++i];
                  return [
                    5,
                    _ts_values(this.pushToIndex(i, !1))
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          }
        }
      ]), Lexer2;
    }();
    exports2.Lexer = Lexer;
  }
});

// ../../node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../../node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    var LineCounter = function LineCounter2() {
      var _this = this;
      _class_call_check15(this, LineCounter2), this.lineStarts = [], this.addNewLine = function(offset) {
        return _this.lineStarts.push(offset);
      }, this.linePos = function(offset) {
        for (var low = 0, high = _this.lineStarts.length; low < high; ) {
          var mid = low + high >> 1;
          _this.lineStarts[mid] < offset ? low = mid + 1 : high = mid;
        }
        if (_this.lineStarts[low] === offset)
          return {
            line: low + 1,
            col: 1
          };
        if (low === 0)
          return {
            line: 0,
            col: offset
          };
        var start = _this.lineStarts[low - 1];
        return {
          line: low,
          col: offset - start + 1
        };
      };
    };
    exports2.LineCounter = LineCounter;
  }
});

// ../../node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../../node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    function _ts_values(o) {
      var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length == "number")
        return {
          next: function() {
            return o && i >= o.length && (o = void 0), {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    var cst = require_cst(), lexer = require_lexer();
    function includesToken(list, type) {
      for (var i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return !0;
      return !1;
    }
    function findNonEmptyIndex(list) {
      for (var i = 0; i < list.length; ++i)
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      return -1;
    }
    function isFlowToken(token) {
      switch (token == null ? void 0 : token.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return !0;
        default:
          return !1;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          var it = parent.items[parent.items.length - 1], _it_sep;
          return (_it_sep = it.sep) !== null && _it_sep !== void 0 ? _it_sep : it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      var _prev_;
      if (prev.length === 0)
        return [];
      var i = prev.length;
      loop:
        for (; --i >= 0; )
          switch (prev[i].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
      for (; ((_prev_ = prev[++i]) === null || _prev_ === void 0 ? void 0 : _prev_.type) === "space"; )
        ;
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = fc.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var it = _step.value;
            it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind") && (it.key && (it.value = it.key), delete it.key, isFlowToken(it.value) ? it.value.end ? Array.prototype.push.apply(it.value.end, it.sep) : it.value.end = it.sep : Array.prototype.push.apply(it.start, it.sep), delete it.sep);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2(onNewLine) {
        _class_call_check15(this, Parser2), this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new lexer.Lexer(), this.onNewLine = onNewLine;
      }
      return _create_class13(Parser2, [
        {
          key: "parse",
          value: (
            /**
            * Parse `source` as a YAML stream.
            * If `incomplete`, a part of the last line may be left as a buffer for the next call.
            *
            * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
            *
            * @returns A generator of tokens representing each directive, document, and other structure.
            */
            function(source) {
              var incomplete, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, lexeme, err, _arguments = arguments;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    incomplete = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : !1, this.onNewLine && this.offset === 0 && this.onNewLine(0), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
                  case 1:
                    _state.trys.push([
                      1,
                      6,
                      7,
                      8
                    ]), _iterator = this.lexer.lex(source, incomplete)[Symbol.iterator](), _state.label = 2;
                  case 2:
                    return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                      3,
                      5
                    ] : (lexeme = _step.value, [
                      5,
                      _ts_values(this.next(lexeme))
                    ]);
                  case 3:
                    _state.sent(), _state.label = 4;
                  case 4:
                    return _iteratorNormalCompletion2 = !0, [
                      3,
                      2
                    ];
                  case 5:
                    return [
                      3,
                      8
                    ];
                  case 6:
                    return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                      3,
                      8
                    ];
                  case 7:
                    try {
                      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                    } finally {
                      if (_didIteratorError2)
                        throw _iteratorError2;
                    }
                    return [
                      7
                    ];
                  case 8:
                    return incomplete ? [
                      3,
                      10
                    ] : [
                      5,
                      _ts_values(this.end())
                    ];
                  case 9:
                    _state.sent(), _state.label = 10;
                  case 10:
                    return [
                      2
                    ];
                }
              });
            }
          )
        },
        {
          key: "next",
          value: (
            /**
            * Advance the parser by the `source` of one lexical token.
            */
            function(source) {
              var type, message;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return this.source = source, process.env.LOG_TOKENS && console.log("|", cst.prettyToken(source)), this.atScalar ? (this.atScalar = !1, [
                      5,
                      _ts_values(this.step())
                    ]) : [
                      3,
                      2
                    ];
                  case 1:
                    return _state.sent(), this.offset += source.length, [
                      2
                    ];
                  case 2:
                    return type = cst.tokenType(source), type ? [
                      3,
                      4
                    ] : (message = "Not a YAML token: ".concat(source), [
                      5,
                      _ts_values(this.pop({
                        type: "error",
                        offset: this.offset,
                        message,
                        source
                      }))
                    ]);
                  case 3:
                    return _state.sent(), this.offset += source.length, [
                      3,
                      7
                    ];
                  case 4:
                    return type !== "scalar" ? [
                      3,
                      5
                    ] : (this.atNewLine = !1, this.atScalar = !0, this.type = "scalar", [
                      3,
                      7
                    ]);
                  case 5:
                    return this.type = type, [
                      5,
                      _ts_values(this.step())
                    ];
                  case 6:
                    switch (_state.sent(), type) {
                      case "newline":
                        this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + source.length);
                        break;
                      case "space":
                        this.atNewLine && source[0] === " " && (this.indent += source.length);
                        break;
                      case "explicit-key-ind":
                      case "map-value-ind":
                      case "seq-item-ind":
                        this.atNewLine && (this.indent += source.length);
                        break;
                      case "doc-mode":
                      case "flow-error-end":
                        return [
                          2
                        ];
                      default:
                        this.atNewLine = !1;
                    }
                    this.offset += source.length, _state.label = 7;
                  case 7:
                    return [
                      2
                    ];
                }
              });
            }
          )
        },
        {
          key: "end",
          value: (
            /** Call at end of input to push out any remaining constructions */
            function() {
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return this.stack.length > 0 ? [
                      5,
                      _ts_values(this.pop())
                    ] : [
                      3,
                      2
                    ];
                  case 1:
                    return _state.sent(), [
                      3,
                      0
                    ];
                  case 2:
                    return [
                      2
                    ];
                }
              });
            }
          )
        },
        {
          key: "sourceToken",
          get: function() {
            var st = {
              type: this.type,
              offset: this.offset,
              indent: this.indent,
              source: this.source
            };
            return st;
          }
        },
        {
          key: "step",
          value: function() {
            var top, _;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (top = this.peek(1), !(this.type === "doc-end" && (!top || top.type !== "doc-end")))
                    return [
                      3,
                      4
                    ];
                  _state.label = 1;
                case 1:
                  return this.stack.length > 0 ? [
                    5,
                    _ts_values(this.pop())
                  ] : [
                    3,
                    3
                  ];
                case 2:
                  return _state.sent(), [
                    3,
                    1
                  ];
                case 3:
                  return this.stack.push({
                    type: "doc-end",
                    offset: this.offset,
                    source: this.source
                  }), [
                    2
                  ];
                case 4:
                  return top ? [
                    3,
                    6
                  ] : [
                    5,
                    _ts_values(this.stream())
                  ];
                case 5:
                  return [
                    2,
                    _state.sent()
                  ];
                case 6:
                  switch (_ = top.type, _) {
                    case "document":
                      return [
                        3,
                        7
                      ];
                    case "alias":
                      return [
                        3,
                        9
                      ];
                    case "scalar":
                      return [
                        3,
                        9
                      ];
                    case "single-quoted-scalar":
                      return [
                        3,
                        9
                      ];
                    case "double-quoted-scalar":
                      return [
                        3,
                        9
                      ];
                    case "block-scalar":
                      return [
                        3,
                        11
                      ];
                    case "block-map":
                      return [
                        3,
                        13
                      ];
                    case "block-seq":
                      return [
                        3,
                        15
                      ];
                    case "flow-collection":
                      return [
                        3,
                        17
                      ];
                    case "doc-end":
                      return [
                        3,
                        19
                      ];
                  }
                  return [
                    3,
                    21
                  ];
                case 7:
                  return [
                    5,
                    _ts_values(this.document(top))
                  ];
                case 8:
                  return [
                    2,
                    _state.sent()
                  ];
                case 9:
                  return [
                    5,
                    _ts_values(this.scalar(top))
                  ];
                case 10:
                  return [
                    2,
                    _state.sent()
                  ];
                case 11:
                  return [
                    5,
                    _ts_values(this.blockScalar(top))
                  ];
                case 12:
                  return [
                    2,
                    _state.sent()
                  ];
                case 13:
                  return [
                    5,
                    _ts_values(this.blockMap(top))
                  ];
                case 14:
                  return [
                    2,
                    _state.sent()
                  ];
                case 15:
                  return [
                    5,
                    _ts_values(this.blockSequence(top))
                  ];
                case 16:
                  return [
                    2,
                    _state.sent()
                  ];
                case 17:
                  return [
                    5,
                    _ts_values(this.flowCollection(top))
                  ];
                case 18:
                  return [
                    2,
                    _state.sent()
                  ];
                case 19:
                  return [
                    5,
                    _ts_values(this.documentEnd(top))
                  ];
                case 20:
                  return [
                    2,
                    _state.sent()
                  ];
                case 21:
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 22:
                  return _state.sent(), [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "peek",
          value: function(n) {
            return this.stack[this.stack.length - n];
          }
        },
        {
          key: "pop",
          value: function(error) {
            var token, message, top, _, it, it1, it2, last;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return token = error ?? this.stack.pop(), token ? [
                    3,
                    2
                  ] : (message = "Tried to pop an empty stack", [
                    4,
                    {
                      type: "error",
                      offset: this.offset,
                      source: "",
                      message
                    }
                  ]);
                case 1:
                  return _state.sent(), [
                    3,
                    14
                  ];
                case 2:
                  return this.stack.length !== 0 ? [
                    3,
                    4
                  ] : [
                    4,
                    token
                  ];
                case 3:
                  return _state.sent(), [
                    3,
                    14
                  ];
                case 4:
                  switch (top = this.peek(1), token.type === "block-scalar" ? token.indent = "indent" in top ? top.indent : 0 : token.type === "flow-collection" && top.type === "document" && (token.indent = 0), token.type === "flow-collection" && fixFlowSeqItems(token), _ = top.type, _) {
                    case "document":
                      return [
                        3,
                        5
                      ];
                    case "block-scalar":
                      return [
                        3,
                        6
                      ];
                    case "block-map":
                      return [
                        3,
                        7
                      ];
                    case "block-seq":
                      return [
                        3,
                        8
                      ];
                    case "flow-collection":
                      return [
                        3,
                        9
                      ];
                  }
                  return [
                    3,
                    10
                  ];
                case 5:
                  return top.value = token, [
                    3,
                    13
                  ];
                case 6:
                  return top.props.push(token), [
                    3,
                    13
                  ];
                case 7:
                  {
                    if (it = top.items[top.items.length - 1], it.value)
                      return top.items.push({
                        start: [],
                        key: token,
                        sep: []
                      }), this.onKeyLine = !0, [
                        2
                      ];
                    if (it.sep)
                      it.value = token;
                    else
                      return Object.assign(it, {
                        key: token,
                        sep: []
                      }), this.onKeyLine = !includesToken(it.start, "explicit-key-ind"), [
                        2
                      ];
                    return [
                      3,
                      13
                    ];
                  }
                  _state.label = 8;
                case 8:
                  return it1 = top.items[top.items.length - 1], it1.value ? top.items.push({
                    start: [],
                    value: token
                  }) : it1.value = token, [
                    3,
                    13
                  ];
                case 9:
                  return it2 = top.items[top.items.length - 1], !it2 || it2.value ? top.items.push({
                    start: [],
                    key: token,
                    sep: []
                  }) : it2.sep ? it2.value = token : Object.assign(it2, {
                    key: token,
                    sep: []
                  }), [
                    2
                  ];
                case 10:
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 11:
                  return _state.sent(), [
                    5,
                    _ts_values(this.pop(token))
                  ];
                case 12:
                  _state.sent(), _state.label = 13;
                case 13:
                  (top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq") && (last = token.items[token.items.length - 1], last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every(function(st) {
                    return st.type !== "comment" || st.indent < token.indent;
                  })) && (top.type === "document" ? top.end = last.start : top.items.push({
                    start: last.start
                  }), token.items.splice(-1, 1))), _state.label = 14;
                case 14:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "stream",
          value: function() {
            var _, doc;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  switch (_ = this.type, _) {
                    case "directive-line":
                      return [
                        3,
                        1
                      ];
                    case "byte-order-mark":
                      return [
                        3,
                        3
                      ];
                    case "space":
                      return [
                        3,
                        3
                      ];
                    case "comment":
                      return [
                        3,
                        3
                      ];
                    case "newline":
                      return [
                        3,
                        3
                      ];
                    case "doc-mode":
                      return [
                        3,
                        5
                      ];
                    case "doc-start":
                      return [
                        3,
                        5
                      ];
                  }
                  return [
                    3,
                    6
                  ];
                case 1:
                  return [
                    4,
                    {
                      type: "directive",
                      offset: this.offset,
                      source: this.source
                    }
                  ];
                case 2:
                  return _state.sent(), [
                    2
                  ];
                case 3:
                  return [
                    4,
                    this.sourceToken
                  ];
                case 4:
                  return _state.sent(), [
                    2
                  ];
                case 5:
                  return doc = {
                    type: "document",
                    offset: this.offset,
                    start: []
                  }, this.type === "doc-start" && doc.start.push(this.sourceToken), this.stack.push(doc), [
                    2
                  ];
                case 6:
                  return [
                    4,
                    {
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected ".concat(this.type, " token in YAML stream"),
                      source: this.source
                    }
                  ];
                case 7:
                  return _state.sent(), [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "document",
          value: function(doc) {
            var _, bv;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return doc.value ? [
                    5,
                    _ts_values(this.lineEnd(doc))
                  ] : [
                    3,
                    2
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
                case 2:
                  switch (_ = this.type, _) {
                    case "doc-start":
                      return [
                        3,
                        3
                      ];
                    case "anchor":
                      return [
                        3,
                        8
                      ];
                    case "tag":
                      return [
                        3,
                        8
                      ];
                    case "space":
                      return [
                        3,
                        8
                      ];
                    case "comment":
                      return [
                        3,
                        8
                      ];
                    case "newline":
                      return [
                        3,
                        8
                      ];
                  }
                  return [
                    3,
                    9
                  ];
                case 3:
                  return findNonEmptyIndex(doc.start) === -1 ? [
                    3,
                    6
                  ] : [
                    5,
                    _ts_values(this.pop())
                  ];
                case 4:
                  return _state.sent(), [
                    5,
                    _ts_values(this.step())
                  ];
                case 5:
                  return _state.sent(), [
                    3,
                    7
                  ];
                case 6:
                  doc.start.push(this.sourceToken), _state.label = 7;
                case 7:
                  return [
                    2
                  ];
                case 8:
                  return doc.start.push(this.sourceToken), [
                    2
                  ];
                case 9:
                  return bv = this.startBlockValue(doc), bv ? (this.stack.push(bv), [
                    3,
                    12
                  ]) : [
                    3,
                    10
                  ];
                case 10:
                  return [
                    4,
                    {
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected ".concat(this.type, " token in YAML document"),
                      source: this.source
                    }
                  ];
                case 11:
                  _state.sent(), _state.label = 12;
                case 12:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "scalar",
          value: function(scalar) {
            var prev, start, sep2, map;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return this.type !== "map-value-ind" ? [
                    3,
                    1
                  ] : (prev = getPrevProps(this.peek(2)), start = getFirstKeyStartProps(prev), scalar.end ? (sep2 = scalar.end, sep2.push(this.sourceToken), delete scalar.end) : sep2 = [
                    this.sourceToken
                  ], map = {
                    type: "block-map",
                    offset: scalar.offset,
                    indent: scalar.indent,
                    items: [
                      {
                        start,
                        key: scalar,
                        sep: sep2
                      }
                    ]
                  }, this.onKeyLine = !0, this.stack[this.stack.length - 1] = map, [
                    3,
                    3
                  ]);
                case 1:
                  return [
                    5,
                    _ts_values(this.lineEnd(scalar))
                  ];
                case 2:
                  _state.sent(), _state.label = 3;
                case 3:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "blockScalar",
          value: function(scalar) {
            var _, nl;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  switch (_ = this.type, _) {
                    case "space":
                      return [
                        3,
                        1
                      ];
                    case "comment":
                      return [
                        3,
                        1
                      ];
                    case "newline":
                      return [
                        3,
                        1
                      ];
                    case "scalar":
                      return [
                        3,
                        2
                      ];
                  }
                  return [
                    3,
                    4
                  ];
                case 1:
                  return scalar.props.push(this.sourceToken), [
                    2
                  ];
                case 2:
                  if (scalar.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine)
                    for (nl = this.source.indexOf(`
`) + 1; nl !== 0; )
                      this.onNewLine(this.offset + nl), nl = this.source.indexOf(`
`, nl) + 1;
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 3:
                  return _state.sent(), [
                    3,
                    7
                  ];
                case 4:
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 5:
                  return _state.sent(), [
                    5,
                    _ts_values(this.step())
                  ];
                case 6:
                  _state.sent(), _state.label = 7;
                case 7:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "blockMap",
          value: function(map) {
            var it, end, last, _prev_value, prev, end1, atNextItem, start, nl, i, st, start1, start2, key, sep2, fs7, bv;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  switch (it = map.items[map.items.length - 1], this.type) {
                    case "newline":
                      return this.onKeyLine = !1, it.value ? (end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0, (last == null ? void 0 : last.type) === "comment" ? end == null || end.push(this.sourceToken) : map.items.push({
                        start: [
                          this.sourceToken
                        ]
                      })) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken), [
                        2
                      ];
                    case "space":
                    case "comment":
                      if (it.value)
                        map.items.push({
                          start: [
                            this.sourceToken
                          ]
                        });
                      else if (it.sep)
                        it.sep.push(this.sourceToken);
                      else {
                        if (this.atIndentedComment(it.start, map.indent) && (prev = map.items[map.items.length - 2], end1 = prev == null || (_prev_value = prev.value) === null || _prev_value === void 0 ? void 0 : _prev_value.end, Array.isArray(end1)))
                          return Array.prototype.push.apply(end1, it.start), end1.push(this.sourceToken), map.items.pop(), [
                            2
                          ];
                        it.start.push(this.sourceToken);
                      }
                      return [
                        2
                      ];
                  }
                  if (this.indent >= map.indent) {
                    if (atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep, start = [], atNextItem && it.sep && !it.value) {
                      for (nl = [], i = 0; i < it.sep.length; ++i)
                        switch (st = it.sep[i], st.type) {
                          case "newline":
                            nl.push(i);
                            break;
                          case "space":
                            break;
                          case "comment":
                            st.indent > map.indent && (nl.length = 0);
                            break;
                          default:
                            nl.length = 0;
                        }
                      nl.length >= 2 && (start = it.sep.splice(nl[1]));
                    }
                    switch (this.type) {
                      case "anchor":
                      case "tag":
                        return atNextItem || it.value ? (start.push(this.sourceToken), map.items.push({
                          start
                        }), this.onKeyLine = !0) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken), [
                          2
                        ];
                      case "explicit-key-ind":
                        return !it.sep && !includesToken(it.start, "explicit-key-ind") ? it.start.push(this.sourceToken) : atNextItem || it.value ? (start.push(this.sourceToken), map.items.push({
                          start
                        })) : this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [
                            {
                              start: [
                                this.sourceToken
                              ]
                            }
                          ]
                        }), this.onKeyLine = !0, [
                          2
                        ];
                      case "map-value-ind":
                        return includesToken(it.start, "explicit-key-ind") ? it.sep ? it.value ? map.items.push({
                          start: [],
                          key: null,
                          sep: [
                            this.sourceToken
                          ]
                        }) : includesToken(it.sep, "map-value-ind") ? this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [
                            {
                              start,
                              key: null,
                              sep: [
                                this.sourceToken
                              ]
                            }
                          ]
                        }) : isFlowToken(it.key) && !includesToken(it.sep, "newline") ? (start2 = getFirstKeyStartProps(it.start), key = it.key, sep2 = it.sep, sep2.push(this.sourceToken), delete it.key, delete it.sep, this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [
                            {
                              start: start2,
                              key,
                              sep: sep2
                            }
                          ]
                        })) : start.length > 0 ? it.sep = it.sep.concat(start, this.sourceToken) : it.sep.push(this.sourceToken) : includesToken(it.start, "newline") ? Object.assign(it, {
                          key: null,
                          sep: [
                            this.sourceToken
                          ]
                        }) : (start1 = getFirstKeyStartProps(it.start), this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [
                            {
                              start: start1,
                              key: null,
                              sep: [
                                this.sourceToken
                              ]
                            }
                          ]
                        })) : it.sep ? it.value || atNextItem ? map.items.push({
                          start,
                          key: null,
                          sep: [
                            this.sourceToken
                          ]
                        }) : includesToken(it.sep, "map-value-ind") ? this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [
                            {
                              start: [],
                              key: null,
                              sep: [
                                this.sourceToken
                              ]
                            }
                          ]
                        }) : it.sep.push(this.sourceToken) : Object.assign(it, {
                          key: null,
                          sep: [
                            this.sourceToken
                          ]
                        }), this.onKeyLine = !0, [
                          2
                        ];
                      case "alias":
                      case "scalar":
                      case "single-quoted-scalar":
                      case "double-quoted-scalar":
                        return fs7 = this.flowScalar(this.type), atNextItem || it.value ? (map.items.push({
                          start,
                          key: fs7,
                          sep: []
                        }), this.onKeyLine = !0) : it.sep ? this.stack.push(fs7) : (Object.assign(it, {
                          key: fs7,
                          sep: []
                        }), this.onKeyLine = !0), [
                          2
                        ];
                      default:
                        if (bv = this.startBlockValue(map), bv)
                          return atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind") && map.items.push({
                            start
                          }), this.stack.push(bv), [
                            2
                          ];
                    }
                  }
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 1:
                  return _state.sent(), [
                    5,
                    _ts_values(this.step())
                  ];
                case 2:
                  return _state.sent(), [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "blockSequence",
          value: function(seq) {
            var it, end, last, _prev_value, prev, end1, bv;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  switch (it = seq.items[seq.items.length - 1], this.type) {
                    case "newline":
                      return it.value ? (end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0, (last == null ? void 0 : last.type) === "comment" ? end == null || end.push(this.sourceToken) : seq.items.push({
                        start: [
                          this.sourceToken
                        ]
                      })) : it.start.push(this.sourceToken), [
                        2
                      ];
                    case "space":
                    case "comment":
                      if (it.value)
                        seq.items.push({
                          start: [
                            this.sourceToken
                          ]
                        });
                      else {
                        if (this.atIndentedComment(it.start, seq.indent) && (prev = seq.items[seq.items.length - 2], end1 = prev == null || (_prev_value = prev.value) === null || _prev_value === void 0 ? void 0 : _prev_value.end, Array.isArray(end1)))
                          return Array.prototype.push.apply(end1, it.start), end1.push(this.sourceToken), seq.items.pop(), [
                            2
                          ];
                        it.start.push(this.sourceToken);
                      }
                      return [
                        2
                      ];
                    case "anchor":
                    case "tag":
                      if (it.value || this.indent <= seq.indent)
                        break;
                      return it.start.push(this.sourceToken), [
                        2
                      ];
                    case "seq-item-ind":
                      if (this.indent !== seq.indent)
                        break;
                      return it.value || includesToken(it.start, "seq-item-ind") ? seq.items.push({
                        start: [
                          this.sourceToken
                        ]
                      }) : it.start.push(this.sourceToken), [
                        2
                      ];
                  }
                  return this.indent > seq.indent && (bv = this.startBlockValue(seq), bv) ? (this.stack.push(bv), [
                    2
                  ]) : [
                    5,
                    _ts_values(this.pop())
                  ];
                case 1:
                  return _state.sent(), [
                    5,
                    _ts_values(this.step())
                  ];
                case 2:
                  return _state.sent(), [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "flowCollection",
          value: function(fc) {
            var it, top, fs7, bv, parent, prev, start, sep2, map;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (it = fc.items[fc.items.length - 1], this.type !== "flow-error-end")
                    return [
                      3,
                      5
                    ];
                  _state.label = 1;
                case 1:
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 2:
                  _state.sent(), top = this.peek(1), _state.label = 3;
                case 3:
                  if (top && top.type === "flow-collection")
                    return [
                      3,
                      1
                    ];
                  _state.label = 4;
                case 4:
                  return [
                    3,
                    16
                  ];
                case 5:
                  if (fc.end.length !== 0)
                    return [
                      3,
                      10
                    ];
                  switch (this.type) {
                    case "comma":
                    case "explicit-key-ind":
                      return !it || it.sep ? fc.items.push({
                        start: [
                          this.sourceToken
                        ]
                      }) : it.start.push(this.sourceToken), [
                        2
                      ];
                    case "map-value-ind":
                      return !it || it.value ? fc.items.push({
                        start: [],
                        key: null,
                        sep: [
                          this.sourceToken
                        ]
                      }) : it.sep ? it.sep.push(this.sourceToken) : Object.assign(it, {
                        key: null,
                        sep: [
                          this.sourceToken
                        ]
                      }), [
                        2
                      ];
                    case "space":
                    case "comment":
                    case "newline":
                    case "anchor":
                    case "tag":
                      return !it || it.value ? fc.items.push({
                        start: [
                          this.sourceToken
                        ]
                      }) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken), [
                        2
                      ];
                    case "alias":
                    case "scalar":
                    case "single-quoted-scalar":
                    case "double-quoted-scalar":
                      return fs7 = this.flowScalar(this.type), !it || it.value ? fc.items.push({
                        start: [],
                        key: fs7,
                        sep: []
                      }) : it.sep ? this.stack.push(fs7) : Object.assign(it, {
                        key: fs7,
                        sep: []
                      }), [
                        2
                      ];
                    case "flow-map-end":
                    case "flow-seq-end":
                      return fc.end.push(this.sourceToken), [
                        2
                      ];
                  }
                  return bv = this.startBlockValue(fc), /* istanbul ignore else should not happen */
                  bv ? (this.stack.push(bv), [
                    3,
                    9
                  ]) : [
                    3,
                    6
                  ];
                case 6:
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 7:
                  return _state.sent(), [
                    5,
                    _ts_values(this.step())
                  ];
                case 8:
                  _state.sent(), _state.label = 9;
                case 9:
                  return [
                    3,
                    16
                  ];
                case 10:
                  return parent = this.peek(2), parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep) ? [
                    5,
                    _ts_values(this.pop())
                  ] : [
                    3,
                    13
                  ];
                case 11:
                  return _state.sent(), [
                    5,
                    _ts_values(this.step())
                  ];
                case 12:
                  return _state.sent(), [
                    3,
                    16
                  ];
                case 13:
                  return this.type === "map-value-ind" && parent.type !== "flow-collection" ? (prev = getPrevProps(parent), start = getFirstKeyStartProps(prev), fixFlowSeqItems(fc), sep2 = fc.end.splice(1, fc.end.length), sep2.push(this.sourceToken), map = {
                    type: "block-map",
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [
                      {
                        start,
                        key: fc,
                        sep: sep2
                      }
                    ]
                  }, this.onKeyLine = !0, this.stack[this.stack.length - 1] = map, [
                    3,
                    16
                  ]) : [
                    3,
                    14
                  ];
                case 14:
                  return [
                    5,
                    _ts_values(this.lineEnd(fc))
                  ];
                case 15:
                  _state.sent(), _state.label = 16;
                case 16:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "flowScalar",
          value: function(type) {
            if (this.onNewLine)
              for (var nl = this.source.indexOf(`
`) + 1; nl !== 0; )
                this.onNewLine(this.offset + nl), nl = this.source.indexOf(`
`, nl) + 1;
            return {
              type,
              offset: this.offset,
              indent: this.indent,
              source: this.source
            };
          }
        },
        {
          key: "startBlockValue",
          value: function(parent) {
            switch (this.type) {
              case "alias":
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar":
                return this.flowScalar(this.type);
              case "block-scalar-header":
                return {
                  type: "block-scalar",
                  offset: this.offset,
                  indent: this.indent,
                  props: [
                    this.sourceToken
                  ],
                  source: ""
                };
              case "flow-map-start":
              case "flow-seq-start":
                return {
                  type: "flow-collection",
                  offset: this.offset,
                  indent: this.indent,
                  start: this.sourceToken,
                  items: [],
                  end: []
                };
              case "seq-item-ind":
                return {
                  type: "block-seq",
                  offset: this.offset,
                  indent: this.indent,
                  items: [
                    {
                      start: [
                        this.sourceToken
                      ]
                    }
                  ]
                };
              case "explicit-key-ind": {
                this.onKeyLine = !0;
                var prev = getPrevProps(parent), start = getFirstKeyStartProps(prev);
                return start.push(this.sourceToken), {
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [
                    {
                      start
                    }
                  ]
                };
              }
              case "map-value-ind": {
                this.onKeyLine = !0;
                var prev1 = getPrevProps(parent), start1 = getFirstKeyStartProps(prev1);
                return {
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [
                    {
                      start: start1,
                      key: null,
                      sep: [
                        this.sourceToken
                      ]
                    }
                  ]
                };
              }
            }
            return null;
          }
        },
        {
          key: "atIndentedComment",
          value: function(start, indent) {
            return this.type !== "comment" || this.indent <= indent ? !1 : start.every(function(st) {
              return st.type === "newline" || st.type === "space";
            });
          }
        },
        {
          key: "documentEnd",
          value: function(docEnd) {
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return this.type === "doc-mode" ? [
                    3,
                    2
                  ] : (docEnd.end ? docEnd.end.push(this.sourceToken) : docEnd.end = [
                    this.sourceToken
                  ], this.type !== "newline" ? [
                    3,
                    2
                  ] : [
                    5,
                    _ts_values(this.pop())
                  ]);
                case 1:
                  _state.sent(), _state.label = 2;
                case 2:
                  return [
                    2
                  ];
              }
            });
          }
        },
        {
          key: "lineEnd",
          value: function(token) {
            var _;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  switch (_ = this.type, _) {
                    case "comma":
                      return [
                        3,
                        1
                      ];
                    case "doc-start":
                      return [
                        3,
                        1
                      ];
                    case "doc-end":
                      return [
                        3,
                        1
                      ];
                    case "flow-seq-end":
                      return [
                        3,
                        1
                      ];
                    case "flow-map-end":
                      return [
                        3,
                        1
                      ];
                    case "map-value-ind":
                      return [
                        3,
                        1
                      ];
                    case "newline":
                      return [
                        3,
                        4
                      ];
                    case // fallthrough
                    "space":
                      return [
                        3,
                        5
                      ];
                    case "comment":
                      return [
                        3,
                        5
                      ];
                  }
                  return [
                    3,
                    5
                  ];
                case 1:
                  return [
                    5,
                    _ts_values(this.pop())
                  ];
                case 2:
                  return _state.sent(), [
                    5,
                    _ts_values(this.step())
                  ];
                case 3:
                  return _state.sent(), [
                    3,
                    7
                  ];
                case 4:
                  this.onKeyLine = !1, _state.label = 5;
                case 5:
                  return token.end ? token.end.push(this.sourceToken) : token.end = [
                    this.sourceToken
                  ], this.type !== "newline" ? [
                    3,
                    7
                  ] : [
                    5,
                    _ts_values(this.pop())
                  ];
                case 6:
                  _state.sent(), _state.label = 7;
                case 7:
                  return [
                    2
                  ];
              }
            });
          }
        }
      ]), Parser2;
    }();
    exports2.Parser = Parser;
  }
});

// ../../node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer(), Document = require_Document(), errors = require_errors(), log2 = require_log(), lineCounter = require_line_counter(), parser = require_parser();
    function parseOptions(options) {
      var prettyErrors = options.prettyErrors !== !1, lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return {
        lineCounter: lineCounter$1,
        prettyErrors
      };
    }
    function parseAllDocuments(source) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _parseOptions = parseOptions(options), lineCounter2 = _parseOptions.lineCounter, prettyErrors = _parseOptions.prettyErrors, parser$1 = new parser.Parser(lineCounter2 == null ? void 0 : lineCounter2.addNewLine), composer$1 = new composer.Composer(options), docs = Array.from(composer$1.compose(parser$1.parse(source))), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      if (prettyErrors && lineCounter2)
        try {
          for (var _iterator = docs[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var doc = _step.value;
            doc.errors.forEach(errors.prettifyError(source, lineCounter2)), doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      return docs.length > 0 ? docs : Object.assign([], {
        empty: !0
      }, composer$1.streamInfo());
    }
    function parseDocument(source) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _parseOptions = parseOptions(options), lineCounter2 = _parseOptions.lineCounter, prettyErrors = _parseOptions.prettyErrors, parser$1 = new parser.Parser(lineCounter2 == null ? void 0 : lineCounter2.addNewLine), composer$1 = new composer.Composer(options), doc = null, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = composer$1.compose(parser$1.parse(source), !0, source.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var _doc = _step.value;
          if (!doc)
            doc = _doc;
          else if (doc.options.logLevel !== "silent") {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
            break;
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return prettyErrors && lineCounter2 && (doc.errors.forEach(errors.prettifyError(source, lineCounter2)), doc.warnings.forEach(errors.prettifyError(source, lineCounter2))), doc;
    }
    function parse6(src, reviver, options) {
      var _reviver = void 0;
      typeof reviver == "function" ? _reviver = reviver : options === void 0 && reviver && typeof reviver == "object" && (options = reviver);
      var doc = parseDocument(src, options);
      if (!doc)
        return null;
      if (doc.warnings.forEach(function(warning) {
        return log2.warn(doc.options.logLevel, warning);
      }), doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        doc.errors = [];
      }
      return doc.toJS(Object.assign({
        reviver: _reviver
      }, options));
    }
    function stringify(value, replacer, options) {
      var _replacer = null;
      if (typeof replacer == "function" || Array.isArray(replacer) ? _replacer = replacer : options === void 0 && replacer && (options = replacer), typeof options == "string" && (options = options.length), typeof options == "number") {
        var indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? {
          indent: 8
        } : {
          indent
        };
      }
      if (value === void 0) {
        var _ref, keepUndefined = ((_ref = options ?? replacer) !== null && _ref !== void 0 ? _ref : {}).keepUndefined;
        if (!keepUndefined)
          return;
      }
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse6;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer(), Document = require_Document(), Schema = require_Schema(), errors = require_errors(), Alias = require_Alias(), identity = require_identity(), Pair = require_Pair(), Scalar = require_Scalar(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), cst = require_cst(), lexer = require_lexer(), lineCounter = require_line_counter(), parser = require_parser(), publicApi = require_public_api(), visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
    exports2.visitAsync = visit.visitAsync;
  }
});

// ../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    module2.exports = balanced;
    function balanced(a, b, str) {
      _instanceof13(a, RegExp) && (a = maybeMatch(a, str)), _instanceof13(b, RegExp) && (b = maybeMatch(b, str));
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result, ai = str.indexOf(a), bi = str.indexOf(b, ai + 1), i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b)
          return [
            ai,
            bi
          ];
        for (begs = [], left = str.length; i >= 0 && !result; )
          i == ai ? (begs.push(i), ai = str.indexOf(a, i + 1)) : begs.length == 1 ? result = [
            begs.pop(),
            bi
          ] : (beg = begs.pop(), beg < left && (left = beg, right = bi), bi = str.indexOf(b, i + 1)), i = ai < bi && ai >= 0 ? ai : bi;
        begs.length && (result = [
          left,
          right
        ]);
      }
      return result;
    }
  }
});

// ../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [
          ""
        ];
      var parts = [], m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
    }
    function expandTop(str) {
      return str ? (str.substr(0, 2) === "{}" && (str = "\\{\\}" + str.substr(2)), expand2(escapeBraces(str), !0).map(unescapeBraces)) : [];
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [], m = balanced("{", "}", str);
      if (!m)
        return [
          str
        ];
      var pre = m.pre, post = m.post.length ? expand2(m.post, !1) : [
        ""
      ];
      if (/\$$/.test(m.pre))
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions)
          return m.post.match(/,.*\}/) ? (str = m.pre + "{" + m.body + escClose + m.post, expand2(str)) : [
            str
          ];
        var n;
        if (isSequence)
          n = m.body.split(/\.\./);
        else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand2(n[0], !1).map(embrace), n.length === 1))
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        var N;
        if (isSequence) {
          var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
          reverse && (incr *= -1, test = gte);
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence)
              c = String.fromCharCode(i), c === "\\" && (c = "");
            else if (c = String(i), pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                i < 0 ? c = "-" + z + c.slice(1) : c = z + c;
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++)
            N.push.apply(N, expand2(n[j], !1));
        }
        for (var j = 0; j < N.length; j++)
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            (!isTop || isSequence || expansion) && expansions.push(expansion);
          }
      }
      return expansions;
    }
  }
});

// ../../node_modules/builtins/builtins.json
var require_builtins = __commonJS({
  "../../node_modules/builtins/builtins.json"(exports2, module2) {
    module2.exports = [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "console",
      "constants",
      "crypto",
      "dgram",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "https",
      "module",
      "net",
      "os",
      "path",
      "process",
      "punycode",
      "querystring",
      "readline",
      "repl",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "tty",
      "url",
      "util",
      "v8",
      "vm",
      "zlib"
    ];
  }
});

// ../../node_modules/validate-npm-package-name/index.js
var require_validate_npm_package_name = __commonJS({
  "../../node_modules/validate-npm-package-name/index.js"(exports2, module2) {
    "use strict";
    var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$"), builtins = require_builtins(), blacklist = [
      "node_modules",
      "favicon.ico"
    ], validate = module2.exports = function(name) {
      var warnings = [], errors = [];
      if (name === null)
        return errors.push("name cannot be null"), done(warnings, errors);
      if (name === void 0)
        return errors.push("name cannot be undefined"), done(warnings, errors);
      if (typeof name != "string")
        return errors.push("name must be a string"), done(warnings, errors);
      if (name.length || errors.push("name length must be greater than zero"), name.match(/^\./) && errors.push("name cannot start with a period"), name.match(/^_/) && errors.push("name cannot start with an underscore"), name.trim() !== name && errors.push("name cannot contain leading or trailing spaces"), blacklist.forEach(function(blacklistedName) {
        name.toLowerCase() === blacklistedName && errors.push(blacklistedName + " is a blacklisted name");
      }), builtins.forEach(function(builtin) {
        name.toLowerCase() === builtin && warnings.push(builtin + " is a core module name");
      }), name.length > 214 && warnings.push("name can no longer contain more than 214 characters"), name.toLowerCase() !== name && warnings.push("name can no longer contain capital letters"), /[~'!()*]/.test(name.split("/").slice(-1)[0]) && warnings.push(`name can no longer contain special characters ("~'!()*")`), encodeURIComponent(name) !== name) {
        var nameMatch = name.match(scopedPackagePattern);
        if (nameMatch) {
          var user = nameMatch[1], pkg = nameMatch[2];
          if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg)
            return done(warnings, errors);
        }
        errors.push("name can only contain URL-friendly characters");
      }
      return done(warnings, errors);
    };
    validate.scopedPackagePattern = scopedPackagePattern;
    var done = function(warnings, errors) {
      var result = {
        validForNewPackages: errors.length === 0 && warnings.length === 0,
        validForOldPackages: errors.length === 0,
        warnings,
        errors
      };
      return result.warnings.length || delete result.warnings, result.errors.length || delete result.errors, result;
    };
  }
});

// ../../node_modules/@expo/package-manager/build/PackageManager.js
var require_PackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/PackageManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/which/which.js
var require_which2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/which/which.js"(exports2, module2) {
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path6 = require("path"), COLON = isWindows ? ";" : ":", isexe = require_isexe(), getNotFoundError = function(cmd) {
      return Object.assign(new Error("not found: ".concat(cmd)), {
        code: "ENOENT"
      });
    }, getPathInfo = function(cmd, opt) {
      var colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
        ""
      ] : (
        // windows always checks the cwd first
        _to_consumable_array16(isWindows ? [
          process.cwd()
        ] : []).concat(_to_consumable_array16((opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)))
      ), pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows ? pathExtExe.split(colon) : [
        ""
      ];
      return isWindows && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
        pathEnv,
        pathExt,
        pathExtExe
      };
    }, which2 = function(cmd, opt, cb) {
      typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
      var _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe, found = [], step = function(i) {
        return new Promise(function(resolve7, reject) {
          if (i === pathEnv.length)
            return opt.all && found.length ? resolve7(found) : reject(getNotFoundError(cmd));
          var ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          resolve7(subStep(p, i, 0));
        });
      }, subStep = function(p, i, ii) {
        return new Promise(function(resolve7, reject) {
          if (ii === pathExt.length)
            return resolve7(step(i + 1));
          var ext2 = pathExt[ii];
          isexe(p + ext2, {
            pathExt: pathExtExe
          }, function(er, is) {
            if (!er && is)
              if (opt.all)
                found.push(p + ext2);
              else
                return resolve7(p + ext2);
            return resolve7(subStep(p, i, ii + 1));
          });
        });
      };
      return cb ? step(0).then(function(res) {
        return cb(null, res);
      }, cb) : step(0);
    }, whichSync = function(cmd, opt) {
      opt = opt || {};
      for (var _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe, found = [], i = 0; i < pathEnv.length; i++)
        for (var ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd, j = 0; j < pathExt.length; j++) {
          var cur = p + pathExt[j];
          try {
            var is = isexe.sync(cur, {
              pathExt: pathExtExe
            });
            if (is)
              if (opt.all)
                found.push(cur);
              else
                return cur;
          } catch {
          }
        }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), which2 = require_which2(), getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      var env2 = parsed.options.env || process.env, cwd2 = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd)
        try {
          process.chdir(parsed.options.cwd);
        } catch {
        }
      var resolved;
      try {
        resolved = which2.sync(parsed.command, {
          path: env2[getPathKey({
            env: env2
          })],
          pathExt: withoutPathExt ? path6.delimiter : void 0
        });
      } catch {
      } finally {
        shouldSwitchCwd && process.chdir(cwd2);
      }
      return resolved && (resolved = path6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
    }
    module2.exports = resolveCommand;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/escape.js
var require_escape2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      return arg = "".concat(arg), arg = arg.replace(/(\\*)"/g, '$1$1\\"'), arg = arg.replace(/(\\*)$/, "$1$1"), arg = '"'.concat(arg, '"'), arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/shebang-regex/index.js
var require_shebang_regex2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/shebang-command/index.js
var require_shebang_command2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_with_holes16(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterable_to_array_limit15(arr, i) {
      var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i != null) {
        var _arr = [], _n = !0, _d = !1, _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _non_iterable_rest16() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _sliced_to_array15(arr, i) {
      return _array_with_holes16(arr) || _iterable_to_array_limit15(arr, i) || _unsupported_iterable_to_array22(arr, i) || _non_iterable_rest16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    var shebangRegex = require_shebang_regex2();
    module2.exports = function() {
      var string = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", match2 = string.match(shebangRegex);
      if (!match2)
        return null;
      var _match__replace_split = _sliced_to_array15(match2[0].replace(/#! ?/, "").split(" "), 2), path6 = _match__replace_split[0], argument = _match__replace_split[1], binary = path6.split("/").pop();
      return binary === "env" ? argument : argument ? "".concat(binary, " ").concat(argument) : binary;
    };
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs7 = require("fs"), shebangCommand = require_shebang_command2();
    function readShebang(command) {
      var size = 150, buffer = Buffer.alloc(size), fd;
      try {
        fd = fs7.openSync(command, "r"), fs7.readSync(fd, buffer, 0, size, 0), fs7.closeSync(fd);
      } catch {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/parse.js
var require_parse4 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), resolveCommand = require_resolveCommand2(), escape2 = require_escape2(), readShebang = require_readShebang2(), isWin = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      var shebang = parsed.file && readShebang(parsed.file);
      return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin)
        return parsed;
      var commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        var needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path6.normalize(parsed.command), parsed.command = escape2.command(parsed.command), parsed.args = parsed.args.map(function(arg) {
          return escape2.argument(arg, needsDoubleEscapeMetaChars);
        });
        var shellCommand = [
          parsed.command
        ].concat(parsed.args).join(" ");
        parsed.args = [
          "/d",
          "/s",
          "/c",
          '"'.concat(shellCommand, '"')
        ], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
      }
      return parsed;
    }
    function parse6(command, args, options) {
      args && !Array.isArray(args) && (options = args, args = null), args = args ? args.slice(0) : [], options = Object.assign({}, options);
      var parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse6;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/enoent.js
var require_enoent2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error("".concat(syscall, " ").concat(original.command, " ENOENT")), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: "".concat(syscall, " ").concat(original.command),
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (isWin) {
        var originalEmit = cp.emit;
        cp.emit = function(name, arg1) {
          if (name === "exit") {
            var err = verifyENOENT(arg1, parsed, "spawn");
            if (err)
              return originalEmit.call(cp, "error", err);
          }
          return originalEmit.apply(cp, arguments);
        };
      }
    }
    function verifyENOENT(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
    }
    function verifyENOENTSync(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/index.js
var require_cross_spawn2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process"), parse6 = require_parse4(), enoent = require_enoent2();
    function spawn2(command, args, options) {
      var parsed = parse6(command, args, options), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      return enoent.hookChildProcess(spawned, parsed), spawned;
    }
    function spawnSync(command, args, options) {
      var parsed = parse6(command, args, options), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      return result.error = result.error || enoent.verifyENOENTSync(result.status, parsed), result;
    }
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse6;
    module2.exports._enoent = enoent;
  }
});

// ../../node_modules/@expo/spawn-async/build/spawnAsync.js
var require_spawnAsync = __commonJS({
  "../../node_modules/@expo/spawn-async/build/spawnAsync.js"(exports2, module2) {
    "use strict";
    function _object_without_properties3(source, excluded) {
      if (source == null)
        return {};
      var target = _object_without_properties_loose3(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
      }
      return target;
    }
    function _object_without_properties_loose3(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    }, cross_spawn_1 = __importDefault(require_cross_spawn2());
    function spawnAsync(command, args) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, stubError = new Error(), callerStack = stubError.stack ? stubError.stack.replace(/^.*/, "    ...") : null, child, promise = new Promise(function(resolve7, reject) {
        var ignoreStdio = options.ignoreStdio, nodeOptions = _object_without_properties3(options, [
          "ignoreStdio"
        ]);
        child = (0, cross_spawn_1.default)(command, args, nodeOptions);
        var stdout = "", stderr = "";
        ignoreStdio || (child.stdout && child.stdout.on("data", function(data) {
          stdout += data;
        }), child.stderr && child.stderr.on("data", function(data) {
          stderr += data;
        }));
        var completionListener = function(code, signal) {
          child.removeListener("error", errorListener);
          var result = {
            pid: child.pid,
            output: [
              stdout,
              stderr
            ],
            stdout,
            stderr,
            status: code,
            signal
          };
          if (code !== 0) {
            var argumentString = args && args.length > 0 ? " ".concat(args.join(" ")) : "", error = signal ? new Error("".concat(command).concat(argumentString, " exited with signal: ").concat(signal)) : new Error("".concat(command).concat(argumentString, " exited with non-zero code: ").concat(code));
            error.stack && callerStack && (error.stack += `
`.concat(callerStack)), Object.assign(error, result), reject(error);
          } else
            resolve7(result);
        }, errorListener = function(error) {
          ignoreStdio ? child.removeListener("exit", completionListener) : child.removeListener("close", completionListener), Object.assign(error, {
            pid: child.pid,
            output: [
              stdout,
              stderr
            ],
            stdout,
            stderr,
            status: null,
            signal: null
          }), reject(error);
        };
        ignoreStdio ? child.once("exit", completionListener) : child.once("close", completionListener), child.once("error", errorListener);
      });
      return promise.child = child, promise;
    }
    module2.exports = spawnAsync;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/sudo-prompt/index.js
var require_sudo_prompt = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/sudo-prompt/index.js"(exports2, module2) {
    var Node = {
      child: require("child_process"),
      crypto: require("crypto"),
      fs: require("fs"),
      os: require("os"),
      path: require("path"),
      process,
      util: require("util")
    };
    function Attempt(instance, end) {
      var platform = Node.process.platform;
      if (platform === "darwin")
        return Mac(instance, end);
      if (platform === "linux")
        return Linux(instance, end);
      if (platform === "win32")
        return Windows(instance, end);
      end(new Error("Platform not yet supported."));
    }
    function EscapeDoubleQuotes(string) {
      if (typeof string != "string")
        throw new Error("Expected a string.");
      return string.replace(/"/g, '\\"');
    }
    function Exec() {
      if (arguments.length < 1 || arguments.length > 3)
        throw new Error("Wrong number of arguments.");
      var command = arguments[0], options = {}, end = function() {
      };
      if (typeof command != "string")
        throw new Error("Command should be a string.");
      if (arguments.length === 2)
        if (Node.util.isObject(arguments[1]))
          options = arguments[1];
        else if (Node.util.isFunction(arguments[1]))
          end = arguments[1];
        else
          throw new Error("Expected options or callback.");
      else if (arguments.length === 3) {
        if (Node.util.isObject(arguments[1]))
          options = arguments[1];
        else
          throw new Error("Expected options to be an object.");
        if (Node.util.isFunction(arguments[2]))
          end = arguments[2];
        else
          throw new Error("Expected callback to be a function.");
      }
      if (/^sudo/i.test(command))
        return end(new Error('Command should not be prefixed with "sudo".'));
      if (typeof options.name > "u") {
        var title = Node.process.title;
        if (ValidName(title))
          options.name = title;
        else
          return end(new Error("process.title cannot be used as a valid name."));
      } else if (!ValidName(options.name)) {
        var error = "";
        return error += "options.name must be alphanumeric only ", error += "(spaces are allowed) and <= 70 characters.", end(new Error(error));
      }
      if (typeof options.icns < "u") {
        if (typeof options.icns != "string")
          return end(new Error("options.icns must be a string if provided."));
        if (options.icns.trim().length === 0)
          return end(new Error("options.icns must not be empty if provided."));
      }
      if (typeof options.env < "u") {
        if (typeof options.env != "object")
          return end(new Error("options.env must be an object if provided."));
        if (Object.keys(options.env).length === 0)
          return end(new Error("options.env must not be empty if provided."));
        for (var key in options.env) {
          var value = options.env[key];
          if (typeof key != "string" || typeof value != "string")
            return end(new Error("options.env environment variables must be strings."));
          if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key))
            return end(new Error("options.env has an invalid environment variable name: " + JSON.stringify(key)));
          if (/[\r\n]/.test(value))
            return end(new Error("options.env has an invalid environment variable value: " + JSON.stringify(value)));
        }
      }
      var platform = Node.process.platform;
      if (platform !== "darwin" && platform !== "linux" && platform !== "win32")
        return end(new Error("Platform not yet supported."));
      var instance = {
        command,
        options,
        uuid: void 0,
        path: void 0
      };
      Attempt(instance, end);
    }
    function Linux(instance, end) {
      LinuxBinary(instance, function(error, binary) {
        if (error)
          return end(error);
        var command = [];
        command.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '";');
        for (var key in instance.options.env) {
          var value = instance.options.env[key];
          command.push("export " + key + '="' + EscapeDoubleQuotes(value) + '";');
        }
        command.push('"' + EscapeDoubleQuotes(binary) + '"'), /kdesudo/i.test(binary) ? (command.push("--comment", '"' + instance.options.name + ' wants to make changes. Enter your password to allow this."'), command.push("-d"), command.push("--")) : /pkexec/i.test(binary) && command.push("--disable-internal-agent");
        var magic = `SUDOPROMPT
`;
        command.push('/bin/bash -c "echo ' + EscapeDoubleQuotes(magic.trim()) + "; " + EscapeDoubleQuotes(instance.command) + '"'), command = command.join(" "), Node.child.exec(command, {
          encoding: "utf-8",
          maxBuffer: MAX_BUFFER
        }, function(error2, stdout, stderr) {
          var elevated = stdout && stdout.slice(0, magic.length) === magic;
          elevated && (stdout = stdout.slice(magic.length)), error2 && !elevated && (/No authentication agent found/.test(stderr) ? error2.message = NO_POLKIT_AGENT : error2.message = PERMISSION_DENIED), end(error2, stdout, stderr);
        });
      });
    }
    function LinuxBinary(instance, end) {
      var index = 0, paths = [
        "/usr/bin/kdesudo",
        "/usr/bin/pkexec"
      ];
      function test() {
        if (index === paths.length)
          return end(new Error("Unable to find pkexec or kdesudo."));
        var path6 = paths[index++];
        Node.fs.stat(path6, function(error) {
          if (error) {
            if (error.code === "ENOTDIR" || error.code === "ENOENT")
              return test();
            end(error);
          } else
            end(void 0, path6);
        });
      }
      test();
    }
    function Mac(instance, callback) {
      var temp = Node.os.tmpdir();
      if (!temp)
        return callback(new Error("os.tmpdir() not defined."));
      var user = Node.process.env.USER;
      if (!user)
        return callback(new Error("env['USER'] not defined."));
      UUID(instance, function(error, uuid) {
        if (error)
          return callback(error);
        instance.uuid = uuid, instance.path = Node.path.join(temp, instance.uuid, instance.options.name + ".app");
        function end(error2, stdout, stderr) {
          Remove(Node.path.dirname(instance.path), function(errorRemove) {
            if (error2)
              return callback(error2);
            if (errorRemove)
              return callback(errorRemove);
            callback(void 0, stdout, stderr);
          });
        }
        MacApplet(instance, function(error2, stdout, stderr) {
          if (error2)
            return end(error2, stdout, stderr);
          MacIcon(instance, function(error3) {
            if (error3)
              return end(error3);
            MacPropertyList(instance, function(error4, stdout2, stderr2) {
              if (error4)
                return end(error4, stdout2, stderr2);
              MacCommand(instance, function(error5) {
                if (error5)
                  return end(error5);
                MacOpen(instance, function(error6, stdout3, stderr3) {
                  if (error6)
                    return end(error6, stdout3, stderr3);
                  MacResult(instance, end);
                });
              });
            });
          });
        });
      });
    }
    function MacApplet(instance, end) {
      var parent = Node.path.dirname(instance.path);
      Node.fs.mkdir(parent, function(error) {
        if (error)
          return end(error);
        var zip = Node.path.join(parent, "sudo-prompt-applet.zip");
        Node.fs.writeFile(zip, APPLET, "base64", function(error2) {
          if (error2)
            return end(error2);
          var command = [];
          command.push("/usr/bin/unzip"), command.push("-o"), command.push('"' + EscapeDoubleQuotes(zip) + '"'), command.push('-d "' + EscapeDoubleQuotes(instance.path) + '"'), command = command.join(" "), Node.child.exec(command, {
            encoding: "utf-8"
          }, end);
        });
      });
    }
    function MacCommand(instance, end) {
      var path6 = Node.path.join(instance.path, "Contents", "MacOS", "sudo-prompt-command"), script = [];
      script.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '"');
      for (var key in instance.options.env) {
        var value = instance.options.env[key];
        script.push("export " + key + '="' + EscapeDoubleQuotes(value) + '"');
      }
      script.push(instance.command), script = script.join(`
`), Node.fs.writeFile(path6, script, "utf-8", end);
    }
    function MacIcon(instance, end) {
      if (!instance.options.icns)
        return end();
      Node.fs.readFile(instance.options.icns, function(error, buffer) {
        if (error)
          return end(error);
        var icns = Node.path.join(instance.path, "Contents", "Resources", "applet.icns");
        Node.fs.writeFile(icns, buffer, end);
      });
    }
    function MacOpen(instance, end) {
      var binary = Node.path.join(instance.path, "Contents", "MacOS", "applet"), options = {
        cwd: Node.path.dirname(binary),
        encoding: "utf-8"
      };
      Node.child.exec("./" + Node.path.basename(binary), options, end);
    }
    function MacPropertyList(instance, end) {
      var plist = Node.path.join(instance.path, "Contents", "Info.plist"), path6 = EscapeDoubleQuotes(plist), key = EscapeDoubleQuotes("CFBundleName"), value = instance.options.name + " Password Prompt";
      if (/'/.test(value))
        return end(new Error("Value should not contain single quotes."));
      var command = [];
      command.push("/usr/bin/defaults"), command.push("write"), command.push('"' + path6 + '"'), command.push('"' + key + '"'), command.push("'" + value + "'"), command = command.join(" "), Node.child.exec(command, {
        encoding: "utf-8"
      }, end);
    }
    function MacResult(instance, end) {
      var cwd2 = Node.path.join(instance.path, "Contents", "MacOS");
      Node.fs.readFile(Node.path.join(cwd2, "code"), "utf-8", function(error, code) {
        if (error) {
          if (error.code === "ENOENT")
            return end(new Error(PERMISSION_DENIED));
          end(error);
        } else
          Node.fs.readFile(Node.path.join(cwd2, "stdout"), "utf-8", function(error2, stdout) {
            if (error2)
              return end(error2);
            Node.fs.readFile(Node.path.join(cwd2, "stderr"), "utf-8", function(error3, stderr) {
              if (error3)
                return end(error3);
              code = parseInt(code.trim(), 10), code === 0 ? end(void 0, stdout, stderr) : (error3 = new Error("Command failed: " + instance.command + `
` + stderr), error3.code = code, end(error3, stdout, stderr));
            });
          });
      });
    }
    function Remove(path6, end) {
      if (typeof path6 != "string" || !path6.trim())
        return end(new Error("Argument path not defined."));
      var command = [];
      if (Node.process.platform === "win32") {
        if (/"/.test(path6))
          return end(new Error("Argument path cannot contain double-quotes."));
        command.push('rmdir /s /q "' + path6 + '"');
      } else
        command.push("/bin/rm"), command.push("-rf"), command.push('"' + EscapeDoubleQuotes(Node.path.normalize(path6)) + '"');
      command = command.join(" "), Node.child.exec(command, {
        encoding: "utf-8"
      }, end);
    }
    function UUID(instance, end) {
      Node.crypto.randomBytes(256, function(error, random) {
        error && (random = Date.now() + "" + Math.random());
        var hash = Node.crypto.createHash("SHA256");
        hash.update("sudo-prompt-3"), hash.update(instance.options.name), hash.update(instance.command), hash.update(random);
        var uuid = hash.digest("hex").slice(-32);
        if (!uuid || typeof uuid != "string" || uuid.length !== 32)
          return end(new Error("Expected a valid UUID."));
        end(void 0, uuid);
      });
    }
    function ValidName(string) {
      return !(!/^[a-z0-9 ]+$/i.test(string) || string.trim().length === 0 || string.length > 70);
    }
    function Windows(instance, callback) {
      var temp = Node.os.tmpdir();
      if (!temp)
        return callback(new Error("os.tmpdir() not defined."));
      UUID(instance, function(error, uuid) {
        if (error)
          return callback(error);
        if (instance.uuid = uuid, instance.path = Node.path.join(temp, instance.uuid), /"/.test(instance.path))
          return callback(new Error("instance.path cannot contain double-quotes."));
        instance.pathElevate = Node.path.join(instance.path, "elevate.vbs"), instance.pathExecute = Node.path.join(instance.path, "execute.bat"), instance.pathCommand = Node.path.join(instance.path, "command.bat"), instance.pathStdout = Node.path.join(instance.path, "stdout"), instance.pathStderr = Node.path.join(instance.path, "stderr"), instance.pathStatus = Node.path.join(instance.path, "status"), Node.fs.mkdir(instance.path, function(error2) {
          if (error2)
            return callback(error2);
          function end(error3, stdout, stderr) {
            Remove(instance.path, function(errorRemove) {
              if (error3)
                return callback(error3);
              if (errorRemove)
                return callback(errorRemove);
              callback(void 0, stdout, stderr);
            });
          }
          WindowsWriteExecuteScript(instance, function(error3) {
            if (error3)
              return end(error3);
            WindowsWriteCommandScript(instance, function(error4) {
              if (error4)
                return end(error4);
              WindowsElevate(instance, function(error5, stdout, stderr) {
                if (error5)
                  return end(error5, stdout, stderr);
                WindowsWaitForStatus(instance, function(error6) {
                  if (error6)
                    return end(error6);
                  WindowsResult(instance, end);
                });
              });
            });
          });
        });
      });
    }
    function WindowsElevate(instance, end) {
      var command = [];
      command.push("powershell.exe"), command.push("Start-Process"), command.push("-FilePath"), command.push(`"'` + instance.pathExecute.replace(/'/g, "`'") + `'"`), command.push("-WindowStyle hidden"), command.push("-Verb runAs"), command = command.join(" ");
      var child = Node.child.exec(command, {
        encoding: "utf-8"
      }, function(error, stdout, stderr) {
        if (error)
          return end(new Error(PERMISSION_DENIED), stdout, stderr);
        end();
      });
      child.stdin.end();
    }
    function WindowsResult(instance, end) {
      Node.fs.readFile(instance.pathStatus, "utf-8", function(error, code) {
        if (error)
          return end(error);
        Node.fs.readFile(instance.pathStdout, "utf-8", function(error2, stdout) {
          if (error2)
            return end(error2);
          Node.fs.readFile(instance.pathStderr, "utf-8", function(error3, stderr) {
            if (error3)
              return end(error3);
            code = parseInt(code.trim(), 10), code === 0 ? end(void 0, stdout, stderr) : (error3 = new Error("Command failed: " + instance.command + `\r
` + stderr), error3.code = code, end(error3, stdout, stderr));
          });
        });
      });
    }
    function WindowsWaitForStatus(instance, end) {
      Node.fs.stat(instance.pathStatus, function(error, stats) {
        error && error.code === "ENOENT" || stats.size < 2 ? setTimeout(function() {
          Node.fs.stat(instance.pathStdout, function(error2) {
            if (error2)
              return end(new Error(PERMISSION_DENIED));
            WindowsWaitForStatus(instance, end);
          });
        }, 1e3) : error ? end(error) : end();
      });
    }
    function WindowsWriteCommandScript(instance, end) {
      var cwd2 = Node.process.cwd();
      if (/"/.test(cwd2))
        return end(new Error("process.cwd() cannot contain double-quotes."));
      var script = [];
      script.push("@echo off"), script.push("chcp 65001>nul"), script.push('cd /d "' + cwd2 + '"');
      for (var key in instance.options.env) {
        var value = instance.options.env[key];
        script.push("set " + key + "=" + value.replace(/([<>\\|&^])/g, "^$1"));
      }
      script.push(instance.command), script = script.join(`\r
`), Node.fs.writeFile(instance.pathCommand, script, "utf-8", end);
    }
    function WindowsWriteExecuteScript(instance, end) {
      var script = [];
      script.push("@echo off"), script.push('call "' + instance.pathCommand + '" > "' + instance.pathStdout + '" 2> "' + instance.pathStderr + '"'), script.push('(echo %ERRORLEVEL%) > "' + instance.pathStatus + '"'), script = script.join(`\r
`), Node.fs.writeFile(instance.pathExecute, script, "utf-8", end);
    }
    module2.exports.exec = Exec;
    var APPLET = "UEsDBAoAAAAAAO1YcEcAAAAAAAAAAAAAAAAJABwAQ29udGVudHMvVVQJAAPNnElWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACgeXBHlHaGqKEBAAC+AwAAEwAcAENvbnRlbnRzL0luZm8ucGxpc3RVVAkAA1zWSVYtkRBXdXgLAAEE9QEAAAQUAAAAfZNRb5swFIWfl1/BeA9OpSmqJkqVBCJFop1VyKQ9Ta59S6wa27NNCfv1M0naJWTsEXO+c8+9vo7v97UI3sBYruRdeBPNwgAkVYzL6i7cluvpbXifTOLP6bdV+QNngRbcugBvl/lmFYRThBZaC0AoLdMA55uiDLwHQtljGIQ75/RXhNq2jUiviqiqe6FF2CgNxnW5N5t6IGKOhb7M0f0ijj9lnLpk8il+hS5ZrZeNZAIWQqj2ge+B5YoSwX8T5xEbo17ktc40gIZQCm8glK5BuieovP5Dbp3xHSeZrHyCXYxO3wM+2wNtHHkWMAQP/bkxbkOVXPMxKuK0Dz6CMh+Wv3AwQ9gPM7INU1NtVK3Ha8sXlfoB+m6J6b4fRzv0mkezMf6R1Fe5MbG2VYYF+L+lMaGvpIKy01cOC4zzMazYKeNOQYuDYkjfjMcteCWJa8w/Zi2ugubFA5e8buqisw7qU81ltzB0xx3QC5/TFh7J/e385/zL+7+/wWbR/LwIOl/dvHiCXw03YFfEPJ9dwsWu5sV2kwnod3QoeLeL0eGdJJM/UEsDBAoAAAAAAHSBjkgAAAAAAAAAAAAAAAAPABwAQ29udGVudHMvTWFjT1MvVVQJAAMbpQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACABVHBdH7Dk4KTIIAADIYQAAFQAcAENvbnRlbnRzL01hY09TL2FwcGxldFVUCQADMiPZVVOlD1d1eAsAAQT1AQAABBQAAADtnG9sHEcVwGfti7M1/rONLNVtXHqpzsipis+pHOSWFOzEm25at3XrJI2ozbK+W/suuds79vaSuCKSpaOIxRy1+NSPRPAhlWj7AVRaQCWpTRz+CEo+RSKCCho4K67kVhUyAeV4b3fWt17fXZqKFgHvp8zO3/dmdmfPmtl5L7+8/uPXGWMNELZCaGRMgmjHIlxaBCibdcoGsewCljGCIAiCIAiCIAiCIP7r+M21d67zjb/zEaAdwr1bGHuWMQH2/2wAgqqODj0kf0F+8nGfoFRbJ8p9U0C5g/KRgwEZqZLGfrfwwJx+LP2kVWkelD9zJ2NfBr1nWt2xrhNisxWZ3Ex6MpNSc1Z+soqOO+5i7JMYt7vj9BC5jiZXBwirCT2V1c0qOgZAxwMYt9cbRyxnmUljusa9mKBjGON2tgG/PlXNGyeSRlxNGlOZKjpeBR0KxsFx+MB7VJy5GB46OOSrCLPKfEjrH3/gFry+4zOpuH8sm+VF5srW6ltVjZQ3HVnL3KRDDLsflMSADpyDyjuR0urp6AAdHRgHdOD9iOs6Ypl0OmPUupeecOW19OsQAmn3tzBy4LFH5OED3jz0MbYouM8D460BOdTXCaEF6tsgLkF8GeJPQBj16Rb4PTf5xl2NH4J8a5Vy1N3F3OcZzefMaCo5GeVTuJ2P4cUf/aH5qbbP73/utpfeevdbLzwfYfy+Q80woGan/1E+ljo/703g77IaOJY479t5rqFLDag9OjaTs/R0dCQ5aWrmTHS/qaX1ExnzWC66L2PqY7p5PBnTc71TXnn0sG7mkhkjFx3a0IL30e/rQxB+EXL68J4BBLe73r298DySk5tlGPtJY1BmOhZTc727PBH2Ke+ZhF35nTyP80oQBEEQBPFRcJTZVwpvrxZWpLmJkN0VKT4q2iORUGFBOPfnBuFX9nhELOG67f1D9pWxpw4XVrrmTklz+ZY5Wfwurm/t3ffi9cE+uM41vYbbj2fP5kNXt9sXiopwVRj6xhPlr160mttfuVi4Fs2vXv2rfc5u7UeZfxQ+y4pPh/JrpyUUBjmrofzmadGXKf0eui7KK/ZwJLQUiuRAe+mLUFQ+tFKUV3npd7AU9ytz8iqIiXYoUnoBsqdxDbXk3CXcRov9lYhoW5EQjBxb4NoSY9iQsvn5+QSuusrduAybL3eHIIIbLqyIS9CHlY3loB8rldVKuLfyOsE1+a6zhUVxYsFp3Amqz8tr7Lz8dza1JF8TmC3/syivYVtcfxcWOycWQDvuLcrdnc61y7mGnWsErgmsXDbK5TKkscnypJvGhsuH3TQ2X37YTaPQ8ucw7W6t1LR2TFfjekqb0SGTiedTOmz0klZSSyWf0U01pqVSufXGmThsjs20OpU3Yrjuxbnu4u+GP8b1LO6PcX2L4Q6+v8Q07u9aQFLy71Ckt54TIfjfNdzfDkMYhTAOIXHXh39vCYIgCIIgCIIgCIL4z3Nm+84/Ci1Nn8b0ryHsgbBX1rbgOXD7LZJzNtrC0/gFqYOn8csQ/GONguQchPXzcvy+9CBzvk84HxkO+tJH3bRz5Fb0pb/nS3/fl/6BL/2aL43faLzz3Wbmju8W5p6pttaoR9THjgyZ0zEeH2eqqmbNzLShpXVIpxOqflKP5S1dTehaXDeZqhvHk2bGYOo+LZXal0lnM4ZuWMPJXFazYgmmPp7VjWF9SsunrPVa1HpMn0lPm2r8hGZO3aea+nQyZ+mmmtNjFp5i4oG0lTChE+eDj2pm8lbSgDFoln4yCRp00zQyEDmZtBZLbGxnanHzgWh092d29e/uv+/f+DIQBEEQBEEQBEEQ/7P81rX/FxoZm/Xs/5UmtP8PO/W3M9fGvKoPAEfYXLQJ1HOpmk+AJx80OOb5m/URGG9z9c378rVs9F15tPXP1dS3wvVtC+Q9/H4DFX21fQcY9zvo9eXrj6++D0Af1zfqy9eyx3f16QnVMayufr+zXN+sL99YRx/O69er+RdIgXkNxJv9DfBTDIxLPa6Zudr6enz5euO6ke9Bj7TRzr0noK+JbczfyA9hgOvr9OX98t57XNFX3ydhlOsL+2T8+oK/ucrvNOCfEHbbXhAqeebLB/0V7oYp7+Pt8PsZWnl1+urRpAn7SUCcYBX/hkth95kd2cFYllX3bxB4+xCrzcCO6v4PbXzo1fwbEM/H4ds/f/nCgZH+8k+j0vNPv7Jlz7qPQ1PFx+FVPoZ76ozj42K87YP9/cT7xuf9UfpSeP0MsJvzp0A8/4g3w+78ef4R+F4QBEEQBPH/w1Gm2FeUwturytwpUSnmJfta4Q3h3J8aFeE9xf7d1ZBSOCcqhftZ/m+YKuG6wV4qaQzdGED0Z2jJ/zpa9ZcegjIF7fkVaIBrt11nJxYOOepXpPPyKjsvvytOLcnvCWxJfh87V+xTa0rx1Kpj0a8UFqWJhXL3fgHt9xXn+rCz7Bop3rkTEkNj5e7bIZ7HNRZb/ku5XE6g58HyZUzdj6mLjh1/Pbt7XMt5dvfvtLl1Fbv7BtbhrtyEPW6V038H1yE88yQTTkqC1LJVnIeaCNe7dr3sEPEe6lCb9LWGfa3efvNG8pe5fF8NeW8g3n7jCI+/xOOEVH19KvF9oudHH2n/YOtYgiAIgiAIgiAIgiA+fm69mx3aO8bYtkHn/xlwDq8nkwaavz9h9swzc+DWwRrm71A5CJVVjeChTtk26Fqwu0fxQjUL+9vqHVV/KC53OUd+bJxVfBkw7/gzCO5pr3dOK/g+WUQDeZlV/A2QRwJ5THjn1/xcd9BfhlT1KbgpVwLn+W2amGr2//8CUEsDBBQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABwAQ29udGVudHMvTWFjT1Mvc3Vkby1wcm9tcHQtc2NyaXB0VVQJAAOJkBBXipAQV3V4CwABBPUBAAAEFAAAAI1SO08cMRDu91cMHIKGxUB5xSGEUqTlFKWMvPYca+EXnjGXy6/PeNcg0qVay+PvObs5U5OLatI0DxvYIwNVm4BdQGIdMhxSkauJ8K1i7FOjvSdwB2A+/WJnXpEJdEGwjvTk0W6HhTW8WldgzKDedVF2Ug2tLn7svz3DDpTFdxWr93C/u7wbVKWyoDhVM/8XZAOPOXvcm+IyXxGcizeaUca0XJ1D0CfQnlEysE2VwbuII0br4gvdCMF37m9IoC39+oxTO2EpS8oZJdtRS0aIKY5/sCQoyLVEMMki6Ghl0BGN9SeuICkPIctXDHDDSB9oGEQi1yZWUAda8EZnIcR/eIOOVao+9TrbkpYFjLmkkHk0KYSGvdt12/e71cP6Hs2c4OJBemtsYusplVX+GLHQ7DKkQ098/ZF38dLEpRCeNUMlMW90BIseeQkWtuu2qKmIyDHCuqFuo1N11Ud/1Cf6CHb7Sfxld2ATklQoUGEDActfZ5326WU74G/HcDv8BVBLAwQKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAcAENvbnRlbnRzL1BrZ0luZm9VVAkAA82cSVYqkRBXdXgLAAEE9QEAAAQUAAAAQVBQTGFwbHRQSwMECgAAAAAAm3lwRwAAAAAAAAAAAAAAABMAHABDb250ZW50cy9SZXNvdXJjZXMvVVQJAANW1klWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACAeXBHfrnysfYGAAAf3AAAHgAcAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUCQADH9ZJVnGlD1d1eAsAAQT1AQAABBQAAADt3Xk81Hkcx/Hvb5yVo5bGsVlKbcpRRqFlGZGS5JikRBIdI0OZttMZloqiYwrVjD1UqJaUokTRubG72bZVjqR1VZNjp2XEGo9H+9gt+9h/9tHx8H7N4/fw5MHjYeaPz+P7+P7x/bL9griEPNBm+001J0S+ZbvL/NmKwzWHE0IUHebYuRFCEckjL9v/xSvk2EpCpBXZtrYuDra2Oi4hwSvZgSsIMU9MdPdePcZd1aqQu0p3fDkrcFrs+mPWihMU9y6clp5XEFFdbRrEczCtGtfkL3pWfvBGublJ4ct051kuocYtaaqll/IjdfR+V75vlTdl//AJVZU6elZ5f0S7NO3MaE2xMElhF+TUrHgW2nFYeGTrs/OrhDJN5zMX8ZJVKXrqSUM1Rj03bnf85/pJMXECNdl0D1ctfe/j82imziM2nllSa3t5q8+vP1f38k/k22uN1lmnvfz0b8dGxO+mnh91v7WB2tKdrG3d4vmJaHlTvjGzdMqWcw/9frnCtQpPZK9sMKi/Ey/jzgqIPzBy9/dlf9griI2/u+sjcApozWx6/NXytC+qBTlrhb69fE7J6tgOzpWjFSl8qxihr5dYf/qExoeupY6Ze/j2PfL1azhhZ8fU3eelJY+ylk16UJN6KmOU0M4r+75cZhH/mxNndowNb4wx7TCoN4yvMGu8ySq5l5W5t+xQyYbS/Ome7e0W0sXbC5aktl0LEXNYR9obH7dMT721dbNdT/eFzXNEYSH8GU+bQ5s6YniGcj3fHtgXPbo0Oj4i3d5G1Fjfm/Ng7kgpjQDNxw4RRnu+Vloy5ZE3J6OpwlFBzaxS25He2h3lJuizO70zJPLUYtks14RE5yrD8y2tXa5l5Wqh/NBY06yoiCLF08Nk9A5Ojbs43GmR1Ch/PaZsLf3e6uPRSrIM1ROqGjt80leqfdxYbNn+WV7K7ZKiy/t6r1/3ie46V5432T/Oahs9V7NnVzb9zoq2rFgvPxXrcAMzmvWnGjof/RpdsZThIEpex6DGbd5h6STaOyZXxV/YfW9u4KyllmZ3X15IMHHLSJtVPSOvULCsz2TyPC/WL9kGSme/1L01SSzjfbHnqk+OV7OBmevZeo3DBR7lXT5drT0MkX5PwDd1EQ0ebfkh1zy/L8ydd+VJ4CLuRndNjuwj+vMfU8q2l2l1rGtr8FC2D+fdSGk81eltuTjYSMk++4BMd0DXQo35iXbZndGdcXkGFyeG6b28evF22M2w22HlYSXetGSLW4cfFT00WqvN9bkqCujQ9KzdSt+snr+qmbcme+5Y3cDRn9BDLps+dPVltE9UkPeb6XovineiVUznTznyuZaSn/ZvR8VeRUYLqe3iHFqnU6+7+4LmtfsmaS0MdjIvslFJGG/rn7DPdMGLcx4d6eP2Oz92Y49kWbBUjudU2ijHnc7YIODQxD1aPx8PynVr+cmvJoy2+M5nQa2Kt0dvdPxp73LNU6aTeaktTfHH1L+8Pm/XalZcFcfzYxlhTefuzjRGobLKEqPZh8QKxUXWbU/ERvW78ghvTGTUNd0g9YqbcjUy5h0xVbn3S7SS54SOqKt88UR0qZuxKfxlZfODUm52o2HkGTOLw5dqhevvWjH7ssiqxAhKwA91d1nWG9w/GJIc7GwWbKKe/mAsGRqXBb87P10jH8/0LY6kpGQV1KcuAwAAeCt4LiVFWRJKs4DJ6p9GxGHWfLuTM5dt61/pzCCE7vLmSodGJM/ASqdzU2U3VjpY6WClg5XOICudUaI3VjocuWCsdAAAAAAAAAAAAAAAAD5o1Gmr054TSoqWxPvnfrLxVEIc29/cT5YmkmdgPzlCSz8a+8nYT8Z+MvaTB9lPZpJX+8lRktFyRdDF0m6IdcF2MgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8ddD8G5oJkUuQnAXwnvxLAAAAADDkEFURRckVE6rIv+Tb1078MiZEetubJ34RHckzcOIXd8uWTpz4hRO/cOIXTvwa5MQvoidZ5S8a9h8nfl1QVhipQ6jyyWeuvTaBGP3D5fwgE4gpeQYmUCZ7XQ0mECYQJhAm0GATyOfVmYOU4sAdNi+cOUpm/9cdNv2Di8kkFN3mYOtrg8sE14xicGFwYXDhmlEAAD5w/Os1o8bTcM0oVjpY6WClg2tGAQAAAAAAAAAAAAAAgL/wb9eMBpow+r817yN/fwnJf33P5g78nWofEZNXD3u95GdSkh3o135/aL2i3vl/gHf/7t59oDlnDSHS8gQhNGQL8uWs6P+iwPYLDuIOzARqyM+E9QOfA3PIfw4IIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhND70J9QSwMEFAAAAAgA7VhwR/dYplZAAAAAagEAAB4AHABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAkAA82cSVZTpQ9XdXgLAAEE9QEAAAQUAAAAY2BgZGBgYFQBEiDsxjDygJQDPlkmEIEaRpJAQg8kLAMML8bi5OIqIFuouKA4A0jLMTD8/w+S5AdrB7PlBIAEAFBLAwQKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1VUCQADzZxJVi2REFd1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAHABDb250ZW50cy9SZXNvdXJjZXMvZGVzY3JpcHRpb24ucnRmZC9UWFQucnRmVVQJAAPNnElWU6UPV3V4CwABBPUBAAAEFAAAACWJOw6AIBAFe08DCBVX2QbWhZgQ1vCpCHcXtHkzkzegtCDB5Xp/g0+UyihARnb70kL/UbvffYpjQODcmk9zKXListxCoUsZA7EQ5S0+dVq085gvUEsDBAoAAAAAAIeBjkgAAAAAAAAAAAAAAAAbABwAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQJAAM9pQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACAAJgI5ICl5liTUBAADMAQAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUCQADcaIPV1OlD1d1eAsAAQT1AQAABBQAAAB9UMtOAkEQrNldd9dhH3Dz6NGYiPIJHjTxLCZeF9iDcXEJC0RvfoI/4sEfIvoHPEQEhbIHvOok01U16emu7vOkaF2dXu7XqrUTcyMATkxCwYKthCAUbmciAQ8O11yFcGBfbF/4jR24WmCvWjwUeXqfNutn13XyEeYYHkqKam+kghdJGfUCvwIfB6jiGAX6aCHHETroCrYFe6IKNEXfGOXChc0v7HKpBRzdSFrtELvbumKVC80F/FIjzwe9bj91uZRuXJuwAiLjNi7DlsxPaJSUAMrCFOeac3GfpINennQ6d/0sA4z7JxzKiVCCV+YHAs74LuuIONUi//4RIoC63czrIbYQS3PFicWJcTMTv1JHmocmROLJ45gjzfHvXJqjf7ZZ4RT+61uaBbDipGh2ZanBcjh8/gFQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAACQAYAAAAAAAAABAA7UEAAAAAQ29udGVudHMvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAoHlwR5R2hqihAQAAvgMAABMAGAAAAAAAAQAAAKSBQwAAAENvbnRlbnRzL0luZm8ucGxpc3RVVAUAA1zWSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAAB0gY5IAAAAAAAAAAAAAAAADwAYAAAAAAAAABAA7UExAgAAQ29udGVudHMvTWFjT1MvVVQFAAMbpQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAVRwXR+w5OCkyCAAAyGEAABUAGAAAAAAAAAAAAO2BegIAAENvbnRlbnRzL01hY09TL2FwcGxldFVUBQADMiPZVXV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABgAAAAAAAEAAADtgfsKAABDb250ZW50cy9NYWNPUy9zdWRvLXByb21wdC1zY3JpcHRVVAUAA4mQEFd1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAYAAAAAAABAAAApIHTDAAAQ29udGVudHMvUGtnSW5mb1VUBQADzZxJVnV4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAAJt5cEcAAAAAAAAAAAAAAAATABgAAAAAAAAAEADtQSUNAABDb250ZW50cy9SZXNvdXJjZXMvVVQFAANW1klWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAgHlwR3658rH2BgAAH9wAAB4AGAAAAAAAAAAAAKSBcg0AAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUBQADH9ZJVnV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAO1YcEf3WKZWQAAAAGoBAAAeABgAAAAAAAAAAACkgcAUAABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAYAAAAAAAAABAA7UFYFQAAQ29udGVudHMvUmVzb3VyY2VzL2Rlc2NyaXB0aW9uLnJ0ZmQvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAGAAAAAAAAQAAAKSBthUAAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1RYVC5ydGZVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAACHgY5IAAAAAAAAAAAAAAAAGwAYAAAAAAAAABAA7UFuFgAAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQFAAM9pQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgACYCOSApeZYk1AQAAzAEAACQAGAAAAAAAAAAAAKSBwxYAAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUBQADcaIPV3V4CwABBPUBAAAEFAAAAFBLBQYAAAAADQANANwEAABWGAAAAAA=", PERMISSION_DENIED = "User did not grant permission.", NO_POLKIT_AGENT = "No polkit authentication agent found.", MAX_BUFFER = 134217728;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/spawn.js
var require_spawn = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/spawn.js"(exports2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.spawnSudoAsync = exports2.createPendingSpawnAsync = void 0;
    var spawn_async_1 = __importDefault(require_spawnAsync()), sudo_prompt_1 = __importDefault(require_sudo_prompt());
    function createPendingSpawnAsync(actionAsync, spawnAsync) {
      var childResolve, child = new Promise(function(resolve7, reject) {
        childResolve = resolve7;
      }), pendingPromise = new Promise(function(spawnResolve, spawnReject) {
        actionAsync().then(function(result) {
          var spawnPromise = spawnAsync(result);
          childResolve(spawnPromise.child), spawnPromise.then(spawnResolve).catch(spawnReject);
        }).catch(function(error) {
          childResolve(null), spawnReject(error);
        });
      });
      return pendingPromise.child = child, pendingPromise;
    }
    exports2.createPendingSpawnAsync = createPendingSpawnAsync;
    function spawnSudoAsync(command, spawnOptions) {
      return _spawnSudoAsync.apply(this, arguments);
    }
    function _spawnSudoAsync() {
      return _spawnSudoAsync = /**
      * Spawn a command with sudo privileges.
      * On windows, this uses the `sudo-prompt` package.
      * on other systems, this uses the `sudo` binary.
      */
      _async_to_generator31(function(command, spawnOptions) {
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return (
                // sudo prompt only seems to work on win32 machines.
                process.platform !== "win32" ? [
                  3,
                  1
                ] : [
                  2,
                  new Promise(function(resolve7, reject) {
                    sudo_prompt_1.default.exec(command.join(" "), {
                      name: "pod install"
                    }, function(error) {
                      error && reject(error), resolve7();
                    });
                  })
                ]
              );
            case 1:
              return console.log("Your password might be needed to install CocoaPods CLI: https://guides.cocoapods.org/using/getting-started.html#installation"), [
                4,
                (0, spawn_async_1.default)("sudo", command, spawnOptions)
              ];
            case 2:
              _state.sent(), _state.label = 3;
            case 3:
              return [
                2
              ];
          }
        });
      }), _spawnSudoAsync.apply(this, arguments);
    }
    exports2.spawnSudoAsync = spawnSudoAsync;
  }
});

// ../../node_modules/@expo/package-manager/build/ios/CocoaPodsPackageManager.js
var require_CocoaPodsPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/ios/CocoaPodsPackageManager.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _construct4(Parent, args, Class) {
      return _is_native_reflect_construct10() ? _construct4 = Reflect.construct : _construct4 = function(Parent2, args2, Class2) {
        var a = [
          null
        ];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
        return Class2 && _set_prototype_of10(instance, Class2.prototype), instance;
      }, _construct4.apply(null, arguments);
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _is_native_function4(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _object_without_properties3(source, excluded) {
      if (source == null)
        return {};
      var target = _object_without_properties_loose3(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
      }
      return target;
    }
    function _object_without_properties_loose3(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _wrap_native_super4(Class) {
      var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return _wrap_native_super4 = function(Class2) {
        if (Class2 === null || !_is_native_function4(Class2))
          return Class2;
        if (typeof Class2 != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache < "u") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct4(Class2, arguments, _get_prototype_of10(this).constructor);
        }
        return Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), _set_prototype_of10(Wrapper, Class2);
      }, _wrap_native_super4(Class);
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.getImprovedPodInstallError = exports2.getPodRepoUpdateMessage = exports2.getPodUpdateMessage = exports2.CocoaPodsPackageManager = exports2.extractMissingDependencyError = exports2.CocoaPodsError = void 0;
    var spawn_async_1 = __importDefault(require_spawnAsync()), chalk_1 = __importDefault(require_source()), fs_1 = require("fs"), os_1 = __importDefault(require("os")), path_1 = __importDefault(require("path")), spawn_1 = require_spawn(), CocoaPodsError = /* @__PURE__ */ function(Error1) {
      _inherits10(CocoaPodsError2, Error1);
      var _super = _create_super10(CocoaPodsError2);
      function CocoaPodsError2(message, code, cause) {
        _class_call_check15(this, CocoaPodsError2);
        var _this;
        return _this = _super.call(this, cause ? "".concat(message, `
\u2514\u2500 Cause: `).concat(cause.message) : message), _define_property21(_assert_this_initialized10(_this), "code", void 0), _define_property21(_assert_this_initialized10(_this), "cause", void 0), _define_property21(_assert_this_initialized10(_this), "name", "CocoaPodsError"), _define_property21(_assert_this_initialized10(_this), "isPackageManagerError", !0), _this.code = code, _this.cause = cause, _this;
      }
      return CocoaPodsError2;
    }(_wrap_native_super4(Error));
    exports2.CocoaPodsError = CocoaPodsError;
    function extractMissingDependencyError(errorOutput) {
      var results = errorOutput.match(/Unable to find a specification for ['"`]([\w-_\d\s]+)['"`] depended upon by ['"`]([\w-_\d\s]+)['"`]/);
      return results ? [
        results[1],
        results[2]
      ] : null;
    }
    exports2.extractMissingDependencyError = extractMissingDependencyError;
    var CocoaPodsPackageManager = /* @__PURE__ */ function() {
      function CocoaPodsPackageManager2(param) {
        var cwd2 = param.cwd, silent = param.silent;
        _class_call_check15(this, CocoaPodsPackageManager2), _define_property21(this, "options", void 0), _define_property21(this, "silent", void 0), this.silent = !!silent, this.options = {
          cwd: cwd2,
          // We use pipe by default instead of inherit so that we can capture stderr/stdout and process it for errors.
          // Later we'll also pipe the stdout/stderr to the terminal when silent is false.
          stdio: "pipe"
        };
      }
      return _create_class13(CocoaPodsPackageManager2, [
        {
          key: "name",
          get: function() {
            return "CocoaPods";
          }
        },
        {
          key: "installAsync",
          value: (
            /** Runs `pod install` and attempts to automatically run known troubleshooting steps automatically. */
            function() {
              var spinner = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).spinner, _this = this;
              return _async_to_generator31(function() {
                return _ts_generator31(this, function(_state) {
                  switch (_state.label) {
                    case 0:
                      return [
                        4,
                        _this._installAsync({
                          spinner
                        })
                      ];
                    case 1:
                      return _state.sent(), [
                        2
                      ];
                  }
                });
              })();
            }
          )
        },
        {
          key: "isCLIInstalledAsync",
          value: function() {
            return CocoaPodsPackageManager2.isCLIInstalledAsync(this.options);
          }
        },
        {
          key: "installCLIAsync",
          value: function() {
            return CocoaPodsPackageManager2.installCLIAsync({
              nonInteractive: !0,
              spawnOptions: this.options
            });
          }
        },
        {
          key: "handleInstallErrorAsync",
          value: function(param) {
            var error = param.error, _param_shouldUpdate = param.shouldUpdate, shouldUpdate = _param_shouldUpdate === void 0 ? !0 : _param_shouldUpdate, _param_updatedPackages = param.updatedPackages, updatedPackages = _param_updatedPackages === void 0 ? [] : _param_updatedPackages, spinner = param.spinner, _this = this;
            return _async_to_generator31(function() {
              var errorOutput, _getPodUpdateMessage, updatePackage, shouldUpdateRepo;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    if (!error.output)
                      throw error;
                    if (!shouldUpdate)
                      throw getImprovedPodInstallError(error, {
                        cwd: _this.options.cwd
                      });
                    return errorOutput = error.output.join(os_1.default.EOL).trim(), _getPodUpdateMessage = getPodUpdateMessage(errorOutput), updatePackage = _getPodUpdateMessage.updatePackage, shouldUpdateRepo = _getPodUpdateMessage.shouldUpdateRepo, !updatePackage || updatedPackages.includes(updatePackage) ? [
                      4,
                      _this._installAsync({
                        spinner,
                        shouldRepoUpdate: !0,
                        // Include a boolean to ensure pod install --repo-update isn't invoked in the unlikely case where the pods fail to update.
                        shouldUpdate: !1,
                        updatedPackages
                      })
                    ] : [
                      3,
                      2
                    ];
                  case 1:
                    return [
                      2,
                      _state.sent()
                    ];
                  case 2:
                    return updatedPackages.push(updatePackage), [
                      4,
                      _this.runInstallTypeCommandAsync([
                        "update",
                        updatePackage,
                        shouldUpdateRepo ? "" : "--no-repo-update"
                      ].filter(Boolean), {
                        formatWarning: function() {
                          var updateMessage = "Failed to update ".concat(chalk_1.default.bold(updatePackage), ". Attempting to update the repo instead.");
                          return updateMessage;
                        },
                        spinner,
                        updatedPackages
                      })
                    ];
                  case 3:
                    return [
                      2,
                      _state.sent()
                    ];
                }
              });
            })();
          }
        },
        {
          key: "_installAsync",
          value: (
            // // If update succeeds, we'll try to install again (skipping `pod install --repo-update`).
            // return await this._installAsync({
            //   spinner,
            //   shouldUpdate: false,
            //   updatedPackages,
            // });
            function() {
              var _param = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _this = this;
              return _async_to_generator31(function() {
                var shouldRepoUpdate, props;
                return _ts_generator31(this, function(_state) {
                  switch (_state.label) {
                    case 0:
                      return shouldRepoUpdate = _param.shouldRepoUpdate, props = _object_without_properties3(_param, [
                        "shouldRepoUpdate"
                      ]), [
                        4,
                        _this.runInstallTypeCommandAsync([
                          "install",
                          shouldRepoUpdate ? "--repo-update" : ""
                        ].filter(Boolean), _object_spread13({
                          formatWarning: function(error) {
                            return getPodRepoUpdateMessage(error.output.join(os_1.default.EOL).trim()).message;
                          }
                        }, props))
                      ];
                    case 1:
                      return [
                        2,
                        _state.sent()
                      ];
                  }
                });
              })();
            }
          )
        },
        {
          key: "runInstallTypeCommandAsync",
          value: function(command) {
            var _param = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _this = this;
            return _async_to_generator31(function() {
              var formatWarning, props, error, warning;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    formatWarning = _param.formatWarning, props = _object_without_properties3(_param, [
                      "formatWarning"
                    ]), _state.label = 1;
                  case 1:
                    return _state.trys.push([
                      1,
                      3,
                      ,
                      5
                    ]), [
                      4,
                      _this._runAsync(command)
                    ];
                  case 2:
                    return [
                      2,
                      _state.sent()
                    ];
                  case 3:
                    return error = _state.sent(), formatWarning && (warning = formatWarning(error), props.spinner && (props.spinner.text = chalk_1.default.bold(warning)), _this.silent || console.warn(chalk_1.default.yellow(warning))), [
                      4,
                      _this.handleInstallErrorAsync(_object_spread13({
                        error
                      }, props))
                    ];
                  case 4:
                    return [
                      2,
                      _state.sent()
                    ];
                  case 5:
                    return [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "addWithParametersAsync",
          value: function(names, parameters) {
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                throw new Error("Unimplemented");
              });
            })();
          }
        },
        {
          key: "addAsync",
          value: function() {
            var names = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            throw new Error("Unimplemented");
          }
        },
        {
          key: "addDevAsync",
          value: function() {
            var names = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            throw new Error("Unimplemented");
          }
        },
        {
          key: "addGlobalAsync",
          value: function() {
            var names = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            throw new Error("Unimplemented");
          }
        },
        {
          key: "removeAsync",
          value: function() {
            var names = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            throw new Error("Unimplemented");
          }
        },
        {
          key: "removeDevAsync",
          value: function() {
            var names = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            throw new Error("Unimplemented");
          }
        },
        {
          key: "removeGlobalAsync",
          value: function() {
            var names = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            throw new Error("Unimplemented");
          }
        },
        {
          key: "versionAsync",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var stdout;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      (0, spawn_async_1.default)("pod", [
                        "--version"
                      ], _this.options)
                    ];
                  case 1:
                    return stdout = _state.sent().stdout, [
                      2,
                      stdout.trim()
                    ];
                }
              });
            })();
          }
        },
        {
          key: "configAsync",
          value: function(key) {
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                throw new Error("Unimplemented");
              });
            })();
          }
        },
        {
          key: "removeLockfileAsync",
          value: function() {
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                throw new Error("Unimplemented");
              });
            })();
          }
        },
        {
          key: "uninstallAsync",
          value: function() {
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                throw new Error("Unimplemented");
              });
            })();
          }
        },
        {
          key: "podRepoUpdateAsync",
          value: (
            // Private
            function() {
              var _this = this;
              return _async_to_generator31(function() {
                var error, _error_stderr;
                return _ts_generator31(this, function(_state) {
                  switch (_state.label) {
                    case 0:
                      return _state.trys.push([
                        0,
                        2,
                        ,
                        3
                      ]), [
                        4,
                        _this._runAsync([
                          "repo",
                          "update"
                        ])
                      ];
                    case 1:
                      return _state.sent(), [
                        3,
                        3
                      ];
                    case 2:
                      throw error = _state.sent(), error.message = error.message || ((_error_stderr = error.stderr) !== null && _error_stderr !== void 0 ? _error_stderr : error.stdout), new CocoaPodsError("The command `pod install --repo-update` failed", "COMMAND_FAILED", error);
                    case 3:
                      return [
                        2
                      ];
                  }
                });
              })();
            }
          )
        },
        {
          key: "_runAsync",
          value: (
            // Exposed for testing
            function(args) {
              var _this = this;
              return _async_to_generator31(function() {
                var promise;
                return _ts_generator31(this, function(_state) {
                  switch (_state.label) {
                    case 0:
                      return _this.silent || console.log("> pod ".concat(args.join(" "))), promise = (0, spawn_async_1.default)("pod", _to_consumable_array16(args).concat([
                        // Enables colors while collecting output.
                        "--ansi"
                      ]), _object_spread_props9(_object_spread13(
                        {},
                        // Add the cwd and other options to the spawn options.
                        _this.options
                      ), {
                        // We use pipe by default instead of inherit so that we can capture stderr/stdout and process it for errors.
                        // This is particularly required for the `pod install --repo-update` error.
                        // Later we'll also pipe the stdout/stderr to the terminal when silent is false,
                        // currently this means we lose out on the ansi colors unless passing the `--ansi` flag to every command.
                        stdio: "pipe"
                      })), _this.silent || promise.child.stdout && promise.child.stdout.pipe(process.stdout), [
                        4,
                        promise
                      ];
                    case 1:
                      return [
                        2,
                        _state.sent()
                      ];
                  }
                });
              })();
            }
          )
        }
      ], [
        {
          key: "getPodProjectRoot",
          value: function(projectRoot) {
            if (CocoaPodsPackageManager2.isUsingPods(projectRoot))
              return projectRoot;
            var iosProject = path_1.default.join(projectRoot, "ios");
            if (CocoaPodsPackageManager2.isUsingPods(iosProject))
              return iosProject;
            var macOsProject = path_1.default.join(projectRoot, "macos");
            return CocoaPodsPackageManager2.isUsingPods(macOsProject) ? macOsProject : null;
          }
        },
        {
          key: "isUsingPods",
          value: function(projectRoot) {
            return (0, fs_1.existsSync)(path_1.default.join(projectRoot, "Podfile"));
          }
        },
        {
          key: "gemInstallCLIAsync",
          value: function() {
            var nonInteractive = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, spawnOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
              stdio: "inherit"
            };
            return _async_to_generator31(function() {
              var options, error;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    options = [
                      "install",
                      "cocoapods",
                      "--no-document"
                    ], _state.label = 1;
                  case 1:
                    return _state.trys.push([
                      1,
                      3,
                      ,
                      5
                    ]), [
                      4,
                      (0, spawn_async_1.default)("gem", options, spawnOptions)
                    ];
                  case 2:
                    return _state.sent(), [
                      3,
                      5
                    ];
                  case 3:
                    if (error = _state.sent(), nonInteractive)
                      throw new CocoaPodsError("Failed to install CocoaPods CLI with gem (recommended)", "COMMAND_FAILED", error);
                    return [
                      4,
                      (0, spawn_1.spawnSudoAsync)([
                        "gem"
                      ].concat(_to_consumable_array16(options)), spawnOptions)
                    ];
                  case 4:
                    return _state.sent(), [
                      3,
                      5
                    ];
                  case 5:
                    return [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "brewLinkCLIAsync",
          value: function() {
            var spawnOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
              stdio: "inherit"
            };
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      (0, spawn_async_1.default)("brew", [
                        "link",
                        "cocoapods"
                      ], spawnOptions)
                    ];
                  case 1:
                    return _state.sent(), [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "brewInstallCLIAsync",
          value: function() {
            var spawnOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
              stdio: "inherit"
            };
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      (0, spawn_async_1.default)("brew", [
                        "install",
                        "cocoapods"
                      ], spawnOptions)
                    ];
                  case 1:
                    return _state.sent(), [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "installCLIAsync",
          value: function(param) {
            var _param_nonInteractive = param.nonInteractive, nonInteractive = _param_nonInteractive === void 0 ? !1 : _param_nonInteractive, _param_spawnOptions = param.spawnOptions, spawnOptions = _param_spawnOptions === void 0 ? {
              stdio: "inherit"
            } : _param_spawnOptions;
            return _async_to_generator31(function() {
              var silent, error, _error_stderr, error1, error2;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    spawnOptions || (spawnOptions = {
                      stdio: "inherit"
                    }), silent = !!spawnOptions.ignoreStdio, _state.label = 1;
                  case 1:
                    return _state.trys.push([
                      1,
                      3,
                      ,
                      14
                    ]), !silent && console.log("\u203A Attempting to install CocoaPods CLI with Gem"), [
                      4,
                      CocoaPodsPackageManager2.gemInstallCLIAsync(nonInteractive, spawnOptions)
                    ];
                  case 2:
                    return _state.sent(), !silent && console.log("\u203A Successfully installed CocoaPods CLI with Gem"), [
                      2,
                      !0
                    ];
                  case 3:
                    error = _state.sent(), silent || (console.log(chalk_1.default.yellow("\u203A Failed to install CocoaPods CLI with Gem")), console.log(chalk_1.default.red((_error_stderr = error.stderr) !== null && _error_stderr !== void 0 ? _error_stderr : error.message)), console.log("\u203A Attempting to install CocoaPods CLI with Homebrew")), _state.label = 4;
                  case 4:
                    return _state.trys.push([
                      4,
                      12,
                      ,
                      13
                    ]), [
                      4,
                      CocoaPodsPackageManager2.brewInstallCLIAsync(spawnOptions)
                    ];
                  case 5:
                    return _state.sent(), [
                      4,
                      CocoaPodsPackageManager2.isCLIInstalledAsync(spawnOptions)
                    ];
                  case 6:
                    if (_state.sent())
                      return [
                        3,
                        11
                      ];
                    _state.label = 7;
                  case 7:
                    return _state.trys.push([
                      7,
                      10,
                      ,
                      11
                    ]), [
                      4,
                      CocoaPodsPackageManager2.brewLinkCLIAsync(spawnOptions)
                    ];
                  case 8:
                    return _state.sent(), [
                      4,
                      CocoaPodsPackageManager2.isCLIInstalledAsync(spawnOptions)
                    ];
                  case 9:
                    if (!_state.sent())
                      throw new CocoaPodsError("CLI could not be installed automatically with gem or Homebrew, please install CocoaPods manually and try again", "NO_CLI", error);
                    return [
                      3,
                      11
                    ];
                  case 10:
                    throw error1 = _state.sent(), new CocoaPodsError("Homebrew installation appeared to succeed but CocoaPods CLI not found in PATH and unable to link.", "NO_CLI", error1);
                  case 11:
                    return !silent && console.log("\u203A Successfully installed CocoaPods CLI with Homebrew"), [
                      2,
                      !0
                    ];
                  case 12:
                    throw error2 = _state.sent(), !silent && console.warn(chalk_1.default.yellow("\u203A Failed to install CocoaPods with Homebrew. Please install CocoaPods CLI manually and try again.")), new CocoaPodsError("Failed to install CocoaPods with Homebrew. Please install CocoaPods CLI manually and try again.", "NO_CLI", error2);
                  case 13:
                    return [
                      3,
                      14
                    ];
                  case 14:
                    return [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "isAvailable",
          value: function(projectRoot, silent) {
            return process.platform !== "darwin" ? (!silent && console.log(chalk_1.default.red("CocoaPods is only supported on macOS machines")), !1) : CocoaPodsPackageManager2.isUsingPods(projectRoot) ? !0 : (!silent && console.log(chalk_1.default.yellow("CocoaPods is not supported in this project")), !1);
          }
        },
        {
          key: "isCLIInstalledAsync",
          value: function() {
            var spawnOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
              stdio: "inherit"
            };
            return _async_to_generator31(function() {
              var e;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return _state.trys.push([
                      0,
                      2,
                      ,
                      3
                    ]), [
                      4,
                      (0, spawn_async_1.default)("pod", [
                        "--version"
                      ], spawnOptions)
                    ];
                  case 1:
                    return _state.sent(), [
                      2,
                      !0
                    ];
                  case 2:
                    return e = _state.sent(), [
                      2,
                      !1
                    ];
                  case 3:
                    return [
                      2
                    ];
                }
              });
            })();
          }
        }
      ]), CocoaPodsPackageManager2;
    }();
    exports2.CocoaPodsPackageManager = CocoaPodsPackageManager;
    function shouldPodRepoUpdate(errorOutput) {
      var output = errorOutput, isPodRepoUpdateError = output.includes("pod repo update") || output.includes("--no-repo-update");
      return isPodRepoUpdateError;
    }
    function getPodUpdateMessage(output) {
      var props = output.match(/run ['"`]pod update ([\w-_\d/]+)( --no-repo-update)?['"`] to apply changes/), _props_;
      return {
        updatePackage: (_props_ = props == null ? void 0 : props[1]) !== null && _props_ !== void 0 ? _props_ : null,
        shouldUpdateRepo: !(props != null && props[2])
      };
    }
    exports2.getPodUpdateMessage = getPodUpdateMessage;
    function getPodRepoUpdateMessage(errorOutput) {
      var warningInfo = extractMissingDependencyError(errorOutput), brokenPackage = getPodUpdateMessage(errorOutput), message;
      return warningInfo ? message = "Couldn't install: ".concat(warningInfo[1], " \xBB ").concat(chalk_1.default.underline(warningInfo[0]), ".") : brokenPackage != null && brokenPackage.updatePackage ? message = "Couldn't install: ".concat(brokenPackage == null ? void 0 : brokenPackage.updatePackage, ".") : message = "Couldn't install Pods.", message += " Updating the Pods project and trying again...", _object_spread13({
        message
      }, brokenPackage);
    }
    exports2.getPodRepoUpdateMessage = getPodRepoUpdateMessage;
    function getImprovedPodInstallError(error, param) {
      var _param_cwd = param.cwd, cwd2 = _param_cwd === void 0 ? process.cwd() : _param_cwd, errorOutput = error.output.join(os_1.default.EOL).trim();
      if (error.stdout.match(/No [`'"]Podfile[`'"] found in the project directory/))
        error.message = "No Podfile found in directory: ".concat(cwd2, ". Ensure CocoaPods is setup any try again.");
      else if (shouldPodRepoUpdate(errorOutput)) {
        var warningInfo = extractMissingDependencyError(errorOutput), reason;
        warningInfo ? reason = "Couldn't install: ".concat(warningInfo[1], " \xBB ").concat(chalk_1.default.underline(warningInfo[0])) : reason = "This is often due to native package versions mismatching";
        var solution;
        if (warningInfo != null && warningInfo[0] ? warningInfo[0].match(/^(?:@?expo|@?react)(-|\/)/) ? solution = 'Ensure the node module "'.concat(warningInfo[0], `" is installed in your project, then run 'npx pod-install' to try again.`) : solution = 'Ensure the CocoaPod "'.concat(warningInfo[0], `" is installed in your project, then run 'npx pod-install' to try again.`) : solution = "Try deleting the 'ios/Pods' folder or the 'ios/Podfile.lock' file and running 'npx pod-install' to resolve.", error.message = "".concat(reason, ". ").concat(solution), error.stdout) {
          var cocoapodsDebugInfo = error.stdout.split(os_1.default.EOL), firstWarning = cocoapodsDebugInfo.findIndex(function(v) {
            return v.startsWith("[!]");
          });
          if (firstWarning !== -1) {
            var warning = cocoapodsDebugInfo.slice(firstWarning).join(os_1.default.EOL);
            error.message += `

`.concat(chalk_1.default.gray(warning));
          }
        }
        return new CocoaPodsError("Command `pod install --repo-update` failed.", "COMMAND_FAILED", error);
      } else {
        var _error_stdout_match, stderr = error.stderr.trim(), usefulError = (_error_stdout_match = error.stdout.match(/\[!\]\s((?:.|\n)*)/)) === null || _error_stdout_match === void 0 ? void 0 : _error_stdout_match[1];
        if (usefulError) {
          var _error_message;
          !((_error_message = error.message) === null || _error_message === void 0) && _error_message.match(/pod exited with non-zero code: 1/) && (error.message = ""), stderr = null;
        }
        error.message = [
          usefulError,
          error.message,
          stderr
        ].filter(Boolean).join(`
`);
      }
      return new CocoaPodsError("Command `pod install` failed.", "COMMAND_FAILED", error);
    }
    exports2.getImprovedPodInstallError = getImprovedPodInstallError;
  }
});

// ../../node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "../../node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match2) {
      var token = {
        type: "invalid",
        value: match2[0],
        closed: void 0
      };
      return match2[1] ? (token.type = "string", token.closed = !!(match2[3] || match2[4])) : match2[5] ? token.type = "comment" : match2[6] ? (token.type = "comment", token.closed = !!match2[7]) : match2[8] ? token.type = "regex" : match2[9] ? token.type = "number" : match2[10] ? token.type = "name" : match2[11] ? token.type = "punctuator" : match2[12] && (token.type = "whitespace"), token;
    };
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [
      0,
      11,
      2,
      25,
      2,
      18,
      2,
      1,
      2,
      14,
      3,
      13,
      35,
      122,
      70,
      52,
      268,
      28,
      4,
      48,
      48,
      31,
      14,
      29,
      6,
      37,
      11,
      29,
      3,
      35,
      5,
      7,
      2,
      4,
      43,
      157,
      19,
      35,
      5,
      35,
      5,
      39,
      9,
      51,
      13,
      10,
      2,
      14,
      2,
      6,
      2,
      1,
      2,
      10,
      2,
      14,
      2,
      6,
      2,
      1,
      68,
      310,
      10,
      21,
      11,
      7,
      25,
      5,
      2,
      41,
      2,
      8,
      70,
      5,
      3,
      0,
      2,
      43,
      2,
      1,
      4,
      0,
      3,
      22,
      11,
      22,
      10,
      30,
      66,
      18,
      2,
      1,
      11,
      21,
      11,
      25,
      71,
      55,
      7,
      1,
      65,
      0,
      16,
      3,
      2,
      2,
      2,
      28,
      43,
      28,
      4,
      28,
      36,
      7,
      2,
      27,
      28,
      53,
      11,
      21,
      11,
      18,
      14,
      17,
      111,
      72,
      56,
      50,
      14,
      50,
      14,
      35,
      349,
      41,
      7,
      1,
      79,
      28,
      11,
      0,
      9,
      21,
      43,
      17,
      47,
      20,
      28,
      22,
      13,
      52,
      58,
      1,
      3,
      0,
      14,
      44,
      33,
      24,
      27,
      35,
      30,
      0,
      3,
      0,
      9,
      34,
      4,
      0,
      13,
      47,
      15,
      3,
      22,
      0,
      2,
      0,
      36,
      17,
      2,
      24,
      20,
      1,
      64,
      6,
      2,
      0,
      2,
      3,
      2,
      14,
      2,
      9,
      8,
      46,
      39,
      7,
      3,
      1,
      3,
      21,
      2,
      6,
      2,
      1,
      2,
      4,
      4,
      0,
      19,
      0,
      13,
      4,
      159,
      52,
      19,
      3,
      21,
      2,
      31,
      47,
      21,
      1,
      2,
      0,
      185,
      46,
      42,
      3,
      37,
      47,
      21,
      0,
      60,
      42,
      14,
      0,
      72,
      26,
      38,
      6,
      186,
      43,
      117,
      63,
      32,
      7,
      3,
      0,
      3,
      7,
      2,
      1,
      2,
      23,
      16,
      0,
      2,
      0,
      95,
      7,
      3,
      38,
      17,
      0,
      2,
      0,
      29,
      0,
      11,
      39,
      8,
      0,
      22,
      0,
      12,
      45,
      20,
      0,
      19,
      72,
      264,
      8,
      2,
      36,
      18,
      0,
      50,
      29,
      113,
      6,
      2,
      1,
      2,
      37,
      22,
      0,
      26,
      5,
      2,
      1,
      2,
      31,
      15,
      0,
      328,
      18,
      16,
      0,
      2,
      12,
      2,
      33,
      125,
      0,
      80,
      921,
      103,
      110,
      18,
      195,
      2637,
      96,
      16,
      1071,
      18,
      5,
      4026,
      582,
      8634,
      568,
      8,
      30,
      18,
      78,
      18,
      29,
      19,
      47,
      17,
      3,
      32,
      20,
      6,
      18,
      689,
      63,
      129,
      74,
      6,
      0,
      67,
      12,
      65,
      1,
      2,
      0,
      29,
      6135,
      9,
      1237,
      43,
      8,
      8936,
      3,
      2,
      6,
      2,
      1,
      2,
      290,
      16,
      0,
      30,
      2,
      3,
      0,
      15,
      3,
      9,
      395,
      2309,
      106,
      6,
      12,
      4,
      8,
      8,
      9,
      5991,
      84,
      2,
      70,
      2,
      1,
      3,
      0,
      3,
      1,
      3,
      3,
      2,
      11,
      2,
      0,
      2,
      6,
      2,
      64,
      2,
      3,
      3,
      7,
      2,
      6,
      2,
      27,
      2,
      3,
      2,
      4,
      2,
      0,
      4,
      6,
      2,
      339,
      3,
      24,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      7,
      1845,
      30,
      7,
      5,
      262,
      61,
      147,
      44,
      11,
      6,
      17,
      0,
      322,
      29,
      19,
      43,
      485,
      27,
      757,
      6,
      2,
      3,
      2,
      1,
      2,
      14,
      2,
      196,
      60,
      67,
      8,
      0,
      1205,
      3,
      2,
      26,
      2,
      1,
      2,
      0,
      3,
      0,
      2,
      9,
      2,
      3,
      2,
      0,
      2,
      0,
      7,
      0,
      5,
      0,
      2,
      0,
      2,
      0,
      2,
      2,
      2,
      1,
      2,
      0,
      3,
      0,
      2,
      0,
      2,
      0,
      2,
      0,
      2,
      0,
      2,
      1,
      2,
      0,
      3,
      3,
      2,
      6,
      2,
      3,
      2,
      3,
      2,
      0,
      2,
      9,
      2,
      16,
      6,
      2,
      2,
      4,
      2,
      16,
      4421,
      42719,
      33,
      4153,
      7,
      221,
      3,
      5761,
      15,
      7472,
      16,
      621,
      2467,
      541,
      1507,
      4938,
      6,
      4191
    ], astralIdentifierCodes = [
      509,
      0,
      227,
      0,
      150,
      4,
      294,
      9,
      1368,
      2,
      2,
      1,
      6,
      3,
      41,
      2,
      5,
      0,
      166,
      1,
      574,
      3,
      9,
      9,
      370,
      1,
      81,
      2,
      71,
      10,
      50,
      3,
      123,
      2,
      54,
      14,
      32,
      10,
      3,
      1,
      11,
      3,
      46,
      10,
      8,
      0,
      46,
      9,
      7,
      2,
      37,
      13,
      2,
      9,
      6,
      1,
      45,
      0,
      13,
      2,
      49,
      13,
      9,
      3,
      2,
      11,
      83,
      11,
      7,
      0,
      3,
      0,
      158,
      11,
      6,
      9,
      7,
      3,
      56,
      1,
      2,
      6,
      3,
      1,
      3,
      2,
      10,
      0,
      11,
      1,
      3,
      6,
      4,
      4,
      193,
      17,
      10,
      9,
      5,
      0,
      82,
      19,
      13,
      9,
      214,
      6,
      3,
      8,
      28,
      1,
      83,
      16,
      16,
      9,
      82,
      12,
      9,
      9,
      84,
      14,
      5,
      9,
      243,
      14,
      166,
      9,
      71,
      5,
      2,
      1,
      3,
      3,
      2,
      0,
      2,
      1,
      13,
      9,
      120,
      6,
      3,
      6,
      4,
      0,
      29,
      9,
      41,
      6,
      2,
      3,
      9,
      0,
      10,
      10,
      47,
      15,
      406,
      7,
      2,
      7,
      17,
      9,
      57,
      21,
      2,
      13,
      123,
      5,
      4,
      0,
      2,
      1,
      2,
      6,
      2,
      0,
      9,
      9,
      49,
      4,
      2,
      1,
      2,
      4,
      9,
      9,
      330,
      3,
      10,
      1,
      2,
      0,
      49,
      6,
      4,
      4,
      14,
      9,
      5351,
      0,
      7,
      14,
      13835,
      9,
      87,
      9,
      39,
      4,
      60,
      6,
      26,
      9,
      1014,
      0,
      2,
      54,
      8,
      3,
      82,
      0,
      12,
      1,
      19628,
      1,
      4706,
      45,
      3,
      22,
      543,
      4,
      4,
      5,
      9,
      7,
      3,
      6,
      31,
      3,
      149,
      2,
      1418,
      49,
      513,
      54,
      5,
      49,
      9,
      0,
      15,
      0,
      23,
      4,
      2,
      14,
      1361,
      6,
      2,
      16,
      3,
      6,
      2,
      1,
      2,
      4,
      101,
      0,
      161,
      6,
      10,
      9,
      357,
      0,
      62,
      13,
      499,
      13,
      983,
      6,
      110,
      6,
      6,
      9,
      4759,
      9,
      787719,
      239
    ];
    function isInAstralSet(code, set3) {
      for (var pos = 65536, i = 0, length = set3.length; i < length; i += 2) {
        if (pos += set3[i], pos > code)
          return !1;
        if (pos += set3[i + 1], pos >= code)
          return !0;
      }
      return !1;
    }
    function isIdentifierStart(code) {
      return code < 65 ? code === 36 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      return code < 48 ? code === 36 : code < 58 ? !0 : code < 65 ? !1 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      for (var isFirst = !0, i = 0; i < name.length; i++) {
        var cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          var trail = name.charCodeAt(++i);
          (trail & 64512) === 56320 && (cp = 65536 + ((cp & 1023) << 10) + (trail & 1023));
        }
        if (isFirst) {
          if (isFirst = !1, !isIdentifierStart(cp))
            return !1;
        } else if (!isIdentifierChar(cp))
          return !1;
      }
      return !isFirst;
    }
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords2 = {
      keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
      ],
      strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
      ],
      strictBind: [
        "eval",
        "arguments"
      ]
    }, keywords = new Set(reservedWords2.keyword), reservedWordsStrictSet = new Set(reservedWords2.strict), reservedWordsStrictBindSet = new Set(reservedWords2.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: !0,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier(), _keyword = require_keyword();
  }
});

// ../../node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str != "string")
        throw new TypeError("Expected a string");
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      aliceblue: [
        240,
        248,
        255
      ],
      antiquewhite: [
        250,
        235,
        215
      ],
      aqua: [
        0,
        255,
        255
      ],
      aquamarine: [
        127,
        255,
        212
      ],
      azure: [
        240,
        255,
        255
      ],
      beige: [
        245,
        245,
        220
      ],
      bisque: [
        255,
        228,
        196
      ],
      black: [
        0,
        0,
        0
      ],
      blanchedalmond: [
        255,
        235,
        205
      ],
      blue: [
        0,
        0,
        255
      ],
      blueviolet: [
        138,
        43,
        226
      ],
      brown: [
        165,
        42,
        42
      ],
      burlywood: [
        222,
        184,
        135
      ],
      cadetblue: [
        95,
        158,
        160
      ],
      chartreuse: [
        127,
        255,
        0
      ],
      chocolate: [
        210,
        105,
        30
      ],
      coral: [
        255,
        127,
        80
      ],
      cornflowerblue: [
        100,
        149,
        237
      ],
      cornsilk: [
        255,
        248,
        220
      ],
      crimson: [
        220,
        20,
        60
      ],
      cyan: [
        0,
        255,
        255
      ],
      darkblue: [
        0,
        0,
        139
      ],
      darkcyan: [
        0,
        139,
        139
      ],
      darkgoldenrod: [
        184,
        134,
        11
      ],
      darkgray: [
        169,
        169,
        169
      ],
      darkgreen: [
        0,
        100,
        0
      ],
      darkgrey: [
        169,
        169,
        169
      ],
      darkkhaki: [
        189,
        183,
        107
      ],
      darkmagenta: [
        139,
        0,
        139
      ],
      darkolivegreen: [
        85,
        107,
        47
      ],
      darkorange: [
        255,
        140,
        0
      ],
      darkorchid: [
        153,
        50,
        204
      ],
      darkred: [
        139,
        0,
        0
      ],
      darksalmon: [
        233,
        150,
        122
      ],
      darkseagreen: [
        143,
        188,
        143
      ],
      darkslateblue: [
        72,
        61,
        139
      ],
      darkslategray: [
        47,
        79,
        79
      ],
      darkslategrey: [
        47,
        79,
        79
      ],
      darkturquoise: [
        0,
        206,
        209
      ],
      darkviolet: [
        148,
        0,
        211
      ],
      deeppink: [
        255,
        20,
        147
      ],
      deepskyblue: [
        0,
        191,
        255
      ],
      dimgray: [
        105,
        105,
        105
      ],
      dimgrey: [
        105,
        105,
        105
      ],
      dodgerblue: [
        30,
        144,
        255
      ],
      firebrick: [
        178,
        34,
        34
      ],
      floralwhite: [
        255,
        250,
        240
      ],
      forestgreen: [
        34,
        139,
        34
      ],
      fuchsia: [
        255,
        0,
        255
      ],
      gainsboro: [
        220,
        220,
        220
      ],
      ghostwhite: [
        248,
        248,
        255
      ],
      gold: [
        255,
        215,
        0
      ],
      goldenrod: [
        218,
        165,
        32
      ],
      gray: [
        128,
        128,
        128
      ],
      green: [
        0,
        128,
        0
      ],
      greenyellow: [
        173,
        255,
        47
      ],
      grey: [
        128,
        128,
        128
      ],
      honeydew: [
        240,
        255,
        240
      ],
      hotpink: [
        255,
        105,
        180
      ],
      indianred: [
        205,
        92,
        92
      ],
      indigo: [
        75,
        0,
        130
      ],
      ivory: [
        255,
        255,
        240
      ],
      khaki: [
        240,
        230,
        140
      ],
      lavender: [
        230,
        230,
        250
      ],
      lavenderblush: [
        255,
        240,
        245
      ],
      lawngreen: [
        124,
        252,
        0
      ],
      lemonchiffon: [
        255,
        250,
        205
      ],
      lightblue: [
        173,
        216,
        230
      ],
      lightcoral: [
        240,
        128,
        128
      ],
      lightcyan: [
        224,
        255,
        255
      ],
      lightgoldenrodyellow: [
        250,
        250,
        210
      ],
      lightgray: [
        211,
        211,
        211
      ],
      lightgreen: [
        144,
        238,
        144
      ],
      lightgrey: [
        211,
        211,
        211
      ],
      lightpink: [
        255,
        182,
        193
      ],
      lightsalmon: [
        255,
        160,
        122
      ],
      lightseagreen: [
        32,
        178,
        170
      ],
      lightskyblue: [
        135,
        206,
        250
      ],
      lightslategray: [
        119,
        136,
        153
      ],
      lightslategrey: [
        119,
        136,
        153
      ],
      lightsteelblue: [
        176,
        196,
        222
      ],
      lightyellow: [
        255,
        255,
        224
      ],
      lime: [
        0,
        255,
        0
      ],
      limegreen: [
        50,
        205,
        50
      ],
      linen: [
        250,
        240,
        230
      ],
      magenta: [
        255,
        0,
        255
      ],
      maroon: [
        128,
        0,
        0
      ],
      mediumaquamarine: [
        102,
        205,
        170
      ],
      mediumblue: [
        0,
        0,
        205
      ],
      mediumorchid: [
        186,
        85,
        211
      ],
      mediumpurple: [
        147,
        112,
        219
      ],
      mediumseagreen: [
        60,
        179,
        113
      ],
      mediumslateblue: [
        123,
        104,
        238
      ],
      mediumspringgreen: [
        0,
        250,
        154
      ],
      mediumturquoise: [
        72,
        209,
        204
      ],
      mediumvioletred: [
        199,
        21,
        133
      ],
      midnightblue: [
        25,
        25,
        112
      ],
      mintcream: [
        245,
        255,
        250
      ],
      mistyrose: [
        255,
        228,
        225
      ],
      moccasin: [
        255,
        228,
        181
      ],
      navajowhite: [
        255,
        222,
        173
      ],
      navy: [
        0,
        0,
        128
      ],
      oldlace: [
        253,
        245,
        230
      ],
      olive: [
        128,
        128,
        0
      ],
      olivedrab: [
        107,
        142,
        35
      ],
      orange: [
        255,
        165,
        0
      ],
      orangered: [
        255,
        69,
        0
      ],
      orchid: [
        218,
        112,
        214
      ],
      palegoldenrod: [
        238,
        232,
        170
      ],
      palegreen: [
        152,
        251,
        152
      ],
      paleturquoise: [
        175,
        238,
        238
      ],
      palevioletred: [
        219,
        112,
        147
      ],
      papayawhip: [
        255,
        239,
        213
      ],
      peachpuff: [
        255,
        218,
        185
      ],
      peru: [
        205,
        133,
        63
      ],
      pink: [
        255,
        192,
        203
      ],
      plum: [
        221,
        160,
        221
      ],
      powderblue: [
        176,
        224,
        230
      ],
      purple: [
        128,
        0,
        128
      ],
      rebeccapurple: [
        102,
        51,
        153
      ],
      red: [
        255,
        0,
        0
      ],
      rosybrown: [
        188,
        143,
        143
      ],
      royalblue: [
        65,
        105,
        225
      ],
      saddlebrown: [
        139,
        69,
        19
      ],
      salmon: [
        250,
        128,
        114
      ],
      sandybrown: [
        244,
        164,
        96
      ],
      seagreen: [
        46,
        139,
        87
      ],
      seashell: [
        255,
        245,
        238
      ],
      sienna: [
        160,
        82,
        45
      ],
      silver: [
        192,
        192,
        192
      ],
      skyblue: [
        135,
        206,
        235
      ],
      slateblue: [
        106,
        90,
        205
      ],
      slategray: [
        112,
        128,
        144
      ],
      slategrey: [
        112,
        128,
        144
      ],
      snow: [
        255,
        250,
        250
      ],
      springgreen: [
        0,
        255,
        127
      ],
      steelblue: [
        70,
        130,
        180
      ],
      tan: [
        210,
        180,
        140
      ],
      teal: [
        0,
        128,
        128
      ],
      thistle: [
        216,
        191,
        216
      ],
      tomato: [
        255,
        99,
        71
      ],
      turquoise: [
        64,
        224,
        208
      ],
      violet: [
        238,
        130,
        238
      ],
      wheat: [
        245,
        222,
        179
      ],
      white: [
        255,
        255,
        255
      ],
      whitesmoke: [
        245,
        245,
        245
      ],
      yellow: [
        255,
        255,
        0
      ],
      yellowgreen: [
        154,
        205,
        50
      ]
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2(), reverseKeywords = {};
    for (key in cssKeywords)
      cssKeywords.hasOwnProperty(key) && (reverseKeywords[cssKeywords[key]] = key);
    var key, convert = module2.exports = {
      rgb: {
        channels: 3,
        labels: "rgb"
      },
      hsl: {
        channels: 3,
        labels: "hsl"
      },
      hsv: {
        channels: 3,
        labels: "hsv"
      },
      hwb: {
        channels: 3,
        labels: "hwb"
      },
      cmyk: {
        channels: 4,
        labels: "cmyk"
      },
      xyz: {
        channels: 3,
        labels: "xyz"
      },
      lab: {
        channels: 3,
        labels: "lab"
      },
      lch: {
        channels: 3,
        labels: "lch"
      },
      hex: {
        channels: 1,
        labels: [
          "hex"
        ]
      },
      keyword: {
        channels: 1,
        labels: [
          "keyword"
        ]
      },
      ansi16: {
        channels: 1,
        labels: [
          "ansi16"
        ]
      },
      ansi256: {
        channels: 1,
        labels: [
          "ansi256"
        ]
      },
      hcg: {
        channels: 3,
        labels: [
          "h",
          "c",
          "g"
        ]
      },
      apple: {
        channels: 3,
        labels: [
          "r16",
          "g16",
          "b16"
        ]
      },
      gray: {
        channels: 1,
        labels: [
          "gray"
        ]
      }
    };
    for (model in convert)
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model]))
          throw new Error("missing channels property: " + model);
        if (!("labels" in convert[model]))
          throw new Error("missing channel labels property: " + model);
        if (convert[model].labels.length !== convert[model].channels)
          throw new Error("channel and label counts mismatch: " + model);
        channels = convert[model].channels, labels = convert[model].labels, delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", {
          value: channels
        }), Object.defineProperty(convert[model], "labels", {
          value: labels
        });
      }
    var channels, labels, model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
      return max === min ? h = 0 : r === max ? h = (g - b) / delta : g === max ? h = 2 + (b - r) / delta : b === max && (h = 4 + (r - g) / delta), h = Math.min(h * 60, 360), h < 0 && (h += 360), l = (min + max) / 2, max === min ? s = 0 : l <= 0.5 ? s = delta / (max + min) : s = delta / (2 - max - min), [
        h,
        s * 100,
        l * 100
      ];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif, gdif, bdif, h, s, r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, v = Math.max(r, g, b), diff = v - Math.min(r, g, b), diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      return diff === 0 ? h = s = 0 : (s = diff / v, rdif = diffc(r), gdif = diffc(g), bdif = diffc(b), r === v ? h = bdif - gdif : g === v ? h = 1 / 3 + rdif - bdif : b === v && (h = 2 / 3 + gdif - rdif), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0], g = rgb[1], b = rgb[2], h = convert.rgb.hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b));
      return b = 1 - 1 / 255 * Math.max(r, Math.max(g, b)), [
        h,
        w * 100,
        b * 100
      ];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, c, m, y, k;
      return k = Math.min(1 - r, 1 - g, 1 - b), c = (1 - r - k) / (1 - k) || 0, m = (1 - g - k) / (1 - k) || 0, y = (1 - b - k) / (1 - k) || 0, [
        c * 100,
        m * 100,
        y * 100,
        k * 100
      ];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed)
        return reversed;
      var currentClosestDistance = 1 / 0, currentClosestKeyword;
      for (var keyword in cssKeywords)
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword], distance = comparativeDistance(rgb, value);
          distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
        }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92, b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805, y = r * 0.2126 + g * 0.7152 + b * 0.0722, z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [
        x * 100,
        y * 100,
        z * 100
      ];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb), x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      return x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116, l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z), [
        l,
        a,
        b
      ];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val;
      if (s === 0)
        return val = l * 255, [
          val,
          val,
          val
        ];
      l < 0.5 ? t2 = l * (1 + s) : t2 = l + s - l * s, t1 = 2 * l - t2, rgb = [
        0,
        0,
        0
      ];
      for (var i = 0; i < 3; i++)
        t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb[i] = val * 255;
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, smin = s, lmin = Math.max(l, 0.01), sv, v;
      return l *= 2, s *= l <= 1 ? l : 2 - l, smin *= lmin <= 1 ? lmin : 2 - lmin, v = (l + s) / 2, sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s), [
        h,
        sv * 100,
        v * 100
      ];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60, s = hsv[1] / 100, v = hsv[2] / 100, hi = Math.floor(h) % 6, f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f));
      switch (v *= 255, hi) {
        case 0:
          return [
            v,
            t,
            p
          ];
        case 1:
          return [
            q,
            v,
            p
          ];
        case 2:
          return [
            p,
            v,
            t
          ];
        case 3:
          return [
            p,
            q,
            v
          ];
        case 4:
          return [
            t,
            p,
            v
          ];
        case 5:
          return [
            v,
            p,
            q
          ];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, vmin = Math.max(v, 0.01), lmin, sl, l;
      return l = (2 - s) * v, lmin = (2 - s) * vmin, sl = s * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l /= 2, [
        h,
        sl * 100,
        l * 100
      ];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, i, v, f, n;
      ratio > 1 && (wh /= ratio, bl /= ratio), i = Math.floor(6 * h), v = 1 - bl, f = 6 * h - i, i & 1 && (f = 1 - f), n = wh + f * (v - wh);
      var r, g, b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v, g = n, b = wh;
          break;
        case 1:
          r = n, g = v, b = wh;
          break;
        case 2:
          r = wh, g = v, b = n;
          break;
        case 3:
          r = wh, g = n, b = v;
          break;
        case 4:
          r = n, g = wh, b = v;
          break;
        case 5:
          r = v, g = wh, b = n;
          break;
      }
      return [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100, r, g, b;
      return r = 1 - Math.min(1, c * (1 - k) + k), g = 1 - Math.min(1, m * (1 - k) + k), b = 1 - Math.min(1, y * (1 - k) + k), [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100, r, g, b;
      return r = x * 3.2406 + y * -1.5372 + z * -0.4986, g = x * -0.9689 + y * 1.8758 + z * 0.0415, b = x * 0.0557 + y * -0.204 + z * 1.057, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92, g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92, b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92, r = Math.min(Math.max(0, r), 1), g = Math.min(Math.max(0, g), 1), b = Math.min(Math.max(0, b), 1), [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      return x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116, l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z), [
        l,
        a,
        b
      ];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], x, y, z;
      y = (l + 16) / 116, x = a / 500 + y, z = y - b / 200;
      var y2 = Math.pow(y, 3), x2 = Math.pow(x, 3), z2 = Math.pow(z, 3);
      return y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787, x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787, z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787, x *= 95.047, y *= 100, z *= 108.883, [
        x,
        y,
        z
      ];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], hr, h, c;
      return hr = Math.atan2(b, a), h = hr * 360 / 2 / Math.PI, h < 0 && (h += 360), c = Math.sqrt(a * a + b * b), [
        l,
        c,
        h
      ];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0], c = lch[1], h = lch[2], a, b, hr;
      return hr = h / 360 * 2 * Math.PI, a = c * Math.cos(hr), b = c * Math.sin(hr), [
        l,
        a,
        b
      ];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0], g = args[1], b = args[2], value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      if (value = Math.round(value / 50), value === 0)
        return 30;
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      return value === 2 && (ansi += 60), ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0], g = args[1], b = args[2];
      if (r === g && g === b)
        return r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232;
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7)
        return args > 50 && (color += 3.5), color = color / 10.5 * 255, [
          color,
          color,
          color
        ];
      var mult = (~~(args > 50) + 1) * 0.5, r = (color & 1) * mult * 255, g = (color >> 1 & 1) * mult * 255, b = (color >> 2 & 1) * mult * 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [
          c,
          c,
          c
        ];
      }
      args -= 16;
      var rem, r = Math.floor(args / 36) / 5 * 255, g = Math.floor((rem = args % 36) / 6) / 5 * 255, b = rem % 6 / 5 * 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255), string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2)
        return [
          0,
          0,
          0
        ];
      var colorString = match2[0];
      match2[0].length === 3 && (colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join(""));
      var integer = parseInt(colorString, 16), r = integer >> 16 & 255, g = integer >> 8 & 255, b = integer & 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, max = Math.max(Math.max(r, g), b), min = Math.min(Math.min(r, g), b), chroma = max - min, grayscale, hue;
      return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r ? hue = (g - b) / chroma % 6 : max === g ? hue = 2 + (b - r) / chroma : hue = 4 + (r - g) / chroma + 4, hue /= 6, hue %= 1, [
        hue * 360,
        chroma * 100,
        grayscale * 100
      ];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100, l = hsl[2] / 100, c = 1, f = 0;
      return l < 0.5 ? c = 2 * s * l : c = 2 * s * (1 - l), c < 1 && (f = (l - 0.5 * c) / (1 - c)), [
        hsl[0],
        c * 100,
        f * 100
      ];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100, v = hsv[2] / 100, c = s * v, f = 0;
      return c < 1 && (f = (v - c) / (1 - c)), [
        hsv[0],
        c * 100,
        f * 100
      ];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360, c = hcg[1] / 100, g = hcg[2] / 100;
      if (c === 0)
        return [
          g * 255,
          g * 255,
          g * 255
        ];
      var pure = [
        0,
        0,
        0
      ], hi = h % 1 * 6, v = hi % 1, w = 1 - v, mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1, pure[1] = v, pure[2] = 0;
          break;
        case 1:
          pure[0] = w, pure[1] = 1, pure[2] = 0;
          break;
        case 2:
          pure[0] = 0, pure[1] = 1, pure[2] = v;
          break;
        case 3:
          pure[0] = 0, pure[1] = w, pure[2] = 1;
          break;
        case 4:
          pure[0] = v, pure[1] = 0, pure[2] = 1;
          break;
        default:
          pure[0] = 1, pure[1] = 0, pure[2] = w;
      }
      return mg = (1 - c) * g, [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c), f = 0;
      return v > 0 && (f = c / v), [
        hcg[0],
        f * 100,
        v * 100
      ];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, l = g * (1 - c) + 0.5 * c, s = 0;
      return l > 0 && l < 0.5 ? s = c / (2 * l) : l >= 0.5 && l < 1 && (s = c / (2 * (1 - l))), [
        hcg[0],
        s * 100,
        l * 100
      ];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c);
      return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
      ];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100, b = hwb[2] / 100, v = 1 - b, c = v - w, g = 0;
      return c < 1 && (g = (v - c) / (1 - c)), [
        hwb[0],
        c * 100,
        g * 100
      ];
    };
    convert.apple.rgb = function(apple) {
      return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
      ];
    };
    convert.rgb.apple = function(rgb) {
      return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
      ];
    };
    convert.gray.rgb = function(args) {
      return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
      ];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [
        0,
        0,
        args[0]
      ];
    };
    convert.gray.hwb = function(gray) {
      return [
        0,
        100,
        gray[0]
      ];
    };
    convert.gray.cmyk = function(gray) {
      return [
        0,
        0,
        0,
        gray[0]
      ];
    };
    convert.gray.lab = function(gray) {
      return [
        gray[0],
        0,
        0
      ];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255, integer = (val << 16) + (val << 8) + val, string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [
        val / 255 * 100
      ];
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      for (var graph = {}, models = Object.keys(conversions), len = models.length, i = 0; i < len; i++)
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph(), queue = [
        fromModel
      ];
      for (graph[fromModel].distance = 0; queue.length; )
        for (var current = queue.pop(), adjacents = Object.keys(conversions[current]), len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i], node = graph[adjacent];
          node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
        }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      for (var path6 = [
        graph[toModel].parent,
        toModel
      ], fn = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent; graph[cur].parent; )
        path6.unshift(graph[cur].parent), fn = link(conversions[graph[cur].parent][cur], fn), cur = graph[cur].parent;
      return fn.conversion = path6, fn;
    }
    module2.exports = function(fromModel) {
      for (var graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph), len = models.length, i = 0; i < len; i++) {
        var toModel = models[i], node = graph[toModel];
        node.parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
      }
      return conversion;
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2(), route = require_route2(), convert = {}, models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        return args == null ? args : (arguments.length > 1 && (args = Array.prototype.slice.call(arguments)), fn(args));
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args == null)
          return args;
        arguments.length > 1 && (args = Array.prototype.slice.call(arguments));
        var result = fn(args);
        if (typeof result == "object")
          for (var len = result.length, i = 0; i < len; i++)
            result[i] = Math.round(result[i]);
        return result;
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", {
        value: conversions[fromModel].channels
      }), Object.defineProperty(convert[fromModel], "labels", {
        value: conversions[fromModel].labels
      });
      var routes = route(fromModel), routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn), convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert2(), wrapAnsi162 = function(fn, offset) {
      return function() {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[".concat(code + offset, "m");
      };
    }, wrapAnsi2562 = function(fn, offset) {
      return function() {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
      };
    }, wrapAnsi16m2 = function(fn, offset) {
      return function() {
        var rgb = fn.apply(colorConvert, arguments);
        return "\x1B[".concat(38 + offset, ";2;").concat(rgb[0], ";").concat(rgb[1], ";").concat(rgb[2], "m");
      };
    };
    function assembleStyles2() {
      var codes2 = /* @__PURE__ */ new Map(), styles3 = {
        modifier: {
          reset: [
            0,
            0
          ],
          // 21 isn't widely supported and 22 does the same thing
          bold: [
            1,
            22
          ],
          dim: [
            2,
            22
          ],
          italic: [
            3,
            23
          ],
          underline: [
            4,
            24
          ],
          inverse: [
            7,
            27
          ],
          hidden: [
            8,
            28
          ],
          strikethrough: [
            9,
            29
          ]
        },
        color: {
          black: [
            30,
            39
          ],
          red: [
            31,
            39
          ],
          green: [
            32,
            39
          ],
          yellow: [
            33,
            39
          ],
          blue: [
            34,
            39
          ],
          magenta: [
            35,
            39
          ],
          cyan: [
            36,
            39
          ],
          white: [
            37,
            39
          ],
          gray: [
            90,
            39
          ],
          // Bright color
          redBright: [
            91,
            39
          ],
          greenBright: [
            92,
            39
          ],
          yellowBright: [
            93,
            39
          ],
          blueBright: [
            94,
            39
          ],
          magentaBright: [
            95,
            39
          ],
          cyanBright: [
            96,
            39
          ],
          whiteBright: [
            97,
            39
          ]
        },
        bgColor: {
          bgBlack: [
            40,
            49
          ],
          bgRed: [
            41,
            49
          ],
          bgGreen: [
            42,
            49
          ],
          bgYellow: [
            43,
            49
          ],
          bgBlue: [
            44,
            49
          ],
          bgMagenta: [
            45,
            49
          ],
          bgCyan: [
            46,
            49
          ],
          bgWhite: [
            47,
            49
          ],
          // Bright color
          bgBlackBright: [
            100,
            49
          ],
          bgRedBright: [
            101,
            49
          ],
          bgGreenBright: [
            102,
            49
          ],
          bgYellowBright: [
            103,
            49
          ],
          bgBlueBright: [
            104,
            49
          ],
          bgMagentaBright: [
            105,
            49
          ],
          bgCyanBright: [
            106,
            49
          ],
          bgWhiteBright: [
            107,
            49
          ]
        }
      };
      styles3.color.grey = styles3.color.gray;
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = Object.keys(styles3)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var groupName = _step.value, group = styles3[groupName], _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = Object.keys(group)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var styleName = _step1.value, style = group[styleName];
              styles3[styleName] = {
                open: "\x1B[".concat(style[0], "m"),
                close: "\x1B[".concat(style[1], "m")
              }, group[styleName] = styles3[styleName], codes2.set(style[0], style[1]);
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
          Object.defineProperty(styles3, groupName, {
            value: group,
            enumerable: !1
          }), Object.defineProperty(styles3, "codes", {
            value: codes2,
            enumerable: !1
          });
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      var ansi2ansi = function(n) {
        return n;
      }, rgb2rgb = function(r, g, b) {
        return [
          r,
          g,
          b
        ];
      };
      styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", styles3.color.ansi = {
        ansi: wrapAnsi162(ansi2ansi, 0)
      }, styles3.color.ansi256 = {
        ansi256: wrapAnsi2562(ansi2ansi, 0)
      }, styles3.color.ansi16m = {
        rgb: wrapAnsi16m2(rgb2rgb, 0)
      }, styles3.bgColor.ansi = {
        ansi: wrapAnsi162(ansi2ansi, 10)
      }, styles3.bgColor.ansi256 = {
        ansi256: wrapAnsi2562(ansi2ansi, 10)
      }, styles3.bgColor.ansi16m = {
        rgb: wrapAnsi16m2(rgb2rgb, 10)
      };
      var _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
      try {
        for (var _iterator2 = Object.keys(colorConvert)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
          var key = _step2.value;
          if (typeof colorConvert[key] == "object") {
            var suite = colorConvert[key];
            key === "ansi16" && (key = "ansi"), "ansi16" in suite && (styles3.color.ansi[key] = wrapAnsi162(suite.ansi16, 0), styles3.bgColor.ansi[key] = wrapAnsi162(suite.ansi16, 10)), "ansi256" in suite && (styles3.color.ansi256[key] = wrapAnsi2562(suite.ansi256, 0), styles3.bgColor.ansi256[key] = wrapAnsi2562(suite.ansi256, 10)), "rgb" in suite && (styles3.color.ansi16m[key] = wrapAnsi16m2(suite.rgb, 0), styles3.bgColor.ansi16m[key] = wrapAnsi16m2(suite.rgb, 10));
          }
        }
      } catch (err) {
        _didIteratorError22 = !0, _iteratorError22 = err;
      } finally {
        try {
          !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
        } finally {
          if (_didIteratorError22)
            throw _iteratorError22;
        }
      }
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: !0,
      get: assembleStyles2
    });
  }
});

// ../../node_modules/@babel/highlight/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv2) {
      argv2 = argv2 || process.argv;
      var prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", pos = argv2.indexOf(prefix + flag), terminatorPos = argv2.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? !0 : pos < terminatorPos);
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os"), hasFlag2 = require_has_flag2(), env2 = process.env, forceColor;
    hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") ? forceColor = !1 : (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) && (forceColor = !0);
    "FORCE_COLOR" in env2 && (forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0);
    function translateLevel2(level) {
      return level === 0 ? !1 : {
        level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor2(stream2) {
      if (forceColor === !1)
        return 0;
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor"))
        return 3;
      if (hasFlag2("color=256"))
        return 2;
      if (stream2 && !stream2.isTTY && forceColor !== !0)
        return 0;
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os2.release().split(".");
        return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in env2)
        return [
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI"
        ].some(function(sign) {
          return sign in env2;
        }) || env2.CI_NAME === "codeship" ? 1 : min;
      if ("TEAMCITY_VERSION" in env2)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      if (env2.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in env2) {
        var version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(env2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM) || "COLORTERM" in env2 ? 1 : (env2.TERM === "dumb", min);
    }
    function getSupportLevel(stream2) {
      var level = supportsColor2(stream2);
      return translateLevel2(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = /* @__PURE__ */ new Map([
      [
        "n",
        `
`
      ],
      [
        "r",
        "\r"
      ],
      [
        "t",
        "	"
      ],
      [
        "b",
        "\b"
      ],
      [
        "f",
        "\f"
      ],
      [
        "v",
        "\v"
      ],
      [
        "0",
        "\0"
      ],
      [
        "\\",
        "\\"
      ],
      [
        "e",
        "\x1B"
      ],
      [
        "a",
        "\x07"
      ]
    ]);
    function unescape2(c) {
      return c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3 ? String.fromCharCode(parseInt(c.slice(1), 16)) : ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      var results = [], chunks = args.trim().split(/\s*,\s*/g), matches, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var chunk = _step.value;
          if (!isNaN(chunk))
            results.push(Number(chunk));
          else if (matches = chunk.match(STRING_REGEX))
            results.push(matches[2].replace(ESCAPE_REGEX, function(m, escape2, chr) {
              return escape2 ? unescape2(escape2) : chr;
            }));
          else
            throw new Error("Invalid Chalk template style argument: ".concat(chunk, " (in style '").concat(name, "')"));
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      for (var results = [], matches; (matches = STYLE_REGEX.exec(style)) !== null; ) {
        var name = matches[1];
        if (matches[2]) {
          var args = parseArguments(name, matches[2]);
          results.push([
            name
          ].concat(args));
        } else
          results.push([
            name
          ]);
      }
      return results;
    }
    function buildStyle(chalk13, styles3) {
      var enabled = {}, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = styles3[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var layer = _step.value, _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator1 = layer.styles[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
              var style = _step1.value;
              enabled[style[0]] = layer.inverse ? null : style.slice(1);
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      var current = chalk13, _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
      try {
        for (var _iterator2 = Object.keys(enabled)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
          var styleName = _step2.value;
          if (Array.isArray(enabled[styleName])) {
            if (!(styleName in current))
              throw new Error("Unknown Chalk style: ".concat(styleName));
            enabled[styleName].length > 0 ? current = current[styleName].apply(current, enabled[styleName]) : current = current[styleName];
          }
        }
      } catch (err) {
        _didIteratorError22 = !0, _iteratorError22 = err;
      } finally {
        try {
          !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
        } finally {
          if (_didIteratorError22)
            throw _iteratorError22;
        }
      }
      return current;
    }
    module2.exports = function(chalk13, tmp) {
      var styles3 = [], chunks = [], chunk = [];
      if (tmp.replace(TEMPLATE_REGEX, function(m, escapeChar, inverse, style, close, chr) {
        if (escapeChar)
          chunk.push(unescape2(escapeChar));
        else if (style) {
          var str = chunk.join("");
          chunk = [], chunks.push(styles3.length === 0 ? str : buildStyle(chalk13, styles3)(str)), styles3.push({
            inverse,
            styles: parseStyle(style)
          });
        } else if (close) {
          if (styles3.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          chunks.push(buildStyle(chalk13, styles3)(chunk.join(""))), chunk = [], styles3.pop();
        } else
          chunk.push(chr);
      }), chunks.push(chunk.join("")), styles3.length > 0) {
        var errMsg = "Chalk template literal is missing ".concat(styles3.length, " closing bracket").concat(styles3.length === 1 ? "" : "s", " (`}`)");
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var escapeStringRegexp = require_escape_string_regexp(), ansiStyles2 = require_ansi_styles2(), stdoutColor2 = require_supports_color2().stdout, template = require_templates2(), isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), levelMapping2 = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ], skipModels = /* @__PURE__ */ new Set([
      "gray"
    ]), styles3 = /* @__PURE__ */ Object.create(null);
    function applyOptions2(obj, options) {
      options = options || {};
      var scLevel = stdoutColor2 ? stdoutColor2.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level, obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !_instanceof13(this, Chalk) || this.template) {
        var chalk13 = {};
        return applyOptions2(chalk13, options), chalk13.template = function() {
          var args = [].slice.call(arguments);
          return chalkTag.apply(null, [
            chalk13.template
          ].concat(args));
        }, Object.setPrototypeOf(chalk13, Chalk.prototype), Object.setPrototypeOf(chalk13.template, chalk13), chalk13.template.constructor = Chalk, chalk13.template;
      }
      applyOptions2(this, options);
    }
    isSimpleWindowsTerm && (ansiStyles2.blue.open = "\x1B[94m");
    var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
    try {
      for (_loop = function() {
        var key = _step.value;
        ansiStyles2[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles2[key].close), "g"), styles3[key] = {
          get: function() {
            var codes2 = ansiStyles2[key];
            return build.call(this, this._styles ? this._styles.concat(codes2) : [
              codes2
            ], this._empty, key);
          }
        };
      }, _iterator = Object.keys(ansiStyles2)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0)
        _loop();
    } catch (err) {
      _didIteratorError2 = !0, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError2)
          throw _iteratorError2;
      }
    }
    var _loop, _iterator, _step;
    styles3.visible = {
      get: function() {
        return build.call(this, this._styles || [], !0, "visible");
      }
    };
    ansiStyles2.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles2.color.close), "g");
    var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
    try {
      for (_loop1 = function() {
        var model = _step1.value;
        if (skipModels.has(model))
          return "continue";
        styles3[model] = {
          get: function() {
            var level = this.level;
            return function() {
              var open3 = ansiStyles2.color[levelMapping2[level]][model].apply(null, arguments), codes2 = {
                open: open3,
                close: ansiStyles2.color.close,
                closeRe: ansiStyles2.color.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes2) : [
                codes2
              ], this._empty, model);
            };
          }
        };
      }, _iterator1 = Object.keys(ansiStyles2.color.ansi)[Symbol.iterator](); !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0)
        _loop1();
    } catch (err) {
      _didIteratorError12 = !0, _iteratorError12 = err;
    } finally {
      try {
        !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
      } finally {
        if (_didIteratorError12)
          throw _iteratorError12;
      }
    }
    var _loop1, _iterator1, _step1;
    ansiStyles2.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles2.bgColor.close), "g");
    var _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
    try {
      for (_loop2 = function() {
        var model = _step2.value;
        if (skipModels.has(model))
          return "continue";
        var bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles3[bgModel] = {
          get: function() {
            var level = this.level;
            return function() {
              var open3 = ansiStyles2.bgColor[levelMapping2[level]][model].apply(null, arguments), codes2 = {
                open: open3,
                close: ansiStyles2.bgColor.close,
                closeRe: ansiStyles2.bgColor.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes2) : [
                codes2
              ], this._empty, model);
            };
          }
        };
      }, _iterator2 = Object.keys(ansiStyles2.bgColor.ansi)[Symbol.iterator](); !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0)
        _loop2();
    } catch (err) {
      _didIteratorError22 = !0, _iteratorError22 = err;
    } finally {
      try {
        !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
      } finally {
        if (_didIteratorError22)
          throw _iteratorError22;
      }
    }
    var _loop2, _iterator2, _step2, proto2 = Object.defineProperties(function() {
    }, styles3);
    function build(_styles, _empty, key) {
      var builder = function() {
        return applyStyle2.apply(builder, arguments);
      };
      builder._styles = _styles, builder._empty = _empty;
      var self = this;
      return Object.defineProperty(builder, "level", {
        enumerable: !0,
        get: function() {
          return self.level;
        },
        set: function(level) {
          self.level = level;
        }
      }), Object.defineProperty(builder, "enabled", {
        enumerable: !0,
        get: function() {
          return self.enabled;
        },
        set: function(enabled) {
          self.enabled = enabled;
        }
      }), builder.hasGrey = this.hasGrey || key === "gray" || key === "grey", builder.__proto__ = proto2, builder;
    }
    function applyStyle2() {
      var args = arguments, argsLen = args.length, str = String(arguments[0]);
      if (argsLen === 0)
        return "";
      if (argsLen > 1)
        for (var a = 1; a < argsLen; a++)
          str += " " + args[a];
      if (!this.enabled || this.level <= 0 || !str)
        return this._empty ? "" : str;
      var originalDim = ansiStyles2.dim.open;
      isSimpleWindowsTerm && this.hasGrey && (ansiStyles2.dim.open = "");
      var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
      try {
        for (var _iterator3 = this._styles.slice().reverse()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
          var code = _step3.value;
          str = code.open + str.replace(code.closeRe, code.open) + code.close, str = str.replace(/\r?\n/g, "".concat(code.close, "$&").concat(code.open));
        }
      } catch (err) {
        _didIteratorError3 = !0, _iteratorError3 = err;
      } finally {
        try {
          !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
        } finally {
          if (_didIteratorError3)
            throw _iteratorError3;
        }
      }
      return ansiStyles2.dim.open = originalDim, str;
    }
    function chalkTag(chalk13, strings) {
      if (!Array.isArray(strings))
        return [].slice.call(arguments, 1).join(" ");
      for (var args = [].slice.call(arguments, 2), parts = [
        strings.raw[0]
      ], i = 1; i < strings.length; i++)
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&")), parts.push(String(strings.raw[i]));
      return template(chalk13, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles3);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor2;
    module2.exports.default = module2.exports;
  }
});

// ../../node_modules/@babel/highlight/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/@babel/highlight/lib/index.js"(exports2) {
    "use strict";
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.default = highlight;
    exports2.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens(), _helperValidatorIdentifier = require_lib4(), _chalk = _interopRequireWildcard(require_chalk(), !0);
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap != "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap(), cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule)
        return obj;
      if (obj === null || typeof obj != "object" && typeof obj != "function")
        return {
          default: obj
        };
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj))
        return cache2.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache2 && cache2.set(obj, newObj), newObj;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set([
      "as",
      "async",
      "from",
      "get",
      "of",
      "set"
    ]);
    function getDefs(chalk13) {
      return {
        keyword: chalk13.cyan,
        capitalized: chalk13.yellow,
        jsxIdentifier: chalk13.yellow,
        punctuator: chalk13.yellow,
        number: chalk13.magenta,
        string: chalk13.green,
        regex: chalk13.magenta,
        comment: chalk13.grey,
        invalid: chalk13.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/, BRACKET = /^[()[\]{}]$/, tokenize;
    JSX_TAG = /^[a-z][\w-]*$/i, getTokenType = function(token, offset, text) {
      if (token.type === "name") {
        if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, !0) || sometimesKeywords.has(token.value))
          return "keyword";
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</"))
          return "jsxIdentifier";
        if (token.value[0] !== token.value[0].toLowerCase())
          return "capitalized";
      }
      return token.type === "punctuator" && BRACKET.test(token.value) ? "bracket" : token.type === "invalid" && (token.value === "@" || token.value === "#") ? "punctuator" : token.type;
    }, tokenize = function(text) {
      var match2, token;
      return _ts_generator31(this, function(_state) {
        switch (_state.label) {
          case 0:
            return (match2 = _jsTokens.default.exec(text)) ? (token = _jsTokens.matchToToken(match2), [
              4,
              {
                type: getTokenType(token, match2.index, text),
                value: token.value
              }
            ]) : [
              3,
              2
            ];
          case 1:
            return _state.sent(), [
              3,
              0
            ];
          case 2:
            return [
              2
            ];
        }
      });
    };
    var JSX_TAG, getTokenType;
    function highlightTokens(defs, text) {
      var highlighted = "", _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _loop = function() {
          var _step_value = _step.value, type = _step_value.type, value = _step_value.value, colorize = defs[type];
          colorize ? highlighted += value.split(NEWLINE).map(function(str) {
            return colorize(str);
          }).join(`
`) : highlighted += value;
        }, _iterator = tokenize(text)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0)
          _loop();
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return _chalk.default.level > 0 || options.forceColor;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        return (_chalkWithForcedColor = chalkWithForcedColor) != null || (chalkWithForcedColor = new _chalk.default.constructor({
          enabled: !0,
          level: 1
        })), chalkWithForcedColor;
      }
      return _chalk.default;
    }
    exports2.getChalk = function(options) {
      return getChalk(options.forceColor);
    };
    function highlight(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (code !== "" && shouldHighlight(options)) {
        var defs = getDefs(getChalk(options.forceColor));
        return highlightTokens(defs, code);
      } else
        return code;
    }
  }
});

// ../../node_modules/@expo/json-file/node_modules/@babel/code-frame/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/@expo/json-file/node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = _default;
    var _highlight = _interopRequireWildcard(require_lib5());
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache2;
      }, cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || typeof obj != "object" && typeof obj != "function")
        return {
          default: obj
        };
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj))
        return cache2.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache2 && cache2.set(obj, newObj), newObj;
    }
    var deprecationWarningShown = !1;
    function getDefs(chalk13) {
      return {
        gutter: chalk13.grey,
        marker: chalk13.red.bold,
        message: chalk13.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      var startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start), endLoc = Object.assign({}, startLoc, loc.end), _ref = opts || {}, _ref_linesAbove = _ref.linesAbove, linesAbove = _ref_linesAbove === void 0 ? 2 : _ref_linesAbove, _ref_linesBelow = _ref.linesBelow, linesBelow = _ref_linesBelow === void 0 ? 3 : _ref_linesBelow, startLine = startLoc.line, startColumn = startLoc.column, endLine = endLoc.line, endColumn = endLoc.column, start = Math.max(startLine - (linesAbove + 1), 0), end = Math.min(source.length, endLine + linesBelow);
      startLine === -1 && (start = 0), endLine === -1 && (end = source.length);
      var lineDiff = endLine - startLine, markerLines = {};
      if (lineDiff)
        for (var i = 0; i <= lineDiff; i++) {
          var lineNumber = i + startLine;
          if (!startColumn)
            markerLines[lineNumber] = !0;
          else if (i === 0) {
            var sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [
              startColumn,
              sourceLength - startColumn + 1
            ];
          } else if (i === lineDiff)
            markerLines[lineNumber] = [
              0,
              endColumn
            ];
          else {
            var sourceLength1 = source[lineNumber - i].length;
            markerLines[lineNumber] = [
              0,
              sourceLength1
            ];
          }
        }
      else
        startColumn === endColumn ? startColumn ? markerLines[startLine] = [
          startColumn,
          0
        ] : markerLines[startLine] = !0 : markerLines[startLine] = [
          startColumn,
          endColumn - startColumn
        ];
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts), chalk13 = (0, _highlight.getChalk)(opts), defs = getDefs(chalk13), maybeHighlight = function(chalkFn, string) {
        return highlighted ? chalkFn(string) : string;
      }, lines = rawLines.split(NEWLINE), _getMarkerLines = getMarkerLines(loc, lines, opts), start = _getMarkerLines.start, end = _getMarkerLines.end, markerLines = _getMarkerLines.markerLines, hasColumns = loc.start && typeof loc.start.column == "number", numberMaxWidth = String(end).length, highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines, frame = highlightedLines.split(NEWLINE).slice(start, end).map(function(line, index) {
        var number = start + 1 + index, paddedNumber = " ".concat(number).slice(-numberMaxWidth), gutter = " ".concat(paddedNumber, " | "), hasMarker = markerLines[number], lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          var markerLine = "";
          if (Array.isArray(hasMarker)) {
            var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " "), numberOfMarkers = hasMarker[1] || 1;
            markerLine = [
              `
 `,
              maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")),
              markerSpacing,
              maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)
            ].join(""), lastMarkerLine && opts.message && (markerLine += " " + maybeHighlight(defs.message, opts.message));
          }
          return [
            maybeHighlight(defs.marker, ">"),
            maybeHighlight(defs.gutter, gutter),
            line,
            markerLine
          ].join("");
        } else
          return " ".concat(maybeHighlight(defs.gutter, gutter)).concat(line);
      }).join(`
`);
      return opts.message && !hasColumns && (frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, `
`).concat(frame)), highlighted ? chalk13.reset(frame) : frame;
    }
    function _default(rawLines, lineNumber, colNumber) {
      var opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (!deprecationWarningShown) {
        deprecationWarningShown = !0;
        var message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning)
          process.emitWarning(message, "DeprecationWarning");
        else {
          var deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning", console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      var location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// ../../node_modules/json5/lib/unicode.js
var require_unicode = __commonJS({
  "../../node_modules/json5/lib/unicode.js"(exports2, module2) {
    module2.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    module2.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    module2.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  }
});

// ../../node_modules/json5/lib/util.js
var require_util4 = __commonJS({
  "../../node_modules/json5/lib/util.js"(exports2, module2) {
    var unicode = require_unicode();
    module2.exports = {
      isSpaceSeparator: function(c) {
        return typeof c == "string" && unicode.Space_Separator.test(c);
      },
      isIdStartChar: function(c) {
        return typeof c == "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
      },
      isIdContinueChar: function(c) {
        return typeof c == "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
      },
      isDigit: function(c) {
        return typeof c == "string" && /[0-9]/.test(c);
      },
      isHexDigit: function(c) {
        return typeof c == "string" && /[0-9A-Fa-f]/.test(c);
      }
    };
  }
});

// ../../node_modules/json5/lib/parse.js
var require_parse5 = __commonJS({
  "../../node_modules/json5/lib/parse.js"(exports2, module2) {
    var util = require_util4(), source, parseState, stack, pos, line, column, token, key, root;
    module2.exports = function(text, reviver) {
      source = String(text), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key = void 0, root = void 0;
      do
        token = lex(), parseStates[parseState]();
      while (token.type !== "eof");
      return typeof reviver == "function" ? internalize({
        "": root
      }, "", reviver) : root;
    };
    function internalize(holder, name, reviver) {
      var value = holder[name];
      if (value != null && typeof value == "object")
        if (Array.isArray(value))
          for (var i = 0; i < value.length; i++) {
            var key2 = String(i), replacement = internalize(value, key2, reviver);
            replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
              value: replacement,
              writable: !0,
              enumerable: !0,
              configurable: !0
            });
          }
        else
          for (var key1 in value) {
            var replacement1 = internalize(value, key1, reviver);
            replacement1 === void 0 ? delete value[key1] : Object.defineProperty(value, key1, {
              value: replacement1,
              writable: !0,
              enumerable: !0,
              configurable: !0
            });
          }
      return reviver.call(holder, name, value);
    }
    var lexState, buffer, doubleQuote, sign, c;
    function lex() {
      for (lexState = "default", buffer = "", doubleQuote = !1, sign = 1; ; ) {
        c = peek();
        var token2 = lexStates[lexState]();
        if (token2)
          return token2;
      }
    }
    function peek() {
      if (source[pos])
        return String.fromCodePoint(source.codePointAt(pos));
    }
    function read() {
      var c2 = peek();
      return c2 === `
` ? (line++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
    }
    var lexStates = {
      default: function() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case `
`:
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read(), lexState = "comment";
            return;
          case void 0:
            return read(), newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment: function() {
        switch (c) {
          case "*":
            read(), lexState = "multiLineComment";
            return;
          case "/":
            read(), lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment: function() {
        switch (c) {
          case "*":
            read(), lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk: function() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read(), lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read(), lexState = "multiLineComment";
      },
      singleLineComment: function() {
        switch (c) {
          case `
`:
          case "\r":
          case "\u2028":
          case "\u2029":
            read(), lexState = "default";
            return;
          case void 0:
            return read(), newToken("eof");
        }
        read();
      },
      value: function() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            return read(), literal("ull"), newToken("null", null);
          case "t":
            return read(), literal("rue"), newToken("boolean", !0);
          case "f":
            return read(), literal("alse"), newToken("boolean", !1);
          case "-":
          case "+":
            read() === "-" && (sign = -1), lexState = "sign";
            return;
          case ".":
            buffer = read(), lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read(), lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read(), lexState = "decimalInteger";
            return;
          case "I":
            return read(), literal("nfinity"), newToken("numeric", 1 / 0);
          case "N":
            return read(), literal("aN"), newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"', buffer = "", lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape: function() {
        if (c !== "u")
          throw invalidChar(read());
        read();
        var u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u))
              throw invalidIdentifier();
            break;
        }
        buffer += u, lexState = "identifierName";
      },
      identifierName: function() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read(), lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape: function() {
        if (c !== "u")
          throw invalidChar(read());
        read();
        var u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u))
              throw invalidIdentifier();
            break;
        }
        buffer += u, lexState = "identifierName";
      },
      sign: function() {
        switch (c) {
          case ".":
            buffer = read(), lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read(), lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read(), lexState = "decimalInteger";
            return;
          case "I":
            return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
          case "N":
            return read(), literal("aN"), newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero: function() {
        switch (c) {
          case ".":
            buffer += read(), lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read(), lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger: function() {
        switch (c) {
          case ".":
            buffer += read(), lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading: function() {
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint: function() {
        switch (c) {
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction: function() {
        switch (c) {
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent: function() {
        switch (c) {
          case "+":
          case "-":
            buffer += read(), lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign: function() {
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger: function() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal: function() {
        if (util.isHexDigit(c)) {
          buffer += read(), lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger: function() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string: function() {
        switch (c) {
          case "\\":
            read(), buffer += escape2();
            return;
          case '"':
            if (doubleQuote)
              return read(), newToken("string", buffer);
            buffer += read();
            return;
          case "'":
            if (!doubleQuote)
              return read(), newToken("string", buffer);
            buffer += read();
            return;
          case `
`:
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start: function() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName: function() {
        switch (c) {
          case "$":
          case "_":
            buffer = read(), lexState = "identifierName";
            return;
          case "\\":
            read(), lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"', lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read(), lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName: function() {
        if (c === ":")
          return newToken("punctuator", read());
        throw invalidChar(read());
      },
      beforePropertyValue: function() {
        lexState = "value";
      },
      afterPropertyValue: function() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue: function() {
        if (c === "]")
          return newToken("punctuator", read());
        lexState = "value";
      },
      afterArrayValue: function() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end: function() {
        throw invalidChar(read());
      }
    };
    function newToken(type, value) {
      return {
        type,
        value,
        line,
        column
      };
    }
    function literal(s) {
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = s[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var c2 = _step.value, p = peek();
          if (p !== c2)
            throw invalidChar(read());
          read();
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
    }
    function escape2() {
      var c2 = peek();
      switch (c2) {
        case "b":
          return read(), "\b";
        case "f":
          return read(), "\f";
        case "n":
          return read(), `
`;
        case "r":
          return read(), "\r";
        case "t":
          return read(), "	";
        case "v":
          return read(), "\v";
        case "0":
          if (read(), util.isDigit(peek()))
            throw invalidChar(read());
          return "\0";
        case "x":
          return read(), hexEscape();
        case "u":
          return read(), unicodeEscape();
        case `
`:
        case "\u2028":
        case "\u2029":
          return read(), "";
        case "\r":
          return read(), peek() === `
` && read(), "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      var buffer2 = "", c2 = peek();
      if (!util.isHexDigit(c2) || (buffer2 += read(), c2 = peek(), !util.isHexDigit(c2)))
        throw invalidChar(read());
      return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      for (var buffer2 = "", count = 4; count-- > 0; ) {
        var c2 = peek();
        if (!util.isHexDigit(c2))
          throw invalidChar(read());
        buffer2 += read();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start: function() {
        if (token.type === "eof")
          throw invalidEOF();
        push();
      },
      beforePropertyName: function() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value, parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()
      afterPropertyName: function() {
        if (token.type === "eof")
          throw invalidEOF();
        parseState = "beforePropertyValue";
      },
      beforePropertyValue: function() {
        if (token.type === "eof")
          throw invalidEOF();
        push();
      },
      beforeArrayValue: function() {
        if (token.type === "eof")
          throw invalidEOF();
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue: function() {
        if (token.type === "eof")
          throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()
      afterArrayValue: function() {
        if (token.type === "eof")
          throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()
      end: function() {
      }
    };
    function push() {
      var value;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;
      }
      if (root === void 0)
        root = value;
      else {
        var parent = stack[stack.length - 1];
        Array.isArray(parent) ? parent.push(value) : Object.defineProperty(parent, key, {
          value,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
      if (value !== null && typeof value == "object")
        stack.push(value), Array.isArray(value) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
      else {
        var current = stack[stack.length - 1];
        current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
      }
    }
    function pop() {
      stack.pop();
      var current = stack[stack.length - 1];
      current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
    }
    function invalidChar(c2) {
      return syntaxError(c2 === void 0 ? "JSON5: invalid end of input at ".concat(line, ":").concat(column) : "JSON5: invalid character '".concat(formatChar(c2), "' at ").concat(line, ":").concat(column));
    }
    function invalidEOF() {
      return syntaxError("JSON5: invalid end of input at ".concat(line, ":").concat(column));
    }
    function invalidIdentifier() {
      return column -= 5, syntaxError("JSON5: invalid identifier character at ".concat(line, ":").concat(column));
    }
    function separatorChar(c2) {
      console.warn("JSON5: '".concat(formatChar(c2), "' in strings is not valid ECMAScript; consider escaping"));
    }
    function formatChar(c2) {
      var replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c2])
        return replacements[c2];
      if (c2 < " ") {
        var hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError(message) {
      var err = new SyntaxError(message);
      return err.lineNumber = line, err.columnNumber = column, err;
    }
  }
});

// ../../node_modules/json5/lib/stringify.js
var require_stringify3 = __commonJS({
  "../../node_modules/json5/lib/stringify.js"(exports2, module2) {
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var util = require_util4();
    module2.exports = function(value, replacer, space) {
      var stack = [], indent = "", propertyList, replacerFunc, gap = "", quote2;
      if (replacer != null && typeof replacer == "object" && !Array.isArray(replacer) && (space = replacer.space, quote2 = replacer.quote, replacer = replacer.replacer), typeof replacer == "function")
        replacerFunc = replacer;
      else if (Array.isArray(replacer)) {
        propertyList = [];
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = replacer[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var v = _step.value, item = void 0;
            typeof v == "string" ? item = v : (typeof v == "number" || _instanceof13(v, String) || _instanceof13(v, Number)) && (item = String(v)), item !== void 0 && propertyList.indexOf(item) < 0 && propertyList.push(item);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
      return _instanceof13(space, Number) ? space = Number(space) : _instanceof13(space, String) && (space = String(space)), typeof space == "number" ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : typeof space == "string" && (gap = space.substr(0, 10)), serializeProperty("", {
        "": value
      });
      function serializeProperty(key, holder) {
        var _$value = holder[key];
        switch (_$value != null && (typeof _$value.toJSON5 == "function" ? _$value = _$value.toJSON5(key) : typeof _$value.toJSON == "function" && (_$value = _$value.toJSON(key))), replacerFunc && (_$value = replacerFunc.call(holder, key, _$value)), _instanceof13(_$value, Number) ? _$value = Number(_$value) : _instanceof13(_$value, String) ? _$value = String(_$value) : _instanceof13(_$value, Boolean) && (_$value = _$value.valueOf()), _$value) {
          case null:
            return "null";
          case !0:
            return "true";
          case !1:
            return "false";
        }
        if (typeof _$value == "string")
          return quoteString(_$value, !1);
        if (typeof _$value == "number")
          return String(_$value);
        if (typeof _$value == "object")
          return Array.isArray(_$value) ? serializeArray(_$value) : serializeObject(_$value);
      }
      function quoteString(value2) {
        for (var quotes = {
          "'": 0.1,
          '"': 0.2
        }, replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        }, product = "", i = 0; i < value2.length; i++) {
          var c = value2[i];
          switch (c) {
            case "'":
            case '"':
              quotes[c]++, product += c;
              continue;
            case "\0":
              if (util.isDigit(value2[i + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c]) {
            product += replacements[c];
            continue;
          }
          if (c < " ") {
            var hexString = c.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c;
        }
        var quoteChar = quote2 || Object.keys(quotes).reduce(function(a, b) {
          return quotes[a] < quotes[b] ? a : b;
        });
        return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack.indexOf(value2) >= 0)
          throw TypeError("Converting circular structure to JSON5");
        stack.push(value2);
        var stepback = indent;
        indent = indent + gap;
        var keys = propertyList || Object.keys(value2), partial = [], _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
        try {
          for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion3 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion3 = !0) {
            var key = _step2.value, propertyString = serializeProperty(key, value2);
            if (propertyString !== void 0) {
              var member = serializeKey(key) + ":";
              gap !== "" && (member += " "), member += propertyString, partial.push(member);
            }
          }
        } catch (err) {
          _didIteratorError3 = !0, _iteratorError3 = err;
        } finally {
          try {
            !_iteratorNormalCompletion3 && _iterator2.return != null && _iterator2.return();
          } finally {
            if (_didIteratorError3)
              throw _iteratorError3;
          }
        }
        var final;
        if (partial.length === 0)
          final = "{}";
        else {
          var properties;
          if (gap === "")
            properties = partial.join(","), final = "{" + properties + "}";
          else {
            var separator = `,
` + indent;
            properties = partial.join(separator), final = `{
` + indent + properties + `,
` + stepback + "}";
          }
        }
        return stack.pop(), indent = stepback, final;
      }
      function serializeKey(key) {
        if (key.length === 0)
          return quoteString(key, !0);
        var firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar))
          return quoteString(key, !0);
        for (var i = firstChar.length; i < key.length; i++)
          if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i))))
            return quoteString(key, !0);
        return key;
      }
      function serializeArray(value2) {
        if (stack.indexOf(value2) >= 0)
          throw TypeError("Converting circular structure to JSON5");
        stack.push(value2);
        var stepback = indent;
        indent = indent + gap;
        for (var partial = [], i = 0; i < value2.length; i++) {
          var propertyString = serializeProperty(String(i), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        var final;
        if (partial.length === 0)
          final = "[]";
        else if (gap === "") {
          var properties = partial.join(",");
          final = "[" + properties + "]";
        } else {
          var separator = `,
` + indent, properties1 = partial.join(separator);
          final = `[
` + indent + properties1 + `,
` + stepback + "]";
        }
        return stack.pop(), indent = stepback, final;
      }
    };
  }
});

// ../../node_modules/json5/lib/index.js
var require_lib7 = __commonJS({
  "../../node_modules/json5/lib/index.js"(exports2, module2) {
    var parse6 = require_parse5(), stringify = require_stringify3(), JSON5 = {
      parse: parse6,
      stringify
    };
    module2.exports = JSON5;
  }
});

// ../../node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "../../node_modules/imurmurhash/imurmurhash.js"(exports2, module2) {
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    (function() {
      var cache2;
      function MurmurHash3(key, seed) {
        var m = _instanceof13(this, MurmurHash3) ? this : cache2;
        if (m.reset(seed), typeof key == "string" && key.length > 0 && m.hash(key), m !== this)
          return m;
      }
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        switch (len = key.length, this.len += len, k1 = this.k1, i = 0, this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0, k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        if (this.rem = len + this.rem & 3, len -= this.rem, len > 0) {
          for (h1 = this.h1; k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1, h1 = h1 << 13 | h1 >>> 19, h1 = h1 * 5 + 3864292196 & 4294967295, !(i >= len); )
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16, top = key.charCodeAt(i++), k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          switch (k1 = 0, this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        return this.k1 = k1, this;
      }, MurmurHash3.prototype.result = function() {
        var k1, h1;
        return k1 = this.k1, h1 = this.h1, k1 > 0 && (k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1), h1 ^= this.len, h1 ^= h1 >>> 16, h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295, h1 ^= h1 >>> 13, h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295, h1 ^= h1 >>> 16, h1 >>> 0;
      }, MurmurHash3.prototype.reset = function(seed) {
        return this.h1 = typeof seed == "number" ? seed : 0, this.rem = this.k1 = this.len = 0, this;
      }, cache2 = new MurmurHash3(), typeof module2 < "u" ? module2.exports = MurmurHash3 : this.MurmurHash3 = MurmurHash3;
    })();
  }
});

// ../../node_modules/write-file-atomic/index.js
var require_write_file_atomic = __commonJS({
  "../../node_modules/write-file-atomic/index.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    module2.exports = writeFile;
    module2.exports.sync = writeFileSync2;
    module2.exports._getTmpname = getTmpname;
    module2.exports._cleanupOnExit = cleanupOnExit;
    var fs7 = require_graceful_fs(), MurmurHash3 = require_imurmurhash(), onExit = require_signal_exit(), path6 = require("path"), activeFiles = {}, threadId = function() {
      try {
        var workerThreads = require("worker_threads");
        return workerThreads.threadId;
      } catch {
        return 0;
      }
    }(), invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return function() {
        try {
          fs7.unlinkSync(typeof tmpfile == "function" ? tmpfile() : tmpfile);
        } catch {
        }
      };
    }
    function writeFile(filename, data, options, callback) {
      options ? _instanceof13(options, Function) ? (callback = options, options = {}) : typeof options == "string" && (options = {
        encoding: options
      }) : options = {};
      var Promise2 = options.Promise || global.Promise, truename, fd, tmpfile, removeOnExitHandler = onExit(cleanupOnExit(function() {
        return tmpfile;
      })), absoluteName = path6.resolve(filename);
      new Promise2(function(resolve7) {
        activeFiles[absoluteName] || (activeFiles[absoluteName] = []), activeFiles[absoluteName].push(resolve7), activeFiles[absoluteName].length === 1 && resolve7();
      }).then(function() {
        return new Promise2(function(resolve7) {
          fs7.realpath(filename, function(_, realname) {
            truename = realname || filename, tmpfile = getTmpname(truename), resolve7();
          });
        });
      }).then(function() {
        return new Promise2(function(resolve7) {
          options.mode && options.chown ? resolve7() : fs7.stat(truename, function(err, stats) {
            err || !stats || (options = Object.assign({}, options), options.mode == null && (options.mode = stats.mode), options.chown == null && process.getuid && (options.chown = {
              uid: stats.uid,
              gid: stats.gid
            })), resolve7();
          });
        });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          fs7.open(tmpfile, "w", options.mode, function(err, _fd) {
            fd = _fd, err ? reject(err) : resolve7();
          });
        });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          Buffer.isBuffer(data) ? fs7.write(fd, data, 0, data.length, 0, function(err) {
            err ? reject(err) : resolve7();
          }) : data != null ? fs7.write(fd, String(data), 0, String(options.encoding || "utf8"), function(err) {
            err ? reject(err) : resolve7();
          }) : resolve7();
        });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          options.fsync !== !1 ? fs7.fsync(fd, function(err) {
            err ? fs7.close(fd, function() {
              return reject(err);
            }) : fs7.close(fd, resolve7);
          }) : fs7.close(fd, resolve7);
        });
      }).then(function() {
        if (fd = null, options.chown)
          return new Promise2(function(resolve7, reject) {
            fs7.chown(tmpfile, options.chown.uid, options.chown.gid, function(err) {
              err ? reject(err) : resolve7();
            });
          });
      }).then(function() {
        if (options.mode)
          return new Promise2(function(resolve7, reject) {
            fs7.chmod(tmpfile, options.mode, function(err) {
              err ? reject(err) : resolve7();
            });
          });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          fs7.rename(tmpfile, truename, function(err) {
            err ? reject(err) : resolve7();
          });
        });
      }).then(function() {
        removeOnExitHandler(), callback();
      }, function(err) {
        return new Promise2(function(resolve7) {
          return fd ? fs7.close(fd, resolve7) : resolve7();
        }).then(function() {
          removeOnExitHandler(), fs7.unlink(tmpfile, function() {
            callback(err);
          });
        });
      }).then(function() {
        activeFiles[absoluteName].shift(), activeFiles[absoluteName].length > 0 ? activeFiles[absoluteName][0]() : delete activeFiles[absoluteName];
      });
    }
    function writeFileSync2(filename, data, options) {
      typeof options == "string" ? options = {
        encoding: options
      } : options || (options = {});
      try {
        filename = fs7.realpathSync(filename);
      } catch {
      }
      var tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown)
        try {
          var stats = fs7.statSync(filename);
          options = Object.assign({}, options), options.mode || (options.mode = stats.mode), !options.chown && process.getuid && (options.chown = {
            uid: stats.uid,
            gid: stats.gid
          });
        } catch {
        }
      var fd, cleanup = cleanupOnExit(tmpfile), removeOnExitHandler = onExit(cleanup);
      try {
        fd = fs7.openSync(tmpfile, "w", options.mode), Buffer.isBuffer(data) ? fs7.writeSync(fd, data, 0, data.length, 0) : data != null && fs7.writeSync(fd, String(data), 0, String(options.encoding || "utf8")), options.fsync !== !1 && fs7.fsyncSync(fd), fs7.closeSync(fd), options.chown && fs7.chownSync(tmpfile, options.chown.uid, options.chown.gid), options.mode && fs7.chmodSync(tmpfile, options.mode), fs7.renameSync(tmpfile, filename), removeOnExitHandler();
      } catch (err) {
        if (fd)
          try {
            fs7.closeSync(fd);
          } catch {
          }
        throw removeOnExitHandler(), cleanup(), err;
      }
    }
  }
});

// ../../node_modules/@expo/json-file/build/JsonFileError.js
var require_JsonFileError = __commonJS({
  "../../node_modules/@expo/json-file/build/JsonFileError.js"(exports2) {
    "use strict";
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _construct4(Parent, args, Class) {
      return _is_native_reflect_construct10() ? _construct4 = Reflect.construct : _construct4 = function(Parent2, args2, Class2) {
        var a = [
          null
        ];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
        return Class2 && _set_prototype_of10(instance, Class2.prototype), instance;
      }, _construct4.apply(null, arguments);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _is_native_function4(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _wrap_native_super4(Class) {
      var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return _wrap_native_super4 = function(Class2) {
        if (Class2 === null || !_is_native_function4(Class2))
          return Class2;
        if (typeof Class2 != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache < "u") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct4(Class2, arguments, _get_prototype_of10(this).constructor);
        }
        return Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), _set_prototype_of10(Wrapper, Class2);
      }, _wrap_native_super4(Class);
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.EmptyJsonFileError = void 0;
    var JsonFileError = /* @__PURE__ */ function(Error1) {
      _inherits10(JsonFileError2, Error1);
      var _super = _create_super10(JsonFileError2);
      function JsonFileError2(message, cause, code, fileName) {
        _class_call_check15(this, JsonFileError2);
        var _this, fullMessage = message;
        return fileName && (fullMessage += `
`.concat(cause ? "\u251C" : "\u2514", "\u2500 File: ").concat(fileName)), cause && (fullMessage += `
\u2514\u2500 Cause: `.concat(cause.name, ": ").concat(cause.message)), _this = _super.call(this, fullMessage), _define_property21(_assert_this_initialized10(_this), "cause", void 0), _define_property21(_assert_this_initialized10(_this), "code", void 0), _define_property21(_assert_this_initialized10(_this), "fileName", void 0), _define_property21(_assert_this_initialized10(_this), "isJsonFileError", void 0), _this.name = _this.constructor.name, _this.cause = cause, _this.code = code, _this.fileName = fileName, _this.isJsonFileError = !0, _this;
      }
      return JsonFileError2;
    }(_wrap_native_super4(Error));
    exports2.default = JsonFileError;
    var EmptyJsonFileError = /* @__PURE__ */ function(JsonFileError2) {
      _inherits10(EmptyJsonFileError2, JsonFileError2);
      var _super = _create_super10(EmptyJsonFileError2);
      function EmptyJsonFileError2(fileName) {
        return _class_call_check15(this, EmptyJsonFileError2), _super.call(this, "Cannot parse an empty JSON string", void 0, "EJSONEMPTY", fileName);
      }
      return EmptyJsonFileError2;
    }(JsonFileError);
    exports2.EmptyJsonFileError = EmptyJsonFileError;
  }
});

// ../../node_modules/@expo/json-file/build/JsonFile.js
var require_JsonFile = __commonJS({
  "../../node_modules/@expo/json-file/build/JsonFile.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
        enumerable: !0,
        get: function() {
          return m[k];
        }
      }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
      });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null)
        for (var k in mod)
          k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var code_frame_1 = require_lib6(), fs_1 = __importDefault(require("fs")), json5_1 = __importDefault(require_lib7()), path_1 = __importDefault(require("path")), util_1 = require("util"), write_file_atomic_1 = __importDefault(require_write_file_atomic()), JsonFileError_1 = __importStar(require_JsonFileError()), writeFileAtomicAsync = (0, util_1.promisify)(write_file_atomic_1.default), DEFAULT_OPTIONS = {
      badJsonDefault: void 0,
      jsonParseErrorDefault: void 0,
      cantReadFileDefault: void 0,
      ensureDir: !1,
      default: void 0,
      json5: !1,
      space: 2,
      addNewLineAtEOF: !0
    }, JsonFile = /* @__PURE__ */ function() {
      function JsonFile2(file) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _class_call_check15(this, JsonFile2), _define_property21(this, "file", void 0), _define_property21(this, "options", void 0), this.file = file, this.options = options;
      }
      return _create_class13(JsonFile2, [
        {
          key: "read",
          value: function(options) {
            return read(this.file, this._getOptions(options));
          }
        },
        {
          key: "readAsync",
          value: function(options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  readAsync(_this.file, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "writeAsync",
          value: function(object, options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  writeAsync(_this.file, object, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "parseJsonString",
          value: function(json, options) {
            return parseJsonString(json, options);
          }
        },
        {
          key: "getAsync",
          value: function(key, defaultValue, options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  getAsync(_this.file, key, defaultValue, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "setAsync",
          value: function(key, value, options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  setAsync(_this.file, key, value, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "mergeAsync",
          value: function(sources, options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  mergeAsync(_this.file, sources, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "deleteKeyAsync",
          value: function(key, options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  deleteKeyAsync(_this.file, key, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "deleteKeysAsync",
          value: function(keys, options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  deleteKeysAsync(_this.file, keys, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "rewriteAsync",
          value: function(options) {
            var _this = this;
            return _async_to_generator31(function() {
              return _ts_generator31(this, function(_state) {
                return [
                  2,
                  rewriteAsync(_this.file, _this._getOptions(options))
                ];
              });
            })();
          }
        },
        {
          key: "_getOptions",
          value: function(options) {
            return _object_spread13({}, this.options, options);
          }
        }
      ]), JsonFile2;
    }();
    _define_property21(JsonFile, "read", read);
    _define_property21(JsonFile, "readAsync", readAsync);
    _define_property21(JsonFile, "parseJsonString", parseJsonString);
    _define_property21(JsonFile, "writeAsync", writeAsync);
    _define_property21(JsonFile, "getAsync", getAsync);
    _define_property21(JsonFile, "setAsync", setAsync);
    _define_property21(JsonFile, "mergeAsync", mergeAsync);
    _define_property21(JsonFile, "deleteKeyAsync", deleteKeyAsync);
    _define_property21(JsonFile, "deleteKeysAsync", deleteKeysAsync);
    _define_property21(JsonFile, "rewriteAsync", rewriteAsync);
    exports2.default = JsonFile;
    function read(file, options) {
      var json;
      try {
        json = fs_1.default.readFileSync(file, "utf8");
      } catch (error) {
        assertEmptyJsonString(json, file);
        var defaultValue = cantReadFileDefault(options);
        if (defaultValue === void 0)
          throw new JsonFileError_1.default("Can't read JSON file: ".concat(file), error, error.code, file);
        return defaultValue;
      }
      return parseJsonString(json, options, file);
    }
    function readAsync(file, options) {
      return _readAsync.apply(this, arguments);
    }
    function _readAsync() {
      return _readAsync = _async_to_generator31(function(file, options) {
        var json, error, defaultValue;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return _state.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                fs_1.default.promises.readFile(file, "utf8")
              ];
            case 1:
              return json = _state.sent(), [
                3,
                3
              ];
            case 2:
              if (error = _state.sent(), assertEmptyJsonString(json, file), defaultValue = cantReadFileDefault(options), defaultValue === void 0)
                throw new JsonFileError_1.default("Can't read JSON file: ".concat(file), error, error.code);
              return [
                2,
                defaultValue
              ];
            case 3:
              return [
                2,
                parseJsonString(json, options)
              ];
          }
        });
      }), _readAsync.apply(this, arguments);
    }
    function parseJsonString(json, options, fileName) {
      assertEmptyJsonString(json, fileName);
      try {
        return _getOption(options, "json5") ? json5_1.default.parse(json) : JSON.parse(json);
      } catch (e) {
        var defaultValue = jsonParseErrorDefault(options);
        if (defaultValue === void 0) {
          var location = locationFromSyntaxError(e, json);
          if (location) {
            var codeFrame = (0, code_frame_1.codeFrameColumns)(json, {
              start: location
            });
            e.codeFrame = codeFrame, e.message += `
`.concat(codeFrame);
          }
          throw new JsonFileError_1.default("Error parsing JSON: ".concat(json), e, "EJSONPARSE", fileName);
        } else
          return defaultValue;
      }
    }
    function getAsync(file, key, defaultValue, options) {
      return _getAsync.apply(this, arguments);
    }
    function _getAsync() {
      return _getAsync = _async_to_generator31(function(file, key, defaultValue, options) {
        var object;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                readAsync(file, options)
              ];
            case 1:
              if (object = _state.sent(), key in object)
                return [
                  2,
                  object[key]
                ];
              if (defaultValue === void 0)
                throw new JsonFileError_1.default('No value at key path "'.concat(String(key), '" in JSON object from: ').concat(file));
              return [
                2,
                defaultValue
              ];
          }
        });
      }), _getAsync.apply(this, arguments);
    }
    function writeAsync(file, object, options) {
      return _writeAsync.apply(this, arguments);
    }
    function _writeAsync() {
      return _writeAsync = _async_to_generator31(function(file, object, options) {
        var space, json5, addNewLineAtEOF, json, data;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return options != null && options.ensureDir ? [
                4,
                fs_1.default.promises.mkdir(path_1.default.dirname(file), {
                  recursive: !0
                })
              ] : [
                3,
                2
              ];
            case 1:
              _state.sent(), _state.label = 2;
            case 2:
              space = _getOption(options, "space"), json5 = _getOption(options, "json5"), addNewLineAtEOF = _getOption(options, "addNewLineAtEOF");
              try {
                json5 ? json = json5_1.default.stringify(object, null, space) : json = JSON.stringify(object, null, space);
              } catch (e) {
                throw new JsonFileError_1.default("Couldn't JSON.stringify object for file: ".concat(file), e);
              }
              return data = addNewLineAtEOF ? "".concat(json, `
`) : json, [
                4,
                writeFileAtomicAsync(file, data, {})
              ];
            case 3:
              return _state.sent(), [
                2,
                object
              ];
          }
        });
      }), _writeAsync.apply(this, arguments);
    }
    function setAsync(file, key, value, options) {
      return _setAsync.apply(this, arguments);
    }
    function _setAsync() {
      return _setAsync = _async_to_generator31(function(file, key, value, options) {
        var object;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                readAsync(file, options)
              ];
            case 1:
              return object = _state.sent(), [
                2,
                writeAsync(file, _object_spread_props9(_object_spread13({}, object), _define_property21({}, key, value)), options)
              ];
          }
        });
      }), _setAsync.apply(this, arguments);
    }
    function mergeAsync(file, sources, options) {
      return _mergeAsync.apply(this, arguments);
    }
    function _mergeAsync() {
      return _mergeAsync = _async_to_generator31(function(file, sources, options) {
        var object, _Object;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                readAsync(file, options)
              ];
            case 1:
              return object = _state.sent(), Array.isArray(sources) ? (_Object = Object).assign.apply(_Object, [
                object
              ].concat(_to_consumable_array16(sources))) : Object.assign(object, sources), [
                2,
                writeAsync(file, object, options)
              ];
          }
        });
      }), _mergeAsync.apply(this, arguments);
    }
    function deleteKeyAsync(file, key, options) {
      return _deleteKeyAsync.apply(this, arguments);
    }
    function _deleteKeyAsync() {
      return _deleteKeyAsync = _async_to_generator31(function(file, key, options) {
        return _ts_generator31(this, function(_state) {
          return [
            2,
            deleteKeysAsync(file, [
              key
            ], options)
          ];
        });
      }), _deleteKeyAsync.apply(this, arguments);
    }
    function deleteKeysAsync(file, keys, options) {
      return _deleteKeysAsync.apply(this, arguments);
    }
    function _deleteKeysAsync() {
      return _deleteKeysAsync = _async_to_generator31(function(file, keys, options) {
        var object, didDelete, i, key;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                readAsync(file, options)
              ];
            case 1:
              for (object = _state.sent(), didDelete = !1, i = 0; i < keys.length; i++)
                key = keys[i], object.hasOwnProperty(key) && (delete object[key], didDelete = !0);
              return didDelete ? [
                2,
                writeAsync(file, object, options)
              ] : [
                2,
                object
              ];
          }
        });
      }), _deleteKeysAsync.apply(this, arguments);
    }
    function rewriteAsync(file, options) {
      return _rewriteAsync.apply(this, arguments);
    }
    function _rewriteAsync() {
      return _rewriteAsync = _async_to_generator31(function(file, options) {
        var object;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                readAsync(file, options)
              ];
            case 1:
              return object = _state.sent(), [
                2,
                writeAsync(file, object, options)
              ];
          }
        });
      }), _rewriteAsync.apply(this, arguments);
    }
    function jsonParseErrorDefault() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return options.jsonParseErrorDefault === void 0 ? options.default : options.jsonParseErrorDefault;
    }
    function cantReadFileDefault() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return options.cantReadFileDefault === void 0 ? options.default : options.cantReadFileDefault;
    }
    function _getOption(options, field) {
      return options && options[field] !== void 0 ? options[field] : DEFAULT_OPTIONS[field];
    }
    function locationFromSyntaxError(error, sourceString) {
      if ("lineNumber" in error && "columnNumber" in error)
        return {
          line: error.lineNumber,
          column: error.columnNumber
        };
      var match2 = /at position (\d+)/.exec(error.message);
      if (match2) {
        var index = parseInt(match2[1], 10), lines = sourceString.slice(0, index + 1).split(`
`);
        return {
          line: lines.length,
          column: lines[lines.length - 1].length
        };
      }
      return null;
    }
    function assertEmptyJsonString(json, file) {
      if ((json == null ? void 0 : json.trim()) === "")
        throw new JsonFileError_1.EmptyJsonFileError(file);
    }
  }
});

// ../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host-info.js
var require_git_host_info = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host-info.js"(exports2, module2) {
    "use strict";
    var gitHosts = module2.exports = {
      github: {
        // First two are insecure and generally shouldn't be used any more, but
        // they are still supported.
        protocols: [
          "git",
          "http",
          "git+ssh",
          "git+https",
          "ssh",
          "https"
        ],
        domain: "github.com",
        treepath: "tree",
        filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
        bugstemplate: "https://{domain}/{user}/{project}/issues",
        gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
        tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
      },
      bitbucket: {
        protocols: [
          "git+ssh",
          "git+https",
          "ssh",
          "https"
        ],
        domain: "bitbucket.org",
        treepath: "src",
        tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
      },
      gitlab: {
        protocols: [
          "git+ssh",
          "git+https",
          "ssh",
          "https"
        ],
        domain: "gitlab.com",
        treepath: "tree",
        bugstemplate: "https://{domain}/{user}/{project}/issues",
        httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
        tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
        pathmatch: /^\/([^/]+)\/((?!.*(\/-\/|\/repository(\/[^/]+)?\/archive\.tar\.gz)).*?)(?:\.git|\/)?$/
      },
      gist: {
        protocols: [
          "git",
          "git+ssh",
          "git+https",
          "ssh",
          "https"
        ],
        domain: "gist.github.com",
        pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{7,})(?:[.]git)?$/,
        filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
        bugstemplate: "https://{domain}/{project}",
        gittemplate: "git://{domain}/{project}.git{#committish}",
        sshtemplate: "git@{domain}:/{project}.git{#committish}",
        sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
        browsetemplate: "https://{domain}/{project}{/committish}",
        browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
        docstemplate: "https://{domain}/{project}{/committish}",
        httpstemplate: "git+https://{domain}/{project}.git{#committish}",
        shortcuttemplate: "{type}:{project}{#committish}",
        pathtemplate: "{project}{#committish}",
        tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
        hashformat: function(fragment) {
          return "file-" + formatHashFragment(fragment);
        }
      }
    }, gitHostDefaults = {
      sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
      sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
      browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
      browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
      docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
      httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
      filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
      shortcuttemplate: "{type}:{user}/{project}{#committish}",
      pathtemplate: "{user}/{project}{#committish}",
      pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
      hashformat: formatHashFragment
    };
    Object.keys(gitHosts).forEach(function(name) {
      Object.keys(gitHostDefaults).forEach(function(key) {
        gitHosts[name][key] || (gitHosts[name][key] = gitHostDefaults[key]);
      }), gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map(function(protocol) {
        return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
      }).join("|") + "):$");
    });
    function formatHashFragment(fragment) {
      return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
    }
  }
});

// ../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host.js
var require_git_host = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host.js"(exports2, module2) {
    "use strict";
    var gitHosts = require_git_host_info(), extend = Object.assign || function(target, source) {
      if (source === null || typeof source != "object")
        return target;
      for (var keys = Object.keys(source), i = keys.length; i--; )
        target[keys[i]] = source[keys[i]];
      return target;
    };
    module2.exports = GitHost;
    function GitHost(type, user, auth, project, committish, defaultRepresentation, opts) {
      var gitHostInfo = this;
      gitHostInfo.type = type, Object.keys(gitHosts[type]).forEach(function(key) {
        gitHostInfo[key] = gitHosts[type][key];
      }), gitHostInfo.user = user, gitHostInfo.auth = auth, gitHostInfo.project = project, gitHostInfo.committish = committish, gitHostInfo.default = defaultRepresentation, gitHostInfo.opts = opts || {};
    }
    GitHost.prototype.hash = function() {
      return this.committish ? "#" + this.committish : "";
    };
    GitHost.prototype._fill = function(template, opts) {
      if (template) {
        var vars = extend({}, opts);
        vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "", opts = extend(extend({}, this.opts), opts);
        var self = this;
        Object.keys(this).forEach(function(key) {
          self[key] != null && vars[key] == null && (vars[key] = self[key]);
        });
        var rawAuth = vars.auth, rawcommittish = vars.committish, rawFragment = vars.fragment, rawPath = vars.path, rawProject = vars.project;
        Object.keys(vars).forEach(function(key) {
          var value = vars[key];
          (key === "path" || key === "project") && typeof value == "string" ? vars[key] = value.split("/").map(function(pathComponent) {
            return encodeURIComponent(pathComponent);
          }).join("/") : key !== "domain" && (vars[key] = encodeURIComponent(value));
        }), vars["auth@"] = rawAuth ? rawAuth + "@" : "", vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "", vars.fragment = vars.fragment ? vars.fragment : "", vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "", vars["/path"] = vars.path ? "/" + vars.path : "", vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/"), opts.noCommittish ? (vars["#committish"] = "", vars["/tree/committish"] = "", vars["/committish"] = "", vars.committish = "") : (vars["#committish"] = rawcommittish ? "#" + rawcommittish : "", vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "", vars["/committish"] = vars.committish ? "/" + vars.committish : "", vars.committish = vars.committish || "master");
        var res = template;
        return Object.keys(vars).forEach(function(key) {
          res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
        }), opts.noGitPlus ? res.replace(/^git[+]/, "") : res;
      }
    };
    GitHost.prototype.ssh = function(opts) {
      return this._fill(this.sshtemplate, opts);
    };
    GitHost.prototype.sshurl = function(opts) {
      return this._fill(this.sshurltemplate, opts);
    };
    GitHost.prototype.browse = function(P, F, opts) {
      return typeof P == "string" ? (typeof F != "string" && (opts = F, F = null), this._fill(this.browsefiletemplate, extend({
        fragment: F,
        path: P
      }, opts))) : this._fill(this.browsetemplate, P);
    };
    GitHost.prototype.docs = function(opts) {
      return this._fill(this.docstemplate, opts);
    };
    GitHost.prototype.bugs = function(opts) {
      return this._fill(this.bugstemplate, opts);
    };
    GitHost.prototype.https = function(opts) {
      return this._fill(this.httpstemplate, opts);
    };
    GitHost.prototype.git = function(opts) {
      return this._fill(this.gittemplate, opts);
    };
    GitHost.prototype.shortcut = function(opts) {
      return this._fill(this.shortcuttemplate, opts);
    };
    GitHost.prototype.path = function(opts) {
      return this._fill(this.pathtemplate, opts);
    };
    GitHost.prototype.tarball = function(opts_) {
      var opts = extend({}, opts_, {
        noCommittish: !1
      });
      return this._fill(this.tarballtemplate, opts);
    };
    GitHost.prototype.file = function(P, opts) {
      return this._fill(this.filetemplate, extend({
        path: P
      }, opts));
    };
    GitHost.prototype.getDefaultRepresentation = function() {
      return this.default;
    };
    GitHost.prototype.toString = function(opts) {
      return this.default && typeof this[this.default] == "function" ? this[this.default](opts) : this.sshurl(opts);
    };
  }
});

// ../../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function() {
        var walker;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              walker = this.head, _state.label = 1;
            case 1:
              return walker ? [
                4,
                walker.value
              ] : [
                3,
                4
              ];
            case 2:
              _state.sent(), _state.label = 3;
            case 3:
              return walker = walker.next, [
                3,
                1
              ];
            case 4:
              return [
                2
              ];
          }
        });
      };
    };
  }
});

// ../../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (_instanceof13(self, Yallist) || (self = new Yallist()), self.tail = null, self.head = null, self.length = 0, list && typeof list.forEach == "function")
        list.forEach(function(item) {
          self.push(item);
        });
      else if (arguments.length > 0)
        for (var i = 0, l = arguments.length; i < l; i++)
          self.push(arguments[i]);
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this)
        throw new Error("removing node which does not belong to this list");
      var next = node.next, prev = node.prev;
      return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node !== this.head) {
        node.list && node.list.removeNode(node);
        var head = this.head;
        node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
      }
    };
    Yallist.prototype.pushNode = function(node) {
      if (node !== this.tail) {
        node.list && node.list.removeNode(node);
        var tail = this.tail;
        node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
      }
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        push(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        unshift(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (this.tail) {
        var res = this.tail.value;
        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
      }
    };
    Yallist.prototype.shift = function() {
      if (this.head) {
        var res = this.head.value;
        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
      }
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++)
        fn.call(thisp, walker.value, i, this), walker = walker.next;
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
        fn.call(thisp, walker.value, i, this), walker = walker.prev;
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++)
        walker = walker.next;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
        walker = walker.prev;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.head; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.tail; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc, walker = this.head;
      if (arguments.length > 1)
        acc = initial;
      else if (this.head)
        walker = this.head.next, acc = this.head.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = 0; walker !== null; i++)
        acc = fn(acc, walker.value, i), walker = walker.next;
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc, walker = this.tail;
      if (arguments.length > 1)
        acc = initial;
      else if (this.tail)
        walker = this.tail.prev, acc = this.tail.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = this.length - 1; walker !== null; i--)
        acc = fn(acc, walker.value, i), walker = walker.prev;
      return acc;
    };
    Yallist.prototype.toArray = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
        arr[i] = walker.value, walker = walker.next;
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
        arr[i] = walker.value, walker = walker.prev;
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = 0, walker = this.head; walker !== null && i < from; i++)
        walker = walker.next;
      for (; walker !== null && i < to; i++, walker = walker.next)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
        walker = walker.prev;
      for (; walker !== null && i > from; i--, walker = walker.prev)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount) {
      for (var _len = arguments.length, nodes = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
        nodes[_key - 2] = arguments[_key];
      start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
      for (var i = 0, walker = this.head; walker !== null && i < start; i++)
        walker = walker.next;
      for (var ret = [], i = 0; walker && i < deleteCount; i++)
        ret.push(walker.value), walker = this.removeNode(walker);
      walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
      for (var i = 0; i < nodes.length; i++)
        walker = insert(this, walker, nodes[i]);
      return ret;
    };
    Yallist.prototype.reverse = function() {
      for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next, walker.next = p;
      }
      return this.head = tail, this.tail = head, this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      return inserted.next === null && (self.tail = inserted), inserted.prev === null && (self.head = inserted), self.length++, inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), self.length++;
    }
    function Node(value, prev, next, list) {
      if (!_instanceof13(this, Node))
        return new Node(value, prev, next, list);
      this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
    }
    try {
      require_iterator()(Yallist);
    } catch {
    }
  }
});

// ../../node_modules/npm-package-arg/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    var Yallist = require_yallist(), MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = function() {
      return 1;
    }, LRUCache2 = /* @__PURE__ */ function() {
      function LRUCache3(options) {
        if (_class_call_check15(this, LRUCache3), typeof options == "number" && (options = {
          max: options
        }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        var max = this[MAX] = options.max || 1 / 0, lc = options.length || naiveLength;
        if (this[LENGTH_CALCULATOR] = typeof lc != "function" ? naiveLength : lc, this[ALLOW_STALE] = options.stale || !1, options.maxAge && typeof options.maxAge != "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || !1, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || !1, this.reset();
      }
      return _create_class13(LRUCache3, [
        {
          key: "max",
          get: function() {
            return this[MAX];
          },
          set: (
            // resize the cache when the max changes.
            function(mL) {
              if (typeof mL != "number" || mL < 0)
                throw new TypeError("max must be a non-negative number");
              this[MAX] = mL || 1 / 0, trim(this);
            }
          )
        },
        {
          key: "allowStale",
          get: function() {
            return this[ALLOW_STALE];
          },
          set: function(allowStale) {
            this[ALLOW_STALE] = !!allowStale;
          }
        },
        {
          key: "maxAge",
          get: function() {
            return this[MAX_AGE];
          },
          set: function(mA) {
            if (typeof mA != "number")
              throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = mA, trim(this);
          }
        },
        {
          key: "lengthCalculator",
          get: function() {
            return this[LENGTH_CALCULATOR];
          },
          set: (
            // resize the cache when the lengthCalculator changes.
            function(lC) {
              var _this = this;
              typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach(function(hit) {
                hit.length = _this[LENGTH_CALCULATOR](hit.value, hit.key), _this[LENGTH] += hit.length;
              })), trim(this);
            }
          )
        },
        {
          key: "length",
          get: function() {
            return this[LENGTH];
          }
        },
        {
          key: "itemCount",
          get: function() {
            return this[LRU_LIST].length;
          }
        },
        {
          key: "rforEach",
          value: function(fn, thisp) {
            thisp = thisp || this;
            for (var walker = this[LRU_LIST].tail; walker !== null; ) {
              var prev = walker.prev;
              forEachStep(this, fn, walker, thisp), walker = prev;
            }
          }
        },
        {
          key: "forEach",
          value: function(fn, thisp) {
            thisp = thisp || this;
            for (var walker = this[LRU_LIST].head; walker !== null; ) {
              var next = walker.next;
              forEachStep(this, fn, walker, thisp), walker = next;
            }
          }
        },
        {
          key: "keys",
          value: function() {
            return this[LRU_LIST].toArray().map(function(k) {
              return k.key;
            });
          }
        },
        {
          key: "values",
          value: function() {
            return this[LRU_LIST].toArray().map(function(k) {
              return k.value;
            });
          }
        },
        {
          key: "reset",
          value: function() {
            var _this = this;
            this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach(function(hit) {
              return _this[DISPOSE](hit.key, hit.value);
            }), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
          }
        },
        {
          // length of items in the list
          key: "dump",
          value: function() {
            var _this = this;
            return this[LRU_LIST].map(function(hit) {
              return isStale(_this, hit) ? !1 : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
              };
            }).toArray().filter(function(h) {
              return h;
            });
          }
        },
        {
          key: "dumpLru",
          value: function() {
            return this[LRU_LIST];
          }
        },
        {
          key: "set",
          value: function(key, value, maxAge) {
            if (maxAge = maxAge || this[MAX_AGE], maxAge && typeof maxAge != "number")
              throw new TypeError("maxAge must be a number");
            var now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
            if (this[CACHE].has(key)) {
              if (len > this[MAX])
                return del(this, this[CACHE].get(key)), !1;
              var node = this[CACHE].get(key), item = node.value;
              return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), !0;
            }
            var hit = new Entry(key, value, len, now, maxAge);
            return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), !1) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), !0);
          }
        },
        {
          key: "has",
          value: function(key) {
            if (!this[CACHE].has(key))
              return !1;
            var hit = this[CACHE].get(key).value;
            return !isStale(this, hit);
          }
        },
        {
          key: "get",
          value: function(key) {
            return get4(this, key, !0);
          }
        },
        {
          key: "peek",
          value: function(key) {
            return get4(this, key, !1);
          }
        },
        {
          key: "pop",
          value: function() {
            var node = this[LRU_LIST].tail;
            return node ? (del(this, node), node.value) : null;
          }
        },
        {
          key: "del",
          value: function(key) {
            del(this, this[CACHE].get(key));
          }
        },
        {
          key: "load",
          value: function(arr) {
            this.reset();
            for (var now = Date.now(), l = arr.length - 1; l >= 0; l--) {
              var hit = arr[l], expiresAt = hit.e || 0;
              if (expiresAt === 0)
                this.set(hit.k, hit.v);
              else {
                var maxAge = expiresAt - now;
                maxAge > 0 && this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        },
        {
          key: "prune",
          value: function() {
            var _this = this;
            this[CACHE].forEach(function(value, key) {
              return get4(_this, key, !1);
            });
          }
        }
      ]), LRUCache3;
    }(), get4 = function(self, key, doUse) {
      var node = self[CACHE].get(key);
      if (node) {
        var hit = node.value;
        if (isStale(self, hit)) {
          if (del(self, node), !self[ALLOW_STALE])
            return;
        } else
          doUse && (self[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self[LRU_LIST].unshiftNode(node));
        return hit.value;
      }
    }, isStale = function(self, hit) {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return !1;
      var diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    }, trim = function(self) {
      if (self[LENGTH] > self[MAX])
        for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self, walker), walker = prev;
        }
    }, del = function(self, node) {
      if (node) {
        var hit = node.value;
        self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
      }
    }, Entry = function Entry2(key, value, length, now, maxAge) {
      _class_call_check15(this, Entry2), this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
    }, forEachStep = function(self, fn, node, thisp) {
      var hit = node.value;
      isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
    };
    module2.exports = LRUCache2;
  }
});

// ../../node_modules/npm-package-arg/node_modules/hosted-git-info/index.js
var require_hosted_git_info = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/hosted-git-info/index.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var url = require("url"), gitHosts = require_git_host_info(), GitHost = module2.exports = require_git_host(), LRU = require_lru_cache(), cache2 = new LRU({
      max: 1e3
    }), protocolToRepresentationMap = {
      "git+ssh:": "sshurl",
      "git+https:": "https",
      "ssh:": "sshurl",
      "git:": "git"
    };
    function protocolToRepresentation(protocol) {
      return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
    }
    var authProtocols = {
      "git:": !0,
      "https:": !0,
      "git+https:": !0,
      "http:": !0,
      "git+http:": !0
    };
    module2.exports.fromUrl = function(giturl, opts) {
      if (typeof giturl == "string") {
        var key = giturl + JSON.stringify(opts || {});
        return cache2.has(key) || cache2.set(key, fromUrl(giturl, opts)), cache2.get(key);
      }
    };
    function fromUrl(giturl, opts) {
      if (!(giturl == null || giturl === "")) {
        var url2 = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? "github:" + giturl : giturl), parsed = parseGitUrl(url2), shortcutMatch = url2.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/), matches = Object.keys(gitHosts).map(function(gitHostName) {
          try {
            var gitHostInfo = gitHosts[gitHostName], auth = null;
            parsed.auth && authProtocols[parsed.protocol] && (auth = parsed.auth);
            var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null, user = null, project = null, defaultRepresentation = null;
            if (shortcutMatch && shortcutMatch[1] === gitHostName)
              user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]), project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, "")), defaultRepresentation = "shortcut";
            else {
              if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain || !gitHostInfo.protocols_re.test(parsed.protocol) || !parsed.path)
                return;
              var pathmatch = gitHostInfo.pathmatch, matched = parsed.path.match(pathmatch);
              if (!matched)
                return;
              matched[1] !== null && matched[1] !== void 0 && (user = decodeURIComponent(matched[1].replace(/^:/, ""))), project = decodeURIComponent(matched[2]), defaultRepresentation = protocolToRepresentation(parsed.protocol);
            }
            return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
          } catch (ex) {
            if (!_instanceof13(ex, URIError))
              throw ex;
          }
        }).filter(function(gitHostInfo) {
          return gitHostInfo;
        });
        if (matches.length === 1)
          return matches[0];
      }
    }
    function isGitHubShorthand(arg) {
      return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg);
    }
    function fixupUnqualifiedGist(giturl) {
      var parsed = url.parse(giturl);
      return parsed.protocol === "gist:" && parsed.host && !parsed.path ? parsed.protocol + "/" + parsed.host : giturl;
    }
    function parseGitUrl(giturl) {
      var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
      if (!matched) {
        var legacy = url.parse(giturl);
        if (legacy.auth) {
          var authmatch = giturl.match(/[^@]+@[^:/]+/);
          if (authmatch) {
            var whatwg = new url.URL(authmatch[0]);
            legacy.auth = whatwg.username || "", whatwg.password && (legacy.auth += ":" + whatwg.password);
          }
        }
        return legacy;
      }
      return {
        protocol: "git+ssh:",
        slashes: !0,
        auth: matched[1],
        host: matched[2],
        port: null,
        hostname: matched[2],
        hash: matched[4],
        search: null,
        query: null,
        pathname: "/" + matched[3],
        path: "/" + matched[3],
        href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
      };
    }
  }
});

// ../../node_modules/os-tmpdir/index.js
var require_os_tmpdir = __commonJS({
  "../../node_modules/os-tmpdir/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32", trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
    module2.exports = function() {
      var path6;
      return isWindows ? path6 = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp" : path6 = process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp", trailingSlashRe.test(path6) && (path6 = path6.slice(0, -1)), path6;
    };
  }
});

// ../../node_modules/os-homedir/index.js
var require_os_homedir = __commonJS({
  "../../node_modules/os-homedir/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    function homedir2() {
      var env2 = process.env, home2 = env2.HOME, user = env2.LOGNAME || env2.USER || env2.LNAME || env2.USERNAME;
      return process.platform === "win32" ? env2.USERPROFILE || env2.HOMEDRIVE + env2.HOMEPATH || home2 || null : process.platform === "darwin" ? home2 || (user ? "/Users/" + user : null) : process.platform === "linux" ? home2 || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null) : home2 || null;
    }
    module2.exports = typeof os2.homedir == "function" ? os2.homedir : homedir2;
  }
});

// ../../node_modules/osenv/osenv.js
var require_osenv = __commonJS({
  "../../node_modules/osenv/osenv.js"(exports2) {
    var isWindows = process.platform === "win32", path6 = require("path"), exec2 = require("child_process").exec, osTmpdir = require_os_tmpdir(), osHomedir = require_os_homedir();
    function memo(key, lookup, fallback) {
      var fell = !1, falling = !1;
      exports2[key] = function(cb) {
        var val = lookup();
        return !val && !fell && !falling && fallback && (fell = !0, falling = !0, exec2(fallback, function(er, output, stderr) {
          falling = !1, !er && (val = output.trim());
        })), exports2[key] = function(cb2) {
          return cb2 && process.nextTick(cb2.bind(null, null, val)), val;
        }, cb && !falling && process.nextTick(cb.bind(null, null, val)), val;
      };
    }
    memo("user", function() {
      return isWindows ? process.env.USERDOMAIN + "\\" + process.env.USERNAME : process.env.USER;
    }, "whoami");
    memo("prompt", function() {
      return isWindows ? process.env.PROMPT : process.env.PS1;
    });
    memo("hostname", function() {
      return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME;
    }, "hostname");
    memo("tmpdir", function() {
      return osTmpdir();
    });
    memo("home", function() {
      return osHomedir();
    });
    memo("path", function() {
      return (process.env.PATH || process.env.Path || process.env.path).split(isWindows ? ";" : ":");
    });
    memo("editor", function() {
      return process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi");
    });
    memo("shell", function() {
      return isWindows ? process.env.ComSpec || "cmd" : process.env.SHELL || "bash";
    });
  }
});

// ../../node_modules/npm-package-arg/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/semver/semver.js"(exports2, module2) {
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    exports2 = module2.exports = SemVer;
    var debug;
    typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER"), console.log.apply(console, args);
    } : debug = function() {
    };
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256, MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991, MAX_SAFE_COMPONENT_LENGTH = 16, re = exports2.re = [], src = exports2.src = [], R = 0, NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++, FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?", LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~", TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^", CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3", HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++)
      debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
    var i;
    exports2.parse = parse6;
    function parse6(version2, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), _instanceof13(version2, SemVer))
        return version2;
      if (typeof version2 != "string" || version2.length > MAX_LENGTH)
        return null;
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version2))
        return null;
      try {
        return new SemVer(version2, options);
      } catch {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version2, options) {
      var v = parse6(version2, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version2, options) {
      var s = parse6(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version2, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), _instanceof13(version2, SemVer)) {
        if (version2.loose === options.loose)
          return version2;
        version2 = version2.version;
      } else if (typeof version2 != "string")
        throw new TypeError("Invalid Version: " + version2);
      if (version2.length > MAX_LENGTH)
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      if (!_instanceof13(this, SemVer))
        return new SemVer(version2, options);
      debug("SemVer", version2, options), this.options = options, this.loose = !!options.loose;
      var m = version2.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m)
        throw new TypeError("Invalid Version: " + version2);
      if (this.raw = version2, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError("Invalid patch version");
      m[4] ? this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER)
            return num;
        }
        return id;
      }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
    }
    SemVer.prototype.format = function() {
      return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      return debug("SemVer.compare", this.version, this.options, other), _instanceof13(other, SemVer) || (other = new SemVer(other, this.options)), this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      return _instanceof13(other, SemVer) || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (_instanceof13(other, SemVer) || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
        return -1;
      if (!this.prerelease.length && other.prerelease.length)
        return 1;
      if (!this.prerelease.length && !other.prerelease.length)
        return 0;
      var i2 = 0;
      do {
        var a = this.prerelease[i2], b = other.prerelease[i2];
        if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
          return 0;
        if (b === void 0)
          return 1;
        if (a === void 0)
          return -1;
        if (a === b)
          continue;
        return compareIdentifiers(a, b);
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [
              0
            ];
          else {
            for (var i2 = this.prerelease.length; --i2 >= 0; )
              typeof this.prerelease[i2] == "number" && (this.prerelease[i2]++, i2 = -2);
            i2 === -1 && this.prerelease.push(0);
          }
          identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [
            identifier,
            0
          ]) : this.prerelease = [
            identifier,
            0
          ]);
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      return this.format(), this.raw = this.version, this;
    };
    exports2.inc = inc;
    function inc(version2, release, loose, identifier) {
      typeof loose == "string" && (identifier = loose, loose = void 0);
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2))
        return null;
      var v1 = parse6(version1), v2 = parse6(version2), prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1)
        if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
          return prefix + key;
      return defaultResult;
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a), bnum = numeric.test(b);
      return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, !0);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
        case "!==":
          return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), _instanceof13(comp, Comparator)) {
        if (comp.loose === !!options.loose)
          return comp;
        comp = comp.value;
      }
      if (!_instanceof13(this, Comparator))
        return new Comparator(comp, options);
      debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR], m = comp.match(r);
      if (!m)
        throw new TypeError("Invalid comparator: " + comp);
      this.operator = m[1], this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      return debug("Comparator.test", version2, this.options.loose), this.semver === ANY ? !0 : (typeof version2 == "string" && (version2 = new SemVer(version2, this.options)), cmp(version2, this.operator, this.semver, this.options));
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!_instanceof13(comp, Comparator))
        throw new TypeError("a Comparator is required");
      (!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      });
      var rangeTmp;
      if (this.operator === "")
        return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
      if (comp.operator === "")
        return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">"), sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<="), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), _instanceof13(range, Range))
        return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
      if (_instanceof13(range, Comparator))
        return new Range(range.value, options);
      if (!_instanceof13(this, Range))
        return new Range(range, options);
      if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range, this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      }), !this.set.length)
        throw new TypeError("Invalid SemVer Range: " + range);
      this.format();
    }
    Range.prototype.format = function() {
      return this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim(), this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range, re[COMPARATORTRIM]), range = range.replace(re[TILDETRIM], tildeTrimReplace), range = range.replace(re[CARETTRIM], caretTrimReplace), range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR], set3 = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      return this.options.loose && (set3 = set3.filter(function(comp) {
        return !!comp.match(compRe);
      })), set3 = set3.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this), set3;
    };
    Range.prototype.intersects = function(range, options) {
      if (!_instanceof13(range, Range))
        throw new TypeError("a Range is required");
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      return debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", debug("tilde return", ret), ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? M === "0" ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
      });
    }
    function replaceXRanges(comp, options) {
      return debug("replaceXRanges", comp, options), comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
        return gtlt === "=" && anyX && (gtlt = ""), xM ? gtlt === ">" || gtlt === "<" ? ret = "<0.0.0" : ret = "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), debug("xRange return", ret), ret;
      });
    }
    function replaceStars(comp, options) {
      return debug("replaceStars", comp, options), comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      return isX(fM) ? from = "" : isX(fm) ? from = ">=" + fM + ".0.0" : isX(fp) ? from = ">=" + fM + "." + fm + ".0" : from = ">=" + from, isX(tM) ? to = "" : isX(tm) ? to = "<" + (+tM + 1) + ".0.0" : isX(tp) ? to = "<" + tM + "." + (+tm + 1) + ".0" : tpr ? to = "<=" + tM + "." + tm + "." + tp + "-" + tpr : to = "<=" + to, (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2)
        return !1;
      typeof version2 == "string" && (version2 = new SemVer(version2, this.options));
      for (var i2 = 0; i2 < this.set.length; i2++)
        if (testSet(this.set[i2], version2, this.options))
          return !0;
      return !1;
    };
    function testSet(set3, version2, options) {
      for (var i2 = 0; i2 < set3.length; i2++)
        if (!set3[i2].test(version2))
          return !1;
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set3.length; i2++)
          if (debug(set3[i2].semver), set3[i2].semver !== ANY && set3[i2].semver.prerelease.length > 0) {
            var allowed = set3[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch)
              return !0;
          }
        return !1;
      }
      return !0;
    }
    exports2.satisfies = satisfies;
    function satisfies(version2, range, options) {
      try {
        range = new Range(range, options);
      } catch {
        return !1;
      }
      return range.test(version2);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null, maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch {
        return null;
      }
      return versions.forEach(function(v) {
        rangeObj.test(v) && (!max || maxSV.compare(v) === -1) && (max = v, maxSV = new SemVer(max, options));
      }), max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null, minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch {
        return null;
      }
      return versions.forEach(function(v) {
        rangeObj.test(v) && (!min || minSV.compare(v) === 1) && (min = v, minSV = new SemVer(min, options));
      }), min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver) || (minver = new SemVer("0.0.0-0"), range.test(minver)))
        return minver;
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
            case "":
            case ">=":
              (!minver || gt(minver, compver)) && (minver = compver);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      return minver && range.test(minver) ? minver : null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version2, range, options) {
      return outside(version2, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version2, range, options) {
      return outside(version2, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version2, range, hilo, options) {
      version2 = new SemVer(version2, options), range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
          break;
        case "<":
          gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options))
        return !1;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2], high = null, low = null;
        if (comparators.forEach(function(comparator) {
          comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
        }), high.operator === comp || high.operator === ecomp || (!low.operator || low.operator === comp) && ltefn(version2, low.semver))
          return !1;
        if (low.operator === ecomp && ltfn(version2, low.semver))
          return !1;
      }
      return !0;
    }
    exports2.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse6(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version2) {
      if (_instanceof13(version2, SemVer))
        return version2;
      if (typeof version2 != "string")
        return null;
      var match2 = version2.match(re[COERCE]);
      return match2 == null ? null : parse6(match2[1] + "." + (match2[2] || "0") + "." + (match2[3] || "0"));
    }
  }
});

// ../../node_modules/npm-package-arg/npa.js
var require_npa = __commonJS({
  "../../node_modules/npm-package-arg/npa.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    module2.exports = npa;
    module2.exports.resolve = resolve7;
    module2.exports.Result = Result2;
    var url, HostedGit, semver, path_;
    function path6() {
      return path_ || (path_ = require("path")), path_;
    }
    var validatePackageName, osenv, isWindows = process.platform === "win32" || global.FAKE_WINDOWS, hasSlashes = isWindows ? /\\|[/]/ : /[/]/, isURL = /^(?:git[+])?[a-z]+:/i, isFilename = /[.](?:tgz|tar.gz|tar)$/i;
    function npa(arg, where) {
      var name, spec;
      if (typeof arg == "object")
        return _instanceof13(arg, Result2) && (!where || where === arg.where) ? arg : arg.name && arg.rawSpec ? npa.resolve(arg.name, arg.rawSpec, where || arg.where) : npa(arg.raw, where || arg.where);
      var nameEndsAt = arg[0] === "@" ? arg.slice(1).indexOf("@") + 1 : arg.indexOf("@"), namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
      if (isURL.test(arg))
        spec = arg;
      else if (namePart[0] !== "@" && (hasSlashes.test(namePart) || isFilename.test(namePart)))
        spec = arg;
      else if (nameEndsAt > 0)
        name = namePart, spec = arg.slice(nameEndsAt + 1);
      else {
        validatePackageName || (validatePackageName = require_validate_npm_package_name());
        var valid = validatePackageName(arg);
        valid.validForOldPackages ? name = arg : spec = arg;
      }
      return resolve7(name, spec, where, arg);
    }
    var isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
    function resolve7(name, spec, where, arg) {
      var res = new Result2({
        raw: arg,
        name,
        rawSpec: spec,
        fromArgument: arg != null
      });
      if (name && res.setName(name), spec && (isFilespec.test(spec) || /^file:/i.test(spec)))
        return fromFile(res, where);
      if (spec && /^npm:/i.test(spec))
        return fromAlias(res, where);
      HostedGit || (HostedGit = require_hosted_git_info());
      var hosted = HostedGit.fromUrl(spec, {
        noGitPlus: !0,
        noCommittish: !0
      });
      return hosted ? fromHostedGit(res, hosted) : spec && isURL.test(spec) ? fromURL(res) : spec && (hasSlashes.test(spec) || isFilename.test(spec)) ? fromFile(res, where) : fromRegistry(res);
    }
    function invalidPackageName(name, valid) {
      var err = new Error('Invalid package name "'.concat(name, '": ').concat(valid.errors.join("; ")));
      return err.code = "EINVALIDPACKAGENAME", err;
    }
    function invalidTagName(name) {
      var err = new Error('Invalid tag name "'.concat(name, '": Tags may not have any characters that encodeURIComponent encodes.'));
      return err.code = "EINVALIDTAGNAME", err;
    }
    function Result2(opts) {
      this.type = opts.type, this.registry = opts.registry, this.where = opts.where, opts.raw == null ? this.raw = opts.name ? opts.name + "@" + opts.rawSpec : opts.rawSpec : this.raw = opts.raw, this.name = void 0, this.escapedName = void 0, this.scope = void 0, this.rawSpec = opts.rawSpec == null ? "" : opts.rawSpec, this.saveSpec = opts.saveSpec, this.fetchSpec = opts.fetchSpec, opts.name && this.setName(opts.name), this.gitRange = opts.gitRange, this.gitCommittish = opts.gitCommittish, this.hosted = opts.hosted;
    }
    Result2.prototype.setName = function(name) {
      validatePackageName || (validatePackageName = require_validate_npm_package_name());
      var valid = validatePackageName(name);
      if (!valid.validForOldPackages)
        throw invalidPackageName(name, valid);
      return this.name = name, this.scope = name[0] === "@" ? name.slice(0, name.indexOf("/")) : void 0, this.escapedName = name.replace("/", "%2f"), this;
    };
    Result2.prototype.toString = function() {
      var full = [];
      this.name != null && this.name !== "" && full.push(this.name);
      var spec = this.saveSpec || this.fetchSpec || this.rawSpec;
      return spec != null && spec !== "" && full.push(spec), full.length ? full.join("@") : this.raw;
    };
    Result2.prototype.toJSON = function() {
      var result = Object.assign({}, this);
      return delete result.hosted, result;
    };
    function setGitCommittish(res, committish) {
      return committish != null && committish.length >= 7 && committish.slice(0, 7) === "semver:" ? (res.gitRange = decodeURIComponent(committish.slice(7)), res.gitCommittish = null) : res.gitCommittish = committish === "" ? null : committish, res;
    }
    var isAbsolutePath = /^[/]|^[A-Za-z]:/;
    function resolvePath(where, spec) {
      return isAbsolutePath.test(spec) ? spec : path6().resolve(where, spec);
    }
    function isAbsolute(dir) {
      return !!(dir[0] === "/" || /^[A-Za-z]:/.test(dir));
    }
    function fromFile(res, where) {
      where || (where = process.cwd()), res.type = isFilename.test(res.rawSpec) ? "file" : "directory", res.where = where;
      var spec = res.rawSpec.replace(/\\/g, "/").replace(/^file:[/]*([A-Za-z]:)/, "$1").replace(/^file:(?:[/]*([~./]))?/, "$1");
      return /^~[/]/.test(spec) ? (osenv || (osenv = require_osenv()), res.fetchSpec = resolvePath(osenv.home(), spec.slice(2)), res.saveSpec = "file:" + spec) : (res.fetchSpec = resolvePath(where, spec), isAbsolute(spec) ? res.saveSpec = "file:" + spec : res.saveSpec = "file:" + path6().relative(where, res.fetchSpec)), res;
    }
    function fromHostedGit(res, hosted) {
      return res.type = "git", res.hosted = hosted, res.saveSpec = hosted.toString({
        noGitPlus: !1,
        noCommittish: !1
      }), res.fetchSpec = hosted.getDefaultRepresentation() === "shortcut" ? null : hosted.toString(), setGitCommittish(res, hosted.committish);
    }
    function unsupportedURLType(protocol, spec) {
      var err = new Error('Unsupported URL Type "'.concat(protocol, '": ').concat(spec));
      return err.code = "EUNSUPPORTEDPROTOCOL", err;
    }
    function matchGitScp(spec) {
      var matched = spec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
      return matched && !matched[1].match(/:[0-9]+\/?.*$/i) && {
        fetchSpec: matched[1],
        gitCommittish: matched[2] == null ? null : matched[2]
      };
    }
    function fromURL(res) {
      url || (url = require("url"));
      var urlparse = url.parse(res.rawSpec);
      switch (res.saveSpec = res.rawSpec, urlparse.protocol) {
        case "git:":
        case "git+http:":
        case "git+https:":
        case "git+rsync:":
        case "git+ftp:":
        case "git+file:":
        case "git+ssh:":
          res.type = "git";
          var match2 = urlparse.protocol === "git+ssh:" && matchGitScp(res.rawSpec);
          match2 ? (setGitCommittish(res, match2.gitCommittish), res.fetchSpec = match2.fetchSpec) : (setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : ""), urlparse.protocol = urlparse.protocol.replace(/^git[+]/, ""), urlparse.protocol === "file:" && /^git\+file:\/\/[a-z]:/i.test(res.rawSpec) && (urlparse.host += ":", urlparse.hostname += ":"), delete urlparse.hash, res.fetchSpec = url.format(urlparse));
          break;
        case "http:":
        case "https:":
          res.type = "remote", res.fetchSpec = res.saveSpec;
          break;
        default:
          throw unsupportedURLType(urlparse.protocol, res.rawSpec);
      }
      return res;
    }
    function fromAlias(res, where) {
      var subSpec = npa(res.rawSpec.substr(4), where);
      if (subSpec.type === "alias")
        throw new Error("nested aliases not supported");
      if (!subSpec.registry)
        throw new Error("aliases only work for registry deps");
      return res.subSpec = subSpec, res.registry = !0, res.type = "alias", res.saveSpec = null, res.fetchSpec = null, res;
    }
    function fromRegistry(res) {
      res.registry = !0;
      var spec = res.rawSpec === "" ? "latest" : res.rawSpec;
      res.saveSpec = null, res.fetchSpec = spec, semver || (semver = require_semver());
      var version2 = semver.valid(spec, !0), range = semver.validRange(spec, !0);
      if (version2)
        res.type = "version";
      else if (range)
        res.type = "range";
      else {
        if (encodeURIComponent(spec) !== spec)
          throw invalidTagName(spec);
        res.type = "tag";
      }
      return res;
    }
  }
});

// ../../node_modules/@expo/package-manager/build/node/BasePackageManager.js
var require_BasePackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/BasePackageManager.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _object_without_properties3(source, excluded) {
      if (source == null)
        return {};
      var target = _object_without_properties_loose3(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
      }
      return target;
    }
    function _object_without_properties_loose3(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.BasePackageManager = void 0;
    var spawn_async_1 = __importDefault(require_spawnAsync()), assert_1 = __importDefault(require("assert")), fs_1 = __importDefault(require("fs")), path_1 = __importDefault(require("path")), BasePackageManager = /* @__PURE__ */ function() {
      function BasePackageManager2() {
        var _param = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check15(this, BasePackageManager2);
        var silent = _param.silent, log2 = _param.log, _param_env = _param.env, env2 = _param_env === void 0 ? process.env : _param_env, options = _object_without_properties3(_param, [
          "silent",
          "log",
          "env"
        ]);
        _define_property21(this, "silent", void 0), _define_property21(this, "log", void 0), _define_property21(this, "options", void 0), this.silent = !!silent, this.log = log2 ?? (silent ? void 0 : console.log), this.options = _object_spread_props9(_object_spread13({
          stdio: silent ? void 0 : "inherit"
        }, options), {
          env: _object_spread13({}, this.getDefaultEnvironment(), env2)
        });
      }
      return _create_class13(BasePackageManager2, [
        {
          /** Get the default environment variables used when running the package manager. */
          key: "getDefaultEnvironment",
          value: function() {
            return {
              ADBLOCK: "1",
              DISABLE_OPENCOLLECTIVE: "1"
            };
          }
        },
        {
          /** Ensure the CWD is set to a non-empty string */
          key: "ensureCwdDefined",
          value: function(method) {
            var _this_options_cwd, cwd2 = (_this_options_cwd = this.options.cwd) === null || _this_options_cwd === void 0 ? void 0 : _this_options_cwd.toString(), className = this.constructor.name, methodName = method ? ".".concat(method) : "";
            return (0, assert_1.default)(cwd2, "cwd is required for ".concat(className).concat(methodName)), cwd2;
          }
        },
        {
          key: "runAsync",
          value: function(command) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _this_log, _this;
            return (_this_log = (_this = this).log) === null || _this_log === void 0 || _this_log.call(_this, "> ".concat(this.name, " ").concat(command.join(" "))), (0, spawn_async_1.default)(this.bin, command, _object_spread13({}, this.options, options));
          }
        },
        {
          key: "versionAsync",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var stdout;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.runAsync([
                        "--version"
                      ], {
                        stdio: void 0
                      })
                    ];
                  case 1:
                    return stdout = _state.sent().stdout, [
                      2,
                      stdout.trim()
                    ];
                }
              });
            })();
          }
        },
        {
          key: "getConfigAsync",
          value: function(key) {
            var _this = this;
            return _async_to_generator31(function() {
              var stdout;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return [
                      4,
                      _this.runAsync([
                        "config",
                        "get",
                        key
                      ])
                    ];
                  case 1:
                    return stdout = _state.sent().stdout, [
                      2,
                      stdout.trim()
                    ];
                }
              });
            })();
          }
        },
        {
          key: "removeLockfileAsync",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var cwd2, filePath;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return cwd2 = _this.ensureCwdDefined("removeLockFile"), filePath = path_1.default.join(cwd2, _this.lockFile), [
                      4,
                      fs_1.default.promises.rm(filePath, {
                        force: !0
                      })
                    ];
                  case 1:
                    return _state.sent(), [
                      2
                    ];
                }
              });
            })();
          }
        },
        {
          key: "installAsync",
          value: function() {
            var flags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return this.runAsync([
              "install"
            ].concat(_to_consumable_array16(flags)));
          }
        },
        {
          key: "uninstallAsync",
          value: function() {
            var _this = this;
            return _async_to_generator31(function() {
              var cwd2, modulesPath;
              return _ts_generator31(this, function(_state) {
                switch (_state.label) {
                  case 0:
                    return cwd2 = _this.ensureCwdDefined("uninstallAsync"), modulesPath = path_1.default.join(cwd2, "node_modules"), [
                      4,
                      fs_1.default.promises.rm(modulesPath, {
                        force: !0,
                        recursive: !0
                      })
                    ];
                  case 1:
                    return _state.sent(), [
                      2
                    ];
                }
              });
            })();
          }
        }
      ]), BasePackageManager2;
    }();
    exports2.BasePackageManager = BasePackageManager;
  }
});

// ../../node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS({
  "../../node_modules/yocto-queue/index.js"(exports2, module2) {
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var Node = function Node2(value) {
      "use strict";
      _class_call_check15(this, Node2), this.value = value, this.next = void 0;
    }, Queue = /* @__PURE__ */ function() {
      "use strict";
      function Queue2() {
        _class_call_check15(this, Queue2), this.clear();
      }
      return _create_class13(Queue2, [
        {
          key: "enqueue",
          value: function(value) {
            var node = new Node(value);
            this._head ? (this._tail.next = node, this._tail = node) : (this._head = node, this._tail = node), this._size++;
          }
        },
        {
          key: "dequeue",
          value: function() {
            var current = this._head;
            if (current)
              return this._head = this._head.next, this._size--, current.value;
          }
        },
        {
          key: "clear",
          value: function() {
            this._head = void 0, this._tail = void 0, this._size = 0;
          }
        },
        {
          key: "size",
          get: function() {
            return this._size;
          }
        },
        {
          key: Symbol.iterator,
          value: function() {
            var current;
            return _ts_generator31(this, function(_state) {
              switch (_state.label) {
                case 0:
                  current = this._head, _state.label = 1;
                case 1:
                  return current ? [
                    4,
                    current.value
                  ] : [
                    3,
                    3
                  ];
                case 2:
                  return _state.sent(), current = current.next, [
                    3,
                    1
                  ];
                case 3:
                  return [
                    2
                  ];
              }
            });
          }
        }
      ]), Queue2;
    }();
    module2.exports = Queue;
  }
});

// ../../node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "../../node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var Queue = require_yocto_queue(), pLimit = function(concurrency) {
      if (!((Number.isInteger(concurrency) || concurrency === 1 / 0) && concurrency > 0))
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      var queue = new Queue(), activeCount = 0, next = function() {
        activeCount--, queue.size > 0 && queue.dequeue()();
      }, run2 = function() {
        var _ref = _async_to_generator31(function(fn, resolve7) {
          var _len, args, _key, result, e, _arguments = arguments;
          return _ts_generator31(this, function(_state) {
            switch (_state.label) {
              case 0:
                for (_len = _arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
                  args[_key - 2] = _arguments[_key];
                activeCount++, result = _async_to_generator31(function() {
                  return _ts_generator31(this, function(_state2) {
                    return [
                      2,
                      fn.apply(void 0, _to_consumable_array16(args))
                    ];
                  });
                })(), resolve7(result), _state.label = 1;
              case 1:
                return _state.trys.push([
                  1,
                  3,
                  ,
                  4
                ]), [
                  4,
                  result
                ];
              case 2:
                return _state.sent(), [
                  3,
                  4
                ];
              case 3:
                return e = _state.sent(), [
                  3,
                  4
                ];
              case 4:
                return next(), [
                  2
                ];
            }
          });
        });
        return function(fn, resolve7) {
          return _ref.apply(this, arguments);
        };
      }(), enqueue = function(fn, resolve7) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
          args[_key - 2] = arguments[_key];
        var _run2;
        queue.enqueue((_run2 = run2).bind.apply(_run2, [
          null,
          fn,
          resolve7
        ].concat(_to_consumable_array16(args)))), _async_to_generator31(function() {
          return _ts_generator31(this, function(_state) {
            switch (_state.label) {
              case 0:
                return [
                  4,
                  Promise.resolve()
                ];
              case 1:
                return _state.sent(), activeCount < concurrency && queue.size > 0 && queue.dequeue()(), [
                  2
                ];
            }
          });
        })();
      }, generator = function(fn) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          args[_key - 1] = arguments[_key];
        return new Promise(function(resolve7) {
          enqueue.apply(void 0, [
            fn,
            resolve7
          ].concat(_to_consumable_array16(args)));
        });
      };
      return Object.defineProperties(generator, {
        activeCount: {
          get: function() {
            return activeCount;
          }
        },
        pendingCount: {
          get: function() {
            return queue.size;
          }
        },
        clearQueue: {
          value: function() {
            queue.clear();
          }
        }
      }), generator;
    };
    module2.exports = pLimit;
  }
});

// ../../node_modules/find-up/node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "../../node_modules/find-up/node_modules/p-locate/index.js"(exports2, module2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _construct4(Parent, args, Class) {
      return _is_native_reflect_construct10() ? _construct4 = Reflect.construct : _construct4 = function(Parent2, args2, Class2) {
        var a = [
          null
        ];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
        return Class2 && _set_prototype_of10(instance, Class2.prototype), instance;
      }, _construct4.apply(null, arguments);
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    function _is_native_function4(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _wrap_native_super4(Class) {
      var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return _wrap_native_super4 = function(Class2) {
        if (Class2 === null || !_is_native_function4(Class2))
          return Class2;
        if (typeof Class2 != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache < "u") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct4(Class2, arguments, _get_prototype_of10(this).constructor);
        }
        return Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), _set_prototype_of10(Wrapper, Class2);
      }, _wrap_native_super4(Class);
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var pLimit = require_p_limit(), EndError = /* @__PURE__ */ function(Error1) {
      _inherits10(EndError2, Error1);
      var _super = _create_super10(EndError2);
      function EndError2(value) {
        _class_call_check15(this, EndError2);
        var _this;
        return _this = _super.call(this), _this.value = value, _this;
      }
      return EndError2;
    }(_wrap_native_super4(Error)), testElement = function() {
      var _ref = _async_to_generator31(function(element, tester) {
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                element
              ];
            case 1:
              return [
                2,
                tester.apply(void 0, [
                  _state.sent()
                ])
              ];
          }
        });
      });
      return function(element, tester) {
        return _ref.apply(this, arguments);
      };
    }(), finder = function() {
      var _ref = _async_to_generator31(function(element) {
        var values;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                Promise.all(element)
              ];
            case 1:
              if (values = _state.sent(), values[1] === !0)
                throw new EndError(values[0]);
              return [
                2,
                !1
              ];
          }
        });
      });
      return function(element) {
        return _ref.apply(this, arguments);
      };
    }(), pLocate = function() {
      var _ref = _async_to_generator31(function(iterable, tester, options) {
        var limit, items, checkLimit, error;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              options = _object_spread13({
                concurrency: 1 / 0,
                preserveOrder: !0
              }, options), limit = pLimit(options.concurrency), items = _to_consumable_array16(iterable).map(function(element) {
                return [
                  element,
                  limit(testElement, element, tester)
                ];
              }), checkLimit = pLimit(options.preserveOrder ? 1 : 1 / 0), _state.label = 1;
            case 1:
              return _state.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                Promise.all(items.map(function(element) {
                  return checkLimit(finder, element);
                }))
              ];
            case 2:
              return _state.sent(), [
                3,
                4
              ];
            case 3:
              if (error = _state.sent(), _instanceof13(error, EndError))
                return [
                  2,
                  error.value
                ];
              throw error;
            case 4:
              return [
                2
              ];
          }
        });
      });
      return function(iterable, tester, options) {
        return _ref.apply(this, arguments);
      };
    }();
    module2.exports = pLocate;
  }
});

// ../../node_modules/find-up/node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "../../node_modules/find-up/node_modules/locate-path/index.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var path6 = require("path"), fs7 = require("fs"), promisify2 = require("util").promisify, pLocate = require_p_locate(), fsStat = promisify2(fs7.stat), fsLStat = promisify2(fs7.lstat), typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType(param) {
      var type = param.type;
      if (!(type in typeMappings))
        throw new Error("Invalid type specified: ".concat(type));
    }
    var matchType = function(type, stat3) {
      return type === void 0 || stat3[typeMappings[type]]();
    };
    module2.exports = function() {
      var _ref = _async_to_generator31(function(paths, options) {
        var statFn;
        return _ts_generator31(this, function(_state) {
          return options = _object_spread13({
            cwd: process.cwd(),
            type: "file",
            allowSymlinks: !0
          }, options), checkType(options), statFn = options.allowSymlinks ? fsStat : fsLStat, [
            2,
            pLocate(paths, function() {
              var _ref2 = _async_to_generator31(function(path_) {
                var stat3, e;
                return _ts_generator31(this, function(_state2) {
                  switch (_state2.label) {
                    case 0:
                      return _state2.trys.push([
                        0,
                        2,
                        ,
                        3
                      ]), [
                        4,
                        statFn(path6.resolve(options.cwd, path_))
                      ];
                    case 1:
                      return stat3 = _state2.sent(), [
                        2,
                        matchType(options.type, stat3)
                      ];
                    case 2:
                      return e = _state2.sent(), [
                        2,
                        !1
                      ];
                    case 3:
                      return [
                        2
                      ];
                  }
                });
              });
              return function(path_) {
                return _ref2.apply(this, arguments);
              };
            }(), options)
          ];
        });
      });
      return function(paths, options) {
        return _ref.apply(this, arguments);
      };
    }();
    module2.exports.sync = function(paths, options) {
      options = _object_spread13({
        cwd: process.cwd(),
        allowSymlinks: !0,
        type: "file"
      }, options), checkType(options);
      var statFn = options.allowSymlinks ? fs7.statSync : fs7.lstatSync, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var path_ = _step.value;
          try {
            var stat3 = statFn(path6.resolve(options.cwd, path_));
            if (matchType(options.type, stat3))
              return path_;
          } catch {
          }
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
    };
  }
});

// ../../node_modules/path-exists/index.js
var require_path_exists2 = __commonJS({
  "../../node_modules/path-exists/index.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var fs7 = require("fs"), promisify2 = require("util").promisify, pAccess = promisify2(fs7.access);
    module2.exports = function() {
      var _ref = _async_to_generator31(function(path6) {
        var _;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return _state.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                pAccess(path6)
              ];
            case 1:
              return _state.sent(), [
                2,
                !0
              ];
            case 2:
              return _ = _state.sent(), [
                2,
                !1
              ];
            case 3:
              return [
                2
              ];
          }
        });
      });
      return function(path6) {
        return _ref.apply(this, arguments);
      };
    }();
    module2.exports.sync = function(path6) {
      try {
        return fs7.accessSync(path6), !0;
      } catch {
        return !1;
      }
    };
  }
});

// ../../node_modules/find-up/index.js
var require_find_up = __commonJS({
  "../../node_modules/find-up/index.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var path6 = require("path"), locatePath = require_locate_path(), pathExists3 = require_path_exists2(), stop = Symbol("findUp.stop");
    module2.exports = function() {
      var _ref = _async_to_generator31(function(name) {
        var options, directory, root, paths, runMatcher, foundPath, _arguments = arguments;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              options = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, directory = path6.resolve(options.cwd || ""), root = path6.parse(directory).root, paths = [].concat(name), runMatcher = function() {
                var _ref2 = _async_to_generator31(function(locateOptions) {
                  var foundPath2;
                  return _ts_generator31(this, function(_state2) {
                    switch (_state2.label) {
                      case 0:
                        return typeof name != "function" ? [
                          2,
                          locatePath(paths, locateOptions)
                        ] : [
                          4,
                          name(locateOptions.cwd)
                        ];
                      case 1:
                        return foundPath2 = _state2.sent(), typeof foundPath2 == "string" ? [
                          2,
                          locatePath([
                            foundPath2
                          ], locateOptions)
                        ] : [
                          2,
                          foundPath2
                        ];
                    }
                  });
                });
                return function(locateOptions) {
                  return _ref2.apply(this, arguments);
                };
              }(), _state.label = 1;
            case 1:
              return [
                4,
                runMatcher(_object_spread_props9(_object_spread13({}, options), {
                  cwd: directory
                }))
              ];
            case 2:
              return foundPath = _state.sent(), foundPath === stop ? [
                2
              ] : foundPath ? [
                2,
                path6.resolve(directory, foundPath)
              ] : directory === root ? [
                2
              ] : (directory = path6.dirname(directory), [
                3,
                1
              ]);
            case 3:
              return [
                2
              ];
          }
        });
      });
      return function(name) {
        return _ref.apply(this, arguments);
      };
    }();
    module2.exports.sync = function(name) {
      for (var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, directory = path6.resolve(options.cwd || ""), root = path6.parse(directory).root, paths = [].concat(name), runMatcher = function(locateOptions) {
        if (typeof name != "function")
          return locatePath.sync(paths, locateOptions);
        var foundPath2 = name(locateOptions.cwd);
        return typeof foundPath2 == "string" ? locatePath.sync([
          foundPath2
        ], locateOptions) : foundPath2;
      }; ; ) {
        var foundPath = runMatcher(_object_spread_props9(_object_spread13({}, options), {
          cwd: directory
        }));
        if (foundPath === stop)
          return;
        if (foundPath)
          return path6.resolve(directory, foundPath);
        if (directory === root)
          return;
        directory = path6.dirname(directory);
      }
    };
    module2.exports.exists = pathExists3;
    module2.exports.sync.exists = pathExists3.sync;
    module2.exports.stop = stop;
  }
});

// ../../node_modules/find-yarn-workspace-root/index.js
var require_find_yarn_workspace_root = __commonJS({
  "../../node_modules/find-yarn-workspace-root/index.js"(exports2, module2) {
    "use strict";
    var fs7 = require("fs"), micromatch = require_micromatch(), path6 = require("path");
    module2.exports = findWorkspaceRoot;
    function findWorkspaceRoot(initial) {
      initial || (initial = process.cwd());
      var previous = null, current = path6.normalize(initial);
      do {
        var manifest = readPackageJSON(current), workspaces = extractWorkspaces(manifest);
        if (workspaces) {
          var relativePath = path6.relative(current, initial);
          return relativePath === "" || micromatch([
            relativePath
          ], workspaces).length > 0 ? current : null;
        }
        previous = current, current = path6.dirname(current);
      } while (current !== previous);
      return null;
    }
    function extractWorkspaces(manifest) {
      var workspaces = (manifest || {}).workspaces;
      return workspaces && workspaces.packages || (Array.isArray(workspaces) ? workspaces : null);
    }
    function readPackageJSON(dir) {
      var file = path6.join(dir, "package.json");
      return fs7.existsSync(file) ? JSON.parse(fs7.readFileSync(file, "utf8")) : null;
    }
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/common.js
var require_common3 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/common.js"(exports2, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject > "u" || subject === null;
    }
    function isObject(subject) {
      return typeof subject == "object" && subject !== null;
    }
    function toArray(sequence) {
      return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [
        sequence
      ];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source)
        for (sourceKeys = Object.keys(source), index = 0, length = sourceKeys.length; index < length; index += 1)
          key = sourceKeys[index], target[key] = source[key];
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1)
        result += string;
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/exception.js"(exports2, module2) {
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function(compact) {
      var result = this.name + ": ";
      return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
    };
    module2.exports = YAMLException;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/mark.js"(exports2, module2) {
    "use strict";
    var common = require_common3();
    function Mark(name, buffer, position, line, column) {
      this.name = name, this.buffer = buffer, this.position = position, this.line = line, this.column = column;
    }
    Mark.prototype.getSnippet = function(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
        if (start -= 1, this.position - start > maxLength / 2 - 1) {
          head = " ... ", start += 5;
          break;
        }
      for (tail = "", end = this.position; end < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1; )
        if (end += 1, end - this.position > maxLength / 2 - 1) {
          tail = " ... ", end -= 5;
          break;
        }
      return snippet = this.buffer.slice(start, end), common.repeat(" ", indent) + head + snippet + tail + `
` + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function(compact) {
      var snippet, where = "";
      return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet = this.getSnippet(), snippet && (where += `:
` + snippet)), where;
    };
    module2.exports = Mark;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception(), TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ], YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      return map !== null && Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      }), result;
    }
    function Type(tag, options) {
      if (options = options || {}, Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }), this.tag = tag, this.kind = options.kind || null, this.resolve = options.resolve || function() {
        return !0;
      }, this.construct = options.construct || function(data) {
        return data;
      }, this.instanceOf = options.instanceOf || null, this.predicate = options.predicate || null, this.represent = options.represent || null, this.defaultStyle = options.defaultStyle || null, this.styleAliases = compileStyleAliases(options.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
    module2.exports = Type;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema4 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var common = require_common3(), YAMLException = require_exception(), Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      return schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      }), schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
        }), result.push(currentType);
      }), result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result.fallback[type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1)
        arguments[index].forEach(collectType);
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar")
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function() {
      var schemas, types2;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT, types2 = arguments[0];
          break;
        case 2:
          schemas = arguments[0], types2 = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      if (schemas = common.toArray(schemas), types2 = common.toArray(types2), !schemas.every(function(schema) {
        return _instanceof13(schema, Schema);
      }))
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      if (!types2.every(function(type) {
        return _instanceof13(type, Type);
      }))
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      return new Schema({
        include: schemas,
        explicit: types2
      });
    };
    module2.exports = Schema;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq2(),
        require_map2()
      ]
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return !0;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool3 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return !1;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int3 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), Type = require_type();
    function isHexCode(c) {
      return 48 <= /* 0 */
      c && c <= 57 || /* 9 */
      65 <= /* A */
      c && c <= 70 || /* F */
      97 <= /* a */
      c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= /* 0 */
      c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= /* 0 */
      c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return !1;
      var max = data.length, index = 0, hasDigits = !1, ch;
      if (!max)
        return !1;
      if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
        if (index + 1 === max)
          return !0;
        if (ch = data[++index], ch === "b") {
          for (index++; index < max; index++)
            if (ch = data[index], ch !== "_") {
              if (ch !== "0" && ch !== "1")
                return !1;
              hasDigits = !0;
            }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          for (index++; index < max; index++)
            if (ch = data[index], ch !== "_") {
              if (!isHexCode(data.charCodeAt(index)))
                return !1;
              hasDigits = !0;
            }
          return hasDigits && ch !== "_";
        }
        for (; index < max; index++)
          if (ch = data[index], ch !== "_") {
            if (!isOctCode(data.charCodeAt(index)))
              return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return !1;
      for (; index < max; index++)
        if (ch = data[index], ch !== "_") {
          if (ch === ":")
            break;
          if (!isDecCode(data.charCodeAt(index)))
            return !1;
          hasDigits = !0;
        }
      return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base, digits = [];
      return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign * parseInt(value.slice(2), 2) : value[1] === "x" ? sign * parseInt(value, 16) : sign * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
        digits.unshift(parseInt(v, 10));
      }), value = 0, base = 1, digits.forEach(function(d) {
        value += d * base, base *= 60;
      }), sign * value) : sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [
          2,
          "bin"
        ],
        octal: [
          8,
          "oct"
        ],
        decimal: [
          10,
          "dec"
        ],
        hexadecimal: [
          16,
          "hex"
        ]
      }
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float3 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), Type = require_type(), YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_");
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      return value = data.replace(/_/g, "").toLowerCase(), sign = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
        digits.unshift(parseFloat(v, 10));
      }), value = 0, base = 1, digits.forEach(function(d) {
        value += d * base, base *= 60;
      }), sign * value) : sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object))
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      else if (Number.POSITIVE_INFINITY === object)
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      else if (Number.NEGATIVE_INFINITY === object)
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      else if (common.isNegativeZero(object))
        return "-0.0";
      return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null2(),
        require_bool3(),
        require_int3(),
        require_float3()
      ]
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      include: [
        require_json2()
      ]
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
    }
    function constructYamlTimestamp(data) {
      var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null)
        throw new Error("Date resolve error");
      if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
        return new Date(Date.UTC(year, month, day));
      if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
        for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
          fraction += "0";
        fraction = +fraction;
      }
      return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports2, module2) {
    "use strict";
    var NodeBuffer;
    try {
      _require = require, NodeBuffer = _require("buffer").Buffer;
    } catch {
    }
    var _require, Type = require_type(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
    function resolveYamlBinary(data) {
      if (data === null)
        return !1;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++)
        if (code = map.indexOf(data.charAt(idx)), !(code > 64)) {
          if (code < 0)
            return !1;
          bitlen += 6;
        }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++)
        idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map.indexOf(input.charAt(idx));
      return tailbits = max % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++)
        idx % 3 === 0 && idx && (result += map[bits >> 18 & 63], result += map[bits >> 12 & 63], result += map[bits >> 6 & 63], result += map[bits & 63]), bits = (bits << 8) + object[idx];
      return tail = max % 3, tail === 0 ? (result += map[bits >> 18 & 63], result += map[bits >> 12 & 63], result += map[bits >> 6 & 63], result += map[bits & 63]) : tail === 2 ? (result += map[bits >> 10 & 63], result += map[bits >> 4 & 63], result += map[bits << 2 & 63], result += map[64]) : tail === 1 && (result += map[bits >> 2 & 63], result += map[bits << 4 & 63], result += map[64], result += map[64]), result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString2 = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return !0;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (pair = object[index], pairHasKey = !1, _toString2.call(pair) !== "[object Object]")
          return !1;
        for (pairKey in pair)
          if (_hasOwnProperty.call(pair, pairKey))
            if (!pairHasKey)
              pairHasKey = !0;
            else
              return !1;
        if (!pairHasKey)
          return !1;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return !1;
      }
      return !0;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), _toString2 = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return !0;
      var index, length, pair, keys, result, object = data;
      for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
        if (pair = object[index], _toString2.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1))
          return !1;
        result[index] = [
          keys[0],
          pair[keys[0]]
        ];
      }
      return !0;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
        pair = object[index], keys = Object.keys(pair), result[index] = [
          keys[0],
          pair[keys[0]]
        ];
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return !0;
      var key, object = data;
      for (key in object)
        if (_hasOwnProperty.call(object, key) && object[key] !== null)
          return !1;
      return !0;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      include: [
        require_core2()
      ],
      implicit: [
        require_timestamp2(),
        require_merge()
      ],
      explicit: [
        require_binary2(),
        require_omap2(),
        require_pairs2(),
        require_set2()
      ]
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return !0;
    }
    function constructJavascriptUndefined() {
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object > "u";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null || data.length === 0)
        return !1;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      return !(regexp[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp[regexp.length - modifiers.length - 1] !== "/"));
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      return regexp[0] === "/" && (tail && (modifiers = tail[1]), regexp = regexp.slice(1, regexp.length - modifiers.length - 1)), new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports2, module2) {
    "use strict";
    var esprima;
    try {
      _require = require, esprima = _require("esprima");
    } catch {
      typeof window < "u" && (esprima = window.esprima);
    }
    var _require, Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return !1;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, {
          range: !0
        });
        return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
      } catch {
        return !1;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, {
        range: !0
      }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
        throw new Error("Failed to resolve function");
      return ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/loader.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), YAMLException = require_exception(), Mark = require_mark(), DEFAULT_SAFE_SCHEMA = require_default_safe(), DEFAULT_FULL_SCHEMA = require_default_full(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || /* LF */
      c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || /* Tab */
      c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || /* Tab */
      c === 32 || /* Space */
      c === 10 || /* LF */
      c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || /* , */
      c === 91 || /* [ */
      c === 93 || /* ] */
      c === 123 || /* { */
      c === 125;
    }
    function fromHexCode(c) {
      var lc;
      return 48 <= /* 0 */
      c && c <= 57 ? c - 48 : (lc = c | 32, 97 <= /* a */
      lc && lc <= 102 ? lc - 97 + 10 : -1);
    }
    function escapedHexLen(c) {
      return c === 120 ? 2 : c === 117 ? 4 : c === 85 ? 8 : 0;
    }
    function fromDecimalCode(c) {
      return 48 <= /* 0 */
      c && c <= 57 ? c - 48 : -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? (
        /* 0 */
        "\0"
      ) : c === 97 ? (
        /* a */
        "\x07"
      ) : c === 98 ? (
        /* b */
        "\b"
      ) : c === 116 || c === 9 ? (
        /* t */
        "	"
      ) : c === 110 ? (
        /* n */
        `
`
      ) : c === 118 ? (
        /* v */
        "\v"
      ) : c === 102 ? (
        /* f */
        "\f"
      ) : c === 114 ? (
        /* r */
        "\r"
      ) : c === 101 ? (
        /* e */
        "\x1B"
      ) : c === 32 ? (
        /* Space */
        " "
      ) : c === 34 ? (
        /* " */
        '"'
      ) : c === 47 ? (
        /* / */
        "/"
      ) : c === 92 ? (
        /* \ */
        "\\"
      ) : c === 78 ? (
        /* N */
        "\x85"
      ) : c === 95 ? (
        /* _ */
        "\xA0"
      ) : c === 76 ? (
        /* L */
        "\u2028"
      ) : c === 80 ? (
        /* P */
        "\u2029"
      ) : "";
    }
    function charFromCodepoint(c) {
      return c <= 65535 ? String.fromCharCode(c) : String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++)
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
    var i;
    function State(input, options) {
      this.input = input, this.filename = options.filename || null, this.schema = options.schema || DEFAULT_FULL_SCHEMA, this.onWarning = options.onWarning || null, this.legacy = options.legacy || !1, this.json = options.json || !1, this.listener = options.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      state.onWarning && state.onWarning.call(null, generateError(state, message));
    }
    var directiveHandlers = {
      YAML: function(state, name, args) {
        var match2, major, minor;
        state.version !== null && throwError(state, "duplication of %YAML directive"), args.length !== 1 && throwError(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError(state, "ill-formed argument of the YAML directive"), major = parseInt(match2[1], 10), minor = parseInt(match2[2], 10), major !== 1 && throwError(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning(state, "unsupported YAML version of the document");
      },
      TAG: function(state, name, args) {
        var handle, prefix;
        args.length !== 2 && throwError(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError(state, "ill-formed tag prefix (second argument) of the TAG directive"), state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        if (_result = state.input.slice(start, end), checkJson)
          for (_position = 0, _length = _result.length; _position < _length; _position += 1)
            _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError(state, "expected valid JSON character");
        else
          PATTERN_NON_PRINTABLE.test(_result) && throwError(state, "the stream contains non-printable characters");
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      for (common.isObject(source) || throwError(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
        key = sourceKeys[index], _hasOwnProperty.call(destination, key) || (destination[key] = source[key], overridableKeys[key] = !0);
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode))
        for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
          Array.isArray(keyNode[index]) && throwError(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
      if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
        if (Array.isArray(valueNode))
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
            mergeMappings(state, _result, valueNode[index], overridableKeys);
        else
          mergeMappings(state, _result, valueNode, overridableKeys);
      else
        !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.position = startPos || state.position, throwError(state, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError(state, "a line break is expected"), state.line += 1, state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (allowComments && ch === 35)
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 10 && /* LF */
          ch !== 13 && /* CR */
          ch !== 0);
        if (is_EOL(ch))
          for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
            state.lineIndent++, ch = state.input.charCodeAt(++state.position);
        else
          break;
      }
      return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      return ch = state.input.charCodeAt(_position), !!((ch === 45 || /* - */
      ch === 46) && /* . */
      ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
    }
    function writeFoldedLines(state, count) {
      count === 1 ? state.result += " " : count > 1 && (state.result += common.repeat(`
`, count - 1));
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || /* # */
      ch === 38 || /* & */
      ch === 42 || /* * */
      ch === 33 || /* ! */
      ch === 124 || /* | */
      ch === 62 || /* > */
      ch === 39 || /* ' */
      ch === 34 || /* " */
      ch === 37 || /* % */
      ch === 64 || /* @ */
      ch === 96 || (ch === 63 || /* ? */
      ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
        return !1;
      for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
        if (ch === 58) {
          if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
            break;
        } else if (ch === 35) {
          if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
            break;
        } else {
          if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
            break;
          if (is_EOL(ch))
            if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
              hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
              continue;
            } else {
              state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
              break;
            }
        }
        hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
      }
      return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      if (ch = state.input.charCodeAt(state.position), ch !== 39)
        return !1;
      for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
        if (ch === 39)
          if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
            captureStart = state.position, state.position++, captureEnd = state.position;
          else
            return !0;
        else
          is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 34)
        return !1;
      for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
        if (ch === 34)
          return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
        if (ch === 92) {
          if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
            skipSeparationSpace(state, !1, nodeIndent);
          else if (ch < 256 && simpleEscapeCheck[ch])
            state.result += simpleEscapeMap[ch], state.position++;
          else if ((tmp = escapedHexLen(ch)) > 0) {
            for (hexLength = tmp, hexResult = 0; hexLength > 0; hexLength--)
              ch = state.input.charCodeAt(++state.position), (tmp = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp : throwError(state, "expected hexadecimal character");
            state.result += charFromCodepoint(hexResult), state.position++;
          } else
            throwError(state, "unknown escape sequence");
          captureStart = captureEnd = state.position;
        } else
          is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = !0, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      if (ch = state.input.charCodeAt(state.position), ch === 91)
        terminator = 93, isMapping = !1, _result = [];
      else if (ch === 123)
        terminator = 125, isMapping = !0, _result = {};
      else
        return !1;
      for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
        if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
          return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
        readNext || throwError(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp, ch;
      if (ch = state.input.charCodeAt(state.position), ch === 124)
        folding = !1;
      else if (ch === 62)
        folding = !0;
      else
        return !1;
      for (state.kind = "scalar", state.result = ""; ch !== 0; )
        if (ch = state.input.charCodeAt(++state.position), ch === 43 || /* + */
        ch === 45)
          CHOMPING_CLIP === chomping ? chomping = ch === 43 ? (
            /* + */
            CHOMPING_KEEP
          ) : CHOMPING_STRIP : throwError(state, "repeat of a chomping mode identifier");
        else if ((tmp = fromDecimalCode(ch)) >= 0)
          tmp === 0 ? throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp - 1, detectedIndent = !0);
        else
          break;
      if (is_WHITE_SPACE(ch)) {
        do
          ch = state.input.charCodeAt(++state.position);
        while (is_WHITE_SPACE(ch));
        if (ch === 35)
          do
            ch = state.input.charCodeAt(++state.position);
          while (!is_EOL(ch) && ch !== 0);
      }
      for (; ch !== 0; ) {
        for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
        if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          chomping === CHOMPING_KEEP ? state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
          break;
        }
        for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common.repeat(`
`, emptyLines) : state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
          ch = state.input.charCodeAt(++state.position);
        captureSegment(state, captureStart, state.position, !1);
      }
      return !0;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
      for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following))); ) {
        if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
          _result.push(null), ch = state.input.charCodeAt(state.position);
          continue;
        }
        if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
          throwError(state, "bad indentation of a sequence entry");
        else if (state.lineIndent < nodeIndent)
          break;
      }
      return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
      for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
        if (following = state.input.charCodeAt(state.position + 1), _line = state.line, _pos = state.position, (ch === 63 || /* ? */
        ch === 58) && /* : */
        is_WS_OR_EOL(following))
          ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
        else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
          if (state.line === _line) {
            for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
              ch = state.input.charCodeAt(++state.position);
            if (ch === 58)
              ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
            else if (detected)
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            else
              return state.tag = _tag, state.anchor = _anchor, !0;
          } else if (detected)
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        else
          break;
        if ((state.line === _line || state.lineIndent > nodeIndent) && (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), state.lineIndent > nodeIndent && ch !== 0)
          throwError(state, "bad indentation of a mapping entry");
        else if (state.lineIndent < nodeIndent)
          break;
      }
      return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 33)
        return !1;
      if (state.tag !== null && throwError(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && ch !== 62);
        state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError(state, "unexpected end of the stream within a verbatim tag");
      } else {
        for (; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch === 33 && (isNamed ? throwError(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
        tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError(state, "tag suffix cannot contain flow indicator characters");
      }
      return tagName && !PATTERN_TAG_URI.test(tagName) && throwError(state, "tag name cannot contain such characters: " + tagName), isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 38)
        return !1;
      for (state.anchor !== null && throwError(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
        ch = state.input.charCodeAt(++state.position);
      return state.position === _position && throwError(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
    }
    function readAlias(state) {
      var _position, alias, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 42)
        return !1;
      for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
        ch = state.input.charCodeAt(++state.position);
      return state.position === _position && throwError(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty.call(state.anchorMap, alias) || throwError(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
        for (; readTagProperty(state) || readAnchorProperty(state); )
          skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
      if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag !== null && state.tag !== "!")
        if (state.tag === "?") {
          for (state.result !== null && state.kind !== "scalar" && throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
            if (type = state.implicitTypes[typeIndex], type.resolve(state.result)) {
              state.result = type.construct(state.result), state.tag = type.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
              break;
            }
        } else
          _hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag) ? (type = state.typeMap[state.kind || "fallback"][state.tag], state.result !== null && type.kind !== state.kind && throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"'), type.resolve(state.result) ? (state.result = type.construct(state.result), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag")) : throwError(state, "unknown tag !<" + state.tag + ">");
      return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
      for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = {}, state.anchorMap = {}; (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
        for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError(state, "directive name must not be less than one character in length"); ch !== 0; ) {
          for (; is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 35) {
            do
              ch = state.input.charCodeAt(++state.position);
            while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
            ch = state.input.charCodeAt(++state.position);
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
      if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && /* - */
      state.input.charCodeAt(state.position + 1) === 45 && /* - */
      state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
        state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
        return;
      }
      if (state.position < state.length - 1)
        throwError(state, "end of the stream or a document separator is expected");
      else
        return;
    }
    function loadDocuments(input, options) {
      input = String(input), options = options || {}, input.length !== 0 && (input.charCodeAt(input.length - 1) !== 10 && /* LF */
      input.charCodeAt(input.length - 1) !== 13 && (input += `
`), input.charCodeAt(0) === 65279 && (input = input.slice(1)));
      var state = new State(input, options), nullpos = input.indexOf("\0");
      for (nullpos !== -1 && (state.position = nullpos, throwError(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
        state.lineIndent += 1, state.position += 1;
      for (; state.position < state.length - 1; )
        readDocument(state);
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      iterator !== null && typeof iterator == "object" && typeof options > "u" && (options = iterator, iterator = null);
      var documents = loadDocuments(input, options);
      if (typeof iterator != "function")
        return documents;
      for (var index = 0, length = documents.length; index < length; index += 1)
        iterator(documents[index]);
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length !== 0) {
        if (documents.length === 1)
          return documents[0];
        throw new YAMLException("expected a single document in the stream, but found more");
      }
    }
    function safeLoadAll(input, iterator, options) {
      return typeof iterator == "object" && iterator !== null && typeof options > "u" && (options = iterator, iterator = null), loadAll(input, iterator, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
      }, options));
    }
    function safeLoad(input, options) {
      return load(input, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
      }, options));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports2, module2) {
    "use strict";
    function _instanceof13(left, right) {
      return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
    }
    var common = require_common3(), YAMLException = require_exception(), DEFAULT_FULL_SCHEMA = require_default_full(), DEFAULT_SAFE_SCHEMA = require_default_safe(), _toString2 = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA = 44, CHAR_MINUS = 45, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      for (result = {}, keys = Object.keys(map), index = 0, length = keys.length; index < length; index += 1)
        tag = keys[index], style = String(map[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type = schema.compiledTypeMap.fallback[tag], type && _hasOwnProperty.call(type.styleAliases, style) && (style = type.styleAliases[style]), result[tag] = style;
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      if (string = character.toString(16).toUpperCase(), character <= 255)
        handle = "x", length = 2;
      else if (character <= 65535)
        handle = "u", length = 4;
      else if (character <= 4294967295)
        handle = "U", length = 8;
      else
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options) {
      this.schema = options.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options.indent || 2), this.noArrayIndent = options.noArrayIndent || !1, this.skipInvalid = options.skipInvalid || !1, this.flowLevel = common.isNothing(options.flowLevel) ? -1 : options.flowLevel, this.styleMap = compileStyleMap(this.schema, options.styles || null), this.sortKeys = options.sortKeys || !1, this.lineWidth = options.lineWidth || 80, this.noRefs = options.noRefs || !1, this.noCompatMode = options.noCompatMode || !1, this.condenseFlow = options.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      for (var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length; position < length; )
        next = string.indexOf(`
`, position), next === -1 ? (line = string.slice(position), position = length) : (line = string.slice(position, next + 1), position = next + 1), line.length && line !== `
` && (result += ind), result += line;
      return result;
    }
    function generateNextLine(state, level) {
      return `
` + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
        if (type = state.implicitTypes[index], type.resolve(str))
          return !0;
      return !1;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || /* BOM */
      65536 <= c && c <= 1114111;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c) && // byte-order-mark
      c !== 65279 && // b-char
      c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 65279 && // - c-flow-indicator
      c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && // - ":" - "#"
      // /* An ns-char preceding */ "#"
      c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && // - s-white
      // - (c-indicator ::=
      // - | ? | : | , | [ | ] | { | }
      c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && // | # | & | * | ! | | | = | > | ' | "
      c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && // | % | @ | `)
      c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i, char, prev_char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly)
        for (i = 0; i < string.length; i++) {
          if (char = string.charCodeAt(i), !isPrintable(char))
            return STYLE_DOUBLE;
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
        }
      else {
        for (i = 0; i < string.length; i++) {
          if (char = string.charCodeAt(i), char === CHAR_LINE_FEED)
            hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
          else if (!isPrintable(char))
            return STYLE_DOUBLE;
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
      }
      return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0)
          return "''";
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
          return "'" + string + "'";
        var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || // No block styles in flow mode.
        state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + `
`;
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
        var nextLF = string.indexOf(`
`);
        return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
      }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
        var prefix = match2[1], line = match2[2];
        moreIndented = line[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? `
` : "") + foldLine(line, width), prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line); )
        next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line.slice(start, end), start = end + 1), curr = next;
      return result += `
`, line.length - start > width && curr > start ? result += line.slice(start, curr) + `
` + line.slice(curr + 1) : result += line.slice(start), result.slice(1);
    }
    function escapeString(string) {
      for (var result = "", char, nextChar, escapeSeq, i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i + 1), nextChar >= 56320 && nextChar <= 57343)) {
          result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i++;
          continue;
        }
        escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1)
        writeNode(state, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
      state.tag = _tag, state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1)
        writeNode(state, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
      state.tag = _tag, state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1)
        pairBuffer = "", index !== 0 && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
      state.tag = _tag, state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === !0)
        objectKeyList.sort();
      else if (typeof state.sortKeys == "function")
        objectKeyList.sort(state.sortKeys);
      else if (state.sortKeys)
        throw new YAMLException("sortKeys must be a boolean or a function");
      for (index = 0, length = objectKeyList.length; index < length; index += 1)
        pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
      state.tag = _tag, state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
        if (type = typeList[index], (type.instanceOf || type.predicate) && (!type.instanceOf || typeof object == "object" && _instanceof13(object, type.instanceOf)) && (!type.predicate || type.predicate(object))) {
          if (state.tag = explicit ? type.tag : "?", type.represent) {
            if (style = state.styleMap[type.tag] || type.defaultStyle, _toString2.call(type.represent) === "[object Function]")
              _result = type.represent(object, style);
            else if (_hasOwnProperty.call(type.represent, style))
              _result = type.represent[style](object, style);
            else
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            state.dump = _result;
          }
          return !0;
        }
      return !1;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
      var type = _toString2.call(state.dump);
      block && (block = state.flowLevel < 0 || state.flowLevel > level);
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
        state.dump = "*ref_" + duplicateIndex;
      else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type === "[object Object]")
          block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
        else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          block && state.dump.length !== 0 ? (writeBlockSequence(state, arrayLevel, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, arrayLevel, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
        } else if (type === "[object String]")
          state.tag !== "?" && writeScalar(state, state.dump, level, iskey);
        else {
          if (state.skipInvalid)
            return !1;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        state.tag !== null && state.tag !== "?" && (state.dump = "!<" + state.tag + "> " + state.dump);
      }
      return !0;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object == "object")
        if (index = objects.indexOf(object), index !== -1)
          duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
        else if (objects.push(object), Array.isArray(object))
          for (index = 0, length = object.length; index < length; index += 1)
            inspectNode(object[index], objects, duplicatesIndexes);
        else
          for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      return state.noRefs || getDuplicateReferences(input, state), writeNode(state, 0, input, !0, !0) ? state.dump + `
` : "";
    }
    function safeDump(input, options) {
      return dump(input, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
      }, options));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/lib/js-yaml.js"(exports2, module2) {
    "use strict";
    var loader = require_loader(), dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema4();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json2();
    module2.exports.CORE_SCHEMA = require_core2();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// ../../node_modules/@expo/package-manager/node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "../../node_modules/@expo/package-manager/node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    var yaml = require_js_yaml();
    module2.exports = yaml;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/nodeWorkspaces.js
var require_nodeWorkspaces = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/nodeWorkspaces.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.findPnpmWorkspaceRoot = exports2.findYarnOrNpmWorkspaceRoot = exports2.BUN_LOCK_FILE = exports2.PNPM_WORKSPACE_FILE = exports2.PNPM_LOCK_FILE = exports2.YARN_LOCK_FILE = exports2.NPM_LOCK_FILE = void 0;
    var find_up_1 = require_find_up(), find_yarn_workspace_root_1 = __importDefault(require_find_yarn_workspace_root()), fs_1 = __importDefault(require("fs")), js_yaml_1 = __importDefault(require_js_yaml2()), micromatch_1 = __importDefault(require_micromatch()), path_1 = __importDefault(require("path"));
    exports2.NPM_LOCK_FILE = "package-lock.json";
    exports2.YARN_LOCK_FILE = "yarn.lock";
    exports2.PNPM_LOCK_FILE = "pnpm-lock.yaml";
    exports2.PNPM_WORKSPACE_FILE = "pnpm-workspace.yaml";
    exports2.BUN_LOCK_FILE = "bun.lockb";
    function findYarnOrNpmWorkspaceRoot(projectRoot) {
      try {
        return (0, find_yarn_workspace_root_1.default)(projectRoot);
      } catch (error) {
        if (error.message.includes("Unexpected end of JSON input"))
          return null;
        throw error;
      }
    }
    exports2.findYarnOrNpmWorkspaceRoot = findYarnOrNpmWorkspaceRoot;
    function findPnpmWorkspaceRoot(projectRoot) {
      var workspaceEnvName = "NPM_CONFIG_WORKSPACE_DIR", _process_env_workspaceEnvName, workspaceEnvValue = (_process_env_workspaceEnvName = process.env[workspaceEnvName]) !== null && _process_env_workspaceEnvName !== void 0 ? _process_env_workspaceEnvName : process.env[workspaceEnvName.toLowerCase()], workspaceFile = workspaceEnvValue ? path_1.default.join(workspaceEnvValue, exports2.PNPM_WORKSPACE_FILE) : (0, find_up_1.sync)(exports2.PNPM_WORKSPACE_FILE, {
        cwd: projectRoot
      });
      if (!workspaceFile || !fs_1.default.existsSync(workspaceFile))
        return null;
      try {
        var _js_yaml_1_default_load = js_yaml_1.default.load(fs_1.default.readFileSync(workspaceFile, "utf8")), workspaces = _js_yaml_1_default_load.packages, workspaceRoot = path_1.default.dirname(workspaceFile), relativePath = path_1.default.relative(workspaceRoot, projectRoot);
        if (relativePath === "" || (0, micromatch_1.default)([
          relativePath
        ], workspaces).length > 0)
          return workspaceRoot;
      } catch {
        return null;
      }
      return null;
    }
    exports2.findPnpmWorkspaceRoot = findPnpmWorkspaceRoot;
  }
});

// ../../node_modules/@expo/package-manager/build/node/NpmPackageManager.js
var require_NpmPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/NpmPackageManager.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.NpmPackageManager = void 0;
    var json_file_1 = __importDefault(require_JsonFile()), npm_package_arg_1 = __importDefault(require_npa()), path_1 = __importDefault(require("path")), BasePackageManager_1 = require_BasePackageManager(), nodeWorkspaces_1 = require_nodeWorkspaces(), spawn_1 = require_spawn(), NpmPackageManager2 = /* @__PURE__ */ function(_BasePackageManager_1_BasePackageManager) {
      _inherits10(NpmPackageManager3, _BasePackageManager_1_BasePackageManager);
      var _super = _create_super10(NpmPackageManager3);
      function NpmPackageManager3() {
        _class_call_check15(this, NpmPackageManager3);
        var _this;
        return _this = _super.apply(this, arguments), _define_property21(_assert_this_initialized10(_this), "name", "npm"), _define_property21(_assert_this_initialized10(_this), "bin", "npm"), _define_property21(_assert_this_initialized10(_this), "lockFile", nodeWorkspaces_1.NPM_LOCK_FILE), _this;
      }
      return _create_class13(NpmPackageManager3, [
        {
          key: "workspaceRoot",
          value: function() {
            var root = (0, nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
            return root ? new NpmPackageManager3(_object_spread_props9(_object_spread13({}, this.options), {
              silent: this.silent,
              log: this.log,
              cwd: root
            })) : null;
          }
        },
        {
          key: "addAsync",
          value: function() {
            var _this = this, namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            if (!namesOrFlags.length)
              return this.installAsync();
            var _this_parsePackageSpecs = this.parsePackageSpecs(namesOrFlags), flags = _this_parsePackageSpecs.flags, versioned = _this_parsePackageSpecs.versioned, unversioned = _this_parsePackageSpecs.unversioned;
            return (0, spawn_1.createPendingSpawnAsync)(function() {
              return _this.updatePackageFileAsync(versioned, "dependencies");
            }, function() {
              return unversioned.length ? _this.runAsync([
                "install",
                "--save"
              ].concat(_to_consumable_array16(flags), _to_consumable_array16(unversioned.map(function(spec) {
                return spec.raw;
              })))) : _this.runAsync([
                "install"
              ].concat(_to_consumable_array16(flags)));
            });
          }
        },
        {
          key: "addDevAsync",
          value: function() {
            var _this = this, namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            if (!namesOrFlags.length)
              return this.installAsync();
            var _this_parsePackageSpecs = this.parsePackageSpecs(namesOrFlags), flags = _this_parsePackageSpecs.flags, versioned = _this_parsePackageSpecs.versioned, unversioned = _this_parsePackageSpecs.unversioned;
            return (0, spawn_1.createPendingSpawnAsync)(function() {
              return _this.updatePackageFileAsync(versioned, "devDependencies");
            }, function() {
              return unversioned.length ? _this.runAsync([
                "install",
                "--save-dev"
              ].concat(_to_consumable_array16(flags), _to_consumable_array16(unversioned.map(function(spec) {
                return spec.raw;
              })))) : _this.runAsync([
                "install"
              ].concat(_to_consumable_array16(flags)));
            });
          }
        },
        {
          key: "addGlobalAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? this.runAsync([
              "install",
              "--global"
            ].concat(_to_consumable_array16(namesOrFlags))) : this.installAsync();
          }
        },
        {
          key: "removeAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "uninstall"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeDevAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "uninstall",
              "--save-dev"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeGlobalAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "uninstall",
              "--global"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          /**
          * Parse all package specifications from the names or flag list.
          * The result from this method can be used for `.updatePackageFileAsync`.
          */
          key: "parsePackageSpecs",
          value: function(namesOrFlags) {
            var result = {
              flags: [],
              versioned: [],
              unversioned: []
            };
            return namesOrFlags.map(function(name) {
              return name.trim().startsWith("-") ? (result.flags.push(name), null) : (0, npm_package_arg_1.default)(name);
            }).forEach(function(spec) {
              spec && spec.rawSpec && spec.type !== "tag" ? result.versioned.push(spec) : spec && result.unversioned.push(spec);
            }), result;
          }
        },
        {
          key: "updatePackageFileAsync",
          value: (
            /**
            * Older npm versions have issues with mismatched nested dependencies when adding exact versions.
            * This propagates as issues like mismatched `@expo/config-pugins` versions.
            * As a workaround, we update the `package.json` directly and run `npm install`.
            */
            function(packageSpecs, packageType) {
              var _this = this;
              return _async_to_generator31(function() {
                var _this_options_cwd, pkgPath, pkg;
                return _ts_generator31(this, function(_state) {
                  switch (_state.label) {
                    case 0:
                      return packageSpecs.length ? (pkgPath = path_1.default.join(((_this_options_cwd = _this.options.cwd) === null || _this_options_cwd === void 0 ? void 0 : _this_options_cwd.toString()) || ".", "package.json"), [
                        4,
                        json_file_1.default.readAsync(pkgPath)
                      ]) : [
                        2
                      ];
                    case 1:
                      return pkg = _state.sent(), packageSpecs.forEach(function(spec) {
                        pkg[packageType] = pkg[packageType] || {}, pkg[packageType][spec.name] = spec.rawSpec;
                      }), [
                        4,
                        json_file_1.default.writeAsync(pkgPath, pkg, {
                          json5: !1
                        })
                      ];
                    case 2:
                      return _state.sent(), [
                        2
                      ];
                  }
                });
              })();
            }
          )
        }
      ]), NpmPackageManager3;
    }(BasePackageManager_1.BasePackageManager);
    exports2.NpmPackageManager = NpmPackageManager2;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/env.js
var require_env = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/env.js"(exports2) {
    "use strict";
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    var Env = /* @__PURE__ */ function() {
      function Env2() {
        _class_call_check15(this, Env2);
      }
      return _create_class13(Env2, [
        {
          key: "CI",
          get: (
            /** Determine if the package manager is running in a CI environment. */
            function() {
              var CI = process.env.CI;
              return (CI == null ? void 0 : CI.toLowerCase()) === "true" || CI === "1";
            }
          )
        }
      ]), Env2;
    }();
    exports2.default = new Env();
  }
});

// ../../node_modules/@expo/package-manager/build/node/PnpmPackageManager.js
var require_PnpmPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/PnpmPackageManager.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.PnpmPackageManager = void 0;
    var BasePackageManager_1 = require_BasePackageManager(), env_1 = __importDefault(require_env()), nodeWorkspaces_1 = require_nodeWorkspaces(), PnpmPackageManager = /* @__PURE__ */ function(_BasePackageManager_1_BasePackageManager) {
      _inherits10(PnpmPackageManager2, _BasePackageManager_1_BasePackageManager);
      var _super = _create_super10(PnpmPackageManager2);
      function PnpmPackageManager2() {
        _class_call_check15(this, PnpmPackageManager2);
        var _this;
        return _this = _super.apply(this, arguments), _define_property21(_assert_this_initialized10(_this), "name", "pnpm"), _define_property21(_assert_this_initialized10(_this), "bin", "pnpm"), _define_property21(_assert_this_initialized10(_this), "lockFile", nodeWorkspaces_1.PNPM_LOCK_FILE), _this;
      }
      return _create_class13(PnpmPackageManager2, [
        {
          key: "workspaceRoot",
          value: function() {
            var root = (0, nodeWorkspaces_1.findPnpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
            return root ? new PnpmPackageManager2(_object_spread_props9(_object_spread13({}, this.options), {
              silent: this.silent,
              log: this.log,
              cwd: root
            })) : null;
          }
        },
        {
          key: "installAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return env_1.default.CI && !namesOrFlags.join(" ").includes("frozen-lockfile") && namesOrFlags.unshift("--no-frozen-lockfile"), this.runAsync([
              "install"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "addAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? this.runAsync([
              "add"
            ].concat(_to_consumable_array16(namesOrFlags))) : this.installAsync();
          }
        },
        {
          key: "addDevAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? this.runAsync([
              "add",
              "--save-dev"
            ].concat(_to_consumable_array16(namesOrFlags))) : this.installAsync();
          }
        },
        {
          key: "addGlobalAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? this.runAsync([
              "add",
              "--global"
            ].concat(_to_consumable_array16(namesOrFlags))) : this.installAsync();
          }
        },
        {
          key: "removeAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeDevAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove",
              "--save-dev"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeGlobalAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove",
              "--global"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        }
      ]), PnpmPackageManager2;
    }(BasePackageManager_1.BasePackageManager);
    exports2.PnpmPackageManager = PnpmPackageManager;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/yarn.js
var require_yarn = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/yarn.js"(exports2) {
    "use strict";
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.getNpmProxy = exports2.isYarnOfflineAsync = void 0;
    var child_process_1 = require("child_process"), dns_1 = __importDefault(require("dns")), url_1 = __importDefault(require("url"));
    function isYarnOfflineAsync() {
      return _isYarnOfflineAsync.apply(this, arguments);
    }
    function _isYarnOfflineAsync() {
      return _isYarnOfflineAsync = /** Determine if you should use yarn offline or not */
      _async_to_generator31(function() {
        var proxy, hostname;
        return _ts_generator31(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                isUrlAvailableAsync("registry.yarnpkg.com")
              ];
            case 1:
              return _state.sent() ? [
                2,
                !1
              ] : (proxy = getNpmProxy(), proxy ? (hostname = url_1.default.parse(proxy).hostname, hostname ? [
                4,
                isUrlAvailableAsync(hostname)
              ] : [
                2,
                !0
              ]) : [
                2,
                !0
              ]);
            case 2:
              return [
                2,
                !_state.sent()
              ];
          }
        });
      }), _isYarnOfflineAsync.apply(this, arguments);
    }
    exports2.isYarnOfflineAsync = isYarnOfflineAsync;
    function getNpmProxy() {
      if (process.env.https_proxy) {
        var _process_env_https_proxy;
        return (_process_env_https_proxy = process.env.https_proxy) !== null && _process_env_https_proxy !== void 0 ? _process_env_https_proxy : null;
      }
      try {
        var httpsProxy = (0, child_process_1.execSync)("npm config get https-proxy").toString().trim();
        return httpsProxy !== "null" ? httpsProxy : null;
      } catch {
        return null;
      }
    }
    exports2.getNpmProxy = getNpmProxy;
    function isUrlAvailableAsync(url) {
      return new Promise(function(resolve7) {
        dns_1.default.lookup(url, function(err) {
          resolve7(!err);
        });
      });
    }
  }
});

// ../../node_modules/@expo/package-manager/build/node/YarnPackageManager.js
var require_YarnPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/YarnPackageManager.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, key, arg) {
      try {
        var info2 = gen[key](arg), value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
    }
    function _async_to_generator31(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next2(value) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep31(gen, resolve7, reject, _next2, _throw, "throw", err);
          }
          _next2(void 0);
        });
      };
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    function _ts_generator31(thisArg, body) {
      var f, y, t, g, _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([
            n,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [
              op[0] & 2,
              t.value
            ]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, {
                  value: op[1],
                  done: !1
                };
              case 5:
                _.label++, y = op[1], op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: !0
        };
      }
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.YarnPackageManager = void 0;
    var BasePackageManager_1 = require_BasePackageManager(), nodeWorkspaces_1 = require_nodeWorkspaces(), spawn_1 = require_spawn(), yarn_1 = require_yarn(), YarnPackageManager2 = /* @__PURE__ */ function(_BasePackageManager_1_BasePackageManager) {
      _inherits10(YarnPackageManager3, _BasePackageManager_1_BasePackageManager);
      var _super = _create_super10(YarnPackageManager3);
      function YarnPackageManager3() {
        _class_call_check15(this, YarnPackageManager3);
        var _this;
        return _this = _super.apply(this, arguments), _define_property21(_assert_this_initialized10(_this), "name", "yarn"), _define_property21(_assert_this_initialized10(_this), "bin", "yarnpkg"), _define_property21(_assert_this_initialized10(_this), "lockFile", nodeWorkspaces_1.YARN_LOCK_FILE), _this;
      }
      return _create_class13(YarnPackageManager3, [
        {
          key: "withOfflineFlagAsync",
          value: (
            /** Check if Yarn is running in offline mode, and add the `--offline` flag */
            function(namesOrFlags) {
              return _async_to_generator31(function() {
                return _ts_generator31(this, function(_state) {
                  switch (_state.label) {
                    case 0:
                      return [
                        4,
                        (0, yarn_1.isYarnOfflineAsync)()
                      ];
                    case 1:
                      return [
                        2,
                        _state.sent() ? _to_consumable_array16(namesOrFlags).concat([
                          "--offline"
                        ]) : namesOrFlags
                      ];
                  }
                });
              })();
            }
          )
        },
        {
          key: "workspaceRoot",
          value: function() {
            var root = (0, nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
            return root ? new YarnPackageManager3(_object_spread_props9(_object_spread13({}, this.options), {
              silent: this.silent,
              log: this.log,
              cwd: root
            })) : null;
          }
        },
        {
          key: "installAsync",
          value: function() {
            var _this = this, flags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return (0, spawn_1.createPendingSpawnAsync)(function() {
              return _this.withOfflineFlagAsync([
                "install"
              ]);
            }, function(args) {
              return _this.runAsync(_to_consumable_array16(args).concat(_to_consumable_array16(flags)));
            });
          }
        },
        {
          key: "addAsync",
          value: function() {
            var _this = this, namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? (0, spawn_1.createPendingSpawnAsync)(function() {
              return _this.withOfflineFlagAsync([
                "add"
              ].concat(_to_consumable_array16(namesOrFlags)));
            }, function(args) {
              return _this.runAsync(args);
            }) : this.installAsync();
          }
        },
        {
          key: "addDevAsync",
          value: function() {
            var _this = this, namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? (0, spawn_1.createPendingSpawnAsync)(function() {
              return _this.withOfflineFlagAsync([
                "add",
                "--dev"
              ].concat(_to_consumable_array16(namesOrFlags)));
            }, function(args) {
              return _this.runAsync(args);
            }) : this.installAsync();
          }
        },
        {
          key: "addGlobalAsync",
          value: function() {
            var _this = this, namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? (0, spawn_1.createPendingSpawnAsync)(function() {
              return _this.withOfflineFlagAsync([
                "global",
                "add"
              ].concat(_to_consumable_array16(namesOrFlags)));
            }, function(args) {
              return _this.runAsync(args);
            }) : this.installAsync();
          }
        },
        {
          key: "removeAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeDevAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeGlobalAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "global",
              "remove"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        }
      ]), YarnPackageManager3;
    }(BasePackageManager_1.BasePackageManager);
    exports2.YarnPackageManager = YarnPackageManager2;
  }
});

// ../../node_modules/@expo/package-manager/build/node/BunPackageManager.js
var require_BunPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/BunPackageManager.js"(exports2) {
    "use strict";
    function _array_like_to_array22(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _array_without_holes16(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array22(arr);
    }
    function _assert_this_initialized10(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _class_call_check15(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties13(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class13(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties13(Constructor.prototype, protoProps), staticProps && _defineProperties13(Constructor, staticProps), Constructor;
    }
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _get_prototype_of10(o) {
      return _get_prototype_of10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _get_prototype_of10(o);
    }
    function _inherits10(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _set_prototype_of10(subClass, superClass);
    }
    function _iterable_to_array16(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _non_iterable_spread16() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys10 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys10 = ownKeys10.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys10.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props9(target, source) {
      return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      }), target;
    }
    function _possible_constructor_return10(self, call) {
      return call && (_type_of12(call) === "object" || typeof call == "function") ? call : _assert_this_initialized10(self);
    }
    function _set_prototype_of10(o, p) {
      return _set_prototype_of10 = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _set_prototype_of10(o, p);
    }
    function _to_consumable_array16(arr) {
      return _array_without_holes16(arr) || _iterable_to_array16(arr) || _unsupported_iterable_to_array22(arr) || _non_iterable_spread16();
    }
    function _type_of12(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array22(o, minLen) {
      if (o) {
        if (typeof o == "string")
          return _array_like_to_array22(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _array_like_to_array22(o, minLen);
      }
    }
    function _is_native_reflect_construct10() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _create_super10(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct10();
      return function() {
        var Super = _get_prototype_of10(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of10(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possible_constructor_return10(this, result);
      };
    }
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.BunPackageManager = void 0;
    var BasePackageManager_1 = require_BasePackageManager(), nodeWorkspaces_1 = require_nodeWorkspaces(), BunPackageManager = /* @__PURE__ */ function(_BasePackageManager_1_BasePackageManager) {
      _inherits10(BunPackageManager2, _BasePackageManager_1_BasePackageManager);
      var _super = _create_super10(BunPackageManager2);
      function BunPackageManager2() {
        _class_call_check15(this, BunPackageManager2);
        var _this;
        return _this = _super.apply(this, arguments), _define_property21(_assert_this_initialized10(_this), "name", "bun"), _define_property21(_assert_this_initialized10(_this), "bin", "bun"), _define_property21(_assert_this_initialized10(_this), "lockFile", nodeWorkspaces_1.BUN_LOCK_FILE), _this;
      }
      return _create_class13(BunPackageManager2, [
        {
          key: "workspaceRoot",
          value: function() {
            var root = (0, nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
            return root ? new BunPackageManager2(_object_spread_props9(_object_spread13({}, this.options), {
              silent: this.silent,
              log: this.log,
              cwd: root
            })) : null;
          }
        },
        {
          key: "installAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return this.runAsync([
              "install"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "addAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? this.runAsync([
              "add"
            ].concat(_to_consumable_array16(namesOrFlags))) : this.installAsync();
          }
        },
        {
          key: "addDevAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? this.runAsync([
              "add",
              "--dev"
            ].concat(_to_consumable_array16(namesOrFlags))) : this.installAsync();
          }
        },
        {
          key: "addGlobalAsync",
          value: function() {
            var namesOrFlags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return namesOrFlags.length ? this.runAsync([
              "add",
              "--global"
            ].concat(_to_consumable_array16(namesOrFlags))) : this.installAsync();
          }
        },
        {
          key: "removeAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeDevAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        },
        {
          key: "removeGlobalAsync",
          value: function(namesOrFlags) {
            return this.runAsync([
              "remove",
              "--global"
            ].concat(_to_consumable_array16(namesOrFlags)));
          }
        }
      ]), BunPackageManager2;
    }(BasePackageManager_1.BasePackageManager);
    exports2.BunPackageManager = BunPackageManager;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/nodeManagers.js
var require_nodeManagers = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/nodeManagers.js"(exports2) {
    "use strict";
    function _define_property21(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, {
        value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key] = value, obj;
    }
    function _object_spread13(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys9.forEach(function(key) {
          _define_property21(target, key, source[key]);
        });
      }
      return target;
    }
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.createForProject = exports2.resolvePackageManager = exports2.findWorkspaceRoot = exports2.RESOLUTION_ORDER = void 0;
    var fs_1 = __importDefault(require("fs")), path_1 = __importDefault(require("path")), nodeWorkspaces_1 = require_nodeWorkspaces(), BunPackageManager_1 = require_BunPackageManager(), NpmPackageManager_1 = require_NpmPackageManager(), PnpmPackageManager_1 = require_PnpmPackageManager(), YarnPackageManager_1 = require_YarnPackageManager();
    exports2.RESOLUTION_ORDER = [
      "bun",
      "yarn",
      "npm",
      "pnpm"
    ];
    function findWorkspaceRoot(projectRoot, preferredManager) {
      var strategies = {
        npm: nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot,
        yarn: nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot,
        pnpm: nodeWorkspaces_1.findPnpmWorkspaceRoot,
        bun: nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot
      };
      if (preferredManager)
        return strategies[preferredManager](projectRoot);
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = exports2.RESOLUTION_ORDER[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var strategy = _step.value, root = strategies[strategy](projectRoot);
          if (root)
            return root;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return null;
    }
    exports2.findWorkspaceRoot = findWorkspaceRoot;
    function resolvePackageManager(projectRoot, preferredManager) {
      var _findWorkspaceRoot, root = (_findWorkspaceRoot = findWorkspaceRoot(projectRoot, preferredManager)) !== null && _findWorkspaceRoot !== void 0 ? _findWorkspaceRoot : projectRoot, lockFiles = {
        npm: nodeWorkspaces_1.NPM_LOCK_FILE,
        pnpm: nodeWorkspaces_1.PNPM_LOCK_FILE,
        yarn: nodeWorkspaces_1.YARN_LOCK_FILE,
        bun: nodeWorkspaces_1.BUN_LOCK_FILE
      };
      if (preferredManager)
        return fs_1.default.existsSync(path_1.default.join(root, lockFiles[preferredManager])) ? preferredManager : null;
      var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
      try {
        for (var _iterator = exports2.RESOLUTION_ORDER[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
          var managerName = _step.value;
          if (fs_1.default.existsSync(path_1.default.join(root, lockFiles[managerName])))
            return managerName;
        }
      } catch (err) {
        _didIteratorError2 = !0, _iteratorError2 = err;
      } finally {
        try {
          !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError2)
            throw _iteratorError2;
        }
      }
      return null;
    }
    exports2.resolvePackageManager = resolvePackageManager;
    function createForProject(projectRoot) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options.npm)
        return new NpmPackageManager_1.NpmPackageManager(_object_spread13({
          cwd: projectRoot
        }, options));
      if (options.yarn)
        return new YarnPackageManager_1.YarnPackageManager(_object_spread13({
          cwd: projectRoot
        }, options));
      if (options.pnpm)
        return new PnpmPackageManager_1.PnpmPackageManager(_object_spread13({
          cwd: projectRoot
        }, options));
      if (options.bun)
        return new BunPackageManager_1.BunPackageManager(_object_spread13({
          cwd: projectRoot
        }, options));
      switch (resolvePackageManager(projectRoot)) {
        case "npm":
          return new NpmPackageManager_1.NpmPackageManager(_object_spread13({
            cwd: projectRoot
          }, options));
        case "pnpm":
          return new PnpmPackageManager_1.PnpmPackageManager(_object_spread13({
            cwd: projectRoot
          }, options));
        case "yarn":
          return new YarnPackageManager_1.YarnPackageManager(_object_spread13({
            cwd: projectRoot
          }, options));
        case "bun":
          return new BunPackageManager_1.BunPackageManager(_object_spread13({
            cwd: projectRoot
          }, options));
        default:
          return new NpmPackageManager_1.NpmPackageManager(_object_spread13({
            cwd: projectRoot
          }, options));
      }
    }
    exports2.createForProject = createForProject;
  }
});

// ../../node_modules/@expo/package-manager/build/index.js
var require_build = __commonJS({
  "../../node_modules/@expo/package-manager/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
        enumerable: !0,
        get: function() {
          return m[k];
        }
      }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports2 && exports2.__exportStar || function(m, exports1) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p) && __createBinding(exports1, m, p);
    };
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.isYarnOfflineAsync = void 0;
    __exportStar(require_PackageManager(), exports2);
    __exportStar(require_CocoaPodsPackageManager(), exports2);
    __exportStar(require_NpmPackageManager(), exports2);
    __exportStar(require_PnpmPackageManager(), exports2);
    __exportStar(require_YarnPackageManager(), exports2);
    __exportStar(require_BunPackageManager(), exports2);
    __exportStar(require_nodeManagers(), exports2);
    __exportStar(require_nodeWorkspaces(), exports2);
    var yarn_1 = require_yarn();
    Object.defineProperty(exports2, "isYarnOfflineAsync", {
      enumerable: !0,
      get: function() {
        return yarn_1.isYarnOfflineAsync;
      }
    });
  }
});

// src/index.ts
var import_child_process3 = require("child_process"), import_fs15 = __toESM(require("fs")), import_path12 = __toESM(require("path")), import_process = require("process"), import_chalk15 = __toESM(require_source()), import_commander = __toESM(require_commander());

// ../../node_modules/detect-package-manager/dist/index.mjs
var import_fs = require("fs"), import_path = require("path"), import_execa = __toESM(require_execa(), 1);
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr))
    return arr;
}
function asyncGeneratorStep(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array(o, minLen);
  }
}
function _ts_generator(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
function pathExists(p) {
  return _pathExists.apply(this, arguments);
}
function _pathExists() {
  return _pathExists = _async_to_generator(function(p) {
    var e;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          return _state.trys.push([
            0,
            2,
            ,
            3
          ]), [
            4,
            import_fs.promises.access(p)
          ];
        case 1:
          return _state.sent(), [
            2,
            !0
          ];
        case 2:
          return e = _state.sent(), [
            2,
            !1
          ];
        case 3:
          return [
            2
          ];
      }
    });
  }), _pathExists.apply(this, arguments);
}
var cache = /* @__PURE__ */ new Map();
function hasGlobalInstallation(pm) {
  var key = "has_global_".concat(pm);
  return cache.has(key) ? Promise.resolve(cache.get(key)) : (0, import_execa.default)(pm, [
    "--version"
  ]).then(function(res) {
    return /^\d+.\d+.\d+$/.test(res.stdout);
  }).then(function(value) {
    return cache.set(key, value), value;
  }).catch(function() {
    return !1;
  });
}
function getTypeofLockFile() {
  var cwd2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ".", key = "lockfile_".concat(cwd2);
  return cache.has(key) ? Promise.resolve(cache.get(key)) : Promise.all([
    pathExists((0, import_path.resolve)(cwd2, "yarn.lock")),
    pathExists((0, import_path.resolve)(cwd2, "package-lock.json")),
    pathExists((0, import_path.resolve)(cwd2, "pnpm-lock.yaml")),
    pathExists((0, import_path.resolve)(cwd2, "bun.lockb"))
  ]).then(function(param) {
    var _param = _sliced_to_array(param, 4), isYarn = _param[0], isNpm = _param[1], isPnpm = _param[2], isBun = _param[3], value = null;
    return isYarn ? value = "yarn" : isPnpm ? value = "pnpm" : isBun ? value = "bun" : isNpm && (value = "npm"), cache.set(key, value), value;
  });
}
var detect = function() {
  var _ref = _async_to_generator(function() {
    var _ref2, cwd2, includeGlobalBun, type, _ref1, hasYarn, hasPnpm, hasBun, _arguments = arguments;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          return _ref2 = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : {}, cwd2 = _ref2.cwd, includeGlobalBun = _ref2.includeGlobalBun, [
            4,
            getTypeofLockFile(cwd2)
          ];
        case 1:
          return type = _state.sent(), type ? [
            2,
            type
          ] : [
            4,
            Promise.all([
              hasGlobalInstallation("yarn"),
              hasGlobalInstallation("pnpm"),
              includeGlobalBun && hasGlobalInstallation("bun")
            ])
          ];
        case 2:
          return _ref1 = _sliced_to_array.apply(void 0, [
            _state.sent(),
            3
          ]), hasYarn = _ref1[0], hasPnpm = _ref1[1], hasBun = _ref1[2], hasYarn ? [
            2,
            "yarn"
          ] : hasPnpm ? [
            2,
            "pnpm"
          ] : hasBun ? [
            2,
            "bun"
          ] : [
            2,
            "npm"
          ];
      }
    });
  });
  return function() {
    return _ref.apply(this, arguments);
  };
}();

// src/index.ts
var import_fs_extra2 = __toESM(require_lib()), import_opener = __toESM(require_opener()), import_prompts4 = __toESM(require_prompts3());

// ../../node_modules/zx/build/core.js
var import_node_assert = __toESM(require("node:assert"), 1), import_node_child_process = require("node:child_process"), import_node_async_hooks = require("node:async_hooks"), import_node_util2 = require("node:util");

// ../../node_modules/zx/node_modules/chalk/source/vendor/ansi-styles/index.js
function _array_like_to_array2(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array2(arr);
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit2(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array2(arr, i) {
  return _array_with_holes2(arr) || _iterable_to_array_limit2(arr, i) || _unsupported_iterable_to_array2(arr, i) || _non_iterable_rest2();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array2(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array2(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array2(o, minLen);
  }
}
var ANSI_BACKGROUND_OFFSET = 10, wrapAnsi16 = function() {
  var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return function(code) {
    return "\x1B[".concat(code + offset, "m");
  };
}, wrapAnsi256 = function() {
  var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return function(code) {
    return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
  };
}, wrapAnsi16m = function() {
  var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return function(red, green, blue) {
    return "\x1B[".concat(38 + offset, ";2;").concat(red, ";").concat(green, ";").concat(blue, "m");
  };
}, styles = {
  modifier: {
    reset: [
      0,
      0
    ],
    // 21 isn't widely supported and 22 does the same thing
    bold: [
      1,
      22
    ],
    dim: [
      2,
      22
    ],
    italic: [
      3,
      23
    ],
    underline: [
      4,
      24
    ],
    overline: [
      53,
      55
    ],
    inverse: [
      7,
      27
    ],
    hidden: [
      8,
      28
    ],
    strikethrough: [
      9,
      29
    ]
  },
  color: {
    black: [
      30,
      39
    ],
    red: [
      31,
      39
    ],
    green: [
      32,
      39
    ],
    yellow: [
      33,
      39
    ],
    blue: [
      34,
      39
    ],
    magenta: [
      35,
      39
    ],
    cyan: [
      36,
      39
    ],
    white: [
      37,
      39
    ],
    // Bright color
    blackBright: [
      90,
      39
    ],
    gray: [
      90,
      39
    ],
    // Alias of `blackBright`
    grey: [
      90,
      39
    ],
    // Alias of `blackBright`
    redBright: [
      91,
      39
    ],
    greenBright: [
      92,
      39
    ],
    yellowBright: [
      93,
      39
    ],
    blueBright: [
      94,
      39
    ],
    magentaBright: [
      95,
      39
    ],
    cyanBright: [
      96,
      39
    ],
    whiteBright: [
      97,
      39
    ]
  },
  bgColor: {
    bgBlack: [
      40,
      49
    ],
    bgRed: [
      41,
      49
    ],
    bgGreen: [
      42,
      49
    ],
    bgYellow: [
      43,
      49
    ],
    bgBlue: [
      44,
      49
    ],
    bgMagenta: [
      45,
      49
    ],
    bgCyan: [
      46,
      49
    ],
    bgWhite: [
      47,
      49
    ],
    // Bright color
    bgBlackBright: [
      100,
      49
    ],
    bgGray: [
      100,
      49
    ],
    // Alias of `bgBlackBright`
    bgGrey: [
      100,
      49
    ],
    // Alias of `bgBlackBright`
    bgRedBright: [
      101,
      49
    ],
    bgGreenBright: [
      102,
      49
    ],
    bgYellowBright: [
      103,
      49
    ],
    bgBlueBright: [
      104,
      49
    ],
    bgMagentaBright: [
      105,
      49
    ],
    bgCyanBright: [
      106,
      49
    ],
    bgWhiteBright: [
      107,
      49
    ]
  }
}, modifierNames = Object.keys(styles.modifier), foregroundColorNames = Object.keys(styles.color), backgroundColorNames = Object.keys(styles.bgColor), colorNames = _to_consumable_array(foregroundColorNames).concat(_to_consumable_array(backgroundColorNames));
function assembleStyles() {
  var _styles, codes2 = /* @__PURE__ */ new Map(), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _iterator = Object.entries(styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
      var _step_value = _sliced_to_array2(_step.value, 2), groupName = _step_value[0], group = _step_value[1], _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
      try {
        for (var _iterator1 = Object.entries(group)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
          var _step_value1 = _sliced_to_array2(_step1.value, 2), styleName = _step_value1[0], style = _step_value1[1];
          styles[styleName] = {
            open: "\x1B[".concat(style[0], "m"),
            close: "\x1B[".concat(style[1], "m")
          }, group[styleName] = styles[styleName], codes2.set(style[0], style[1]);
        }
      } catch (err) {
        _didIteratorError12 = !0, _iteratorError12 = err;
      } finally {
        try {
          !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError12)
            throw _iteratorError12;
        }
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: !1
      });
    }
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
  return Object.defineProperty(styles, "codes", {
    value: codes2,
    enumerable: !1
  }), styles.color.close = "\x1B[39m", styles.bgColor.close = "\x1B[49m", styles.color.ansi = wrapAnsi16(), styles.color.ansi256 = wrapAnsi256(), styles.color.ansi16m = wrapAnsi16m(), styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET), styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET), styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET), Object.defineProperties(styles, {
    rgbToAnsi256: {
      value: function(red, green, blue) {
        return red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value: function(hex) {
        var matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches)
          return [
            0,
            0,
            0
          ];
        var _matches = _sliced_to_array2(matches, 1), colorString = _matches[0];
        colorString.length === 3 && (colorString = _to_consumable_array(colorString).map(function(character) {
          return character + character;
        }).join(""));
        var integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      /* eslint-enable no-bitwise */
      enumerable: !1
    },
    hexToAnsi256: {
      value: function(hex) {
        return (_styles = styles).rgbToAnsi256.apply(_styles, _to_consumable_array(styles.hexToRgb(hex)));
      },
      enumerable: !1
    },
    ansi256ToAnsi: {
      value: function(code) {
        if (code < 8)
          return 30 + code;
        if (code < 16)
          return 90 + (code - 8);
        var red, green, blue;
        if (code >= 232)
          red = ((code - 232) * 10 + 8) / 255, green = red, blue = red;
        else {
          code -= 16;
          var remainder = code % 36;
          red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
        }
        var value2 = Math.max(red, green, blue) * 2;
        if (value2 === 0)
          return 30;
        var result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        return value2 === 2 && (result += 60), result;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: function(red, green, blue) {
        return styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue));
      },
      enumerable: !1
    },
    hexToAnsi: {
      value: function(hex) {
        return styles.ansi256ToAnsi(styles.hexToAnsi256(hex));
      },
      enumerable: !1
    }
  }), styles;
}
var ansiStyles = assembleStyles(), ansi_styles_default = ansiStyles;

// ../../node_modules/zx/node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require("node:process"), 1), import_node_os = __toESM(require("node:os"), 1), import_node_tty = __toESM(require("node:tty"), 1);
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function hasFlag(flag) {
  var argv2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv, prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv2.indexOf(prefix + flag), terminatorPosition = argv2.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var env = import_node_process.default.env, flagForceColor;
hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? flagForceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (flagForceColor = 1);
function envForceColor() {
  if ("FORCE_COLOR" in env)
    return env.FORCE_COLOR === "true" ? 1 : env.FORCE_COLOR === "false" ? 0 : env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
}
function translateLevel(level) {
  return level === 0 ? !1 : {
    level,
    hasBasic: !0,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, streamIsTTY = _ref.streamIsTTY, _ref_sniffFlags = _ref.sniffFlags, sniffFlags = _ref_sniffFlags === void 0 ? !0 : _ref_sniffFlags, noFlagForceColor = envForceColor();
  noFlagForceColor !== void 0 && (flagForceColor = noFlagForceColor);
  var forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0)
    return 0;
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
      return 3;
    if (hasFlag("color=256"))
      return 2;
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env)
    return 1;
  if (haveStream && !streamIsTTY && forceColor === void 0)
    return 0;
  var min = forceColor || 0;
  if (env.TERM === "dumb")
    return min;
  if (import_node_process.default.platform === "win32") {
    var osRelease = import_node_os.default.release().split(".");
    return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in env)
    return "GITHUB_ACTIONS" in env ? 3 : [
      "TRAVIS",
      "CIRCLECI",
      "APPVEYOR",
      "GITLAB_CI",
      "BUILDKITE",
      "DRONE"
    ].some(function(sign) {
      return sign in env;
    }) || env.CI_NAME === "codeship" ? 1 : min;
  if ("TEAMCITY_VERSION" in env)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  if (env.COLORTERM === "truecolor" || env.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in env) {
    var version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        return version2 >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
}
function createSupportsColor(stream2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, level = _supportsColor(stream2, _object_spread({
    streamIsTTY: stream2 && stream2.isTTY
  }, options));
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({
    isTTY: import_node_tty.default.isatty(1)
  }),
  stderr: createSupportsColor({
    isTTY: import_node_tty.default.isatty(2)
  })
}, supports_color_default = supportsColor;

// ../../node_modules/zx/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  var index = string.indexOf(substring);
  if (index === -1)
    return string;
  var substringLength = substring.length, endIndex = 0, returnValue = "";
  do
    returnValue += string.slice(endIndex, index) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
  while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  var endIndex = 0, returnValue = "";
  do {
    var gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}

// ../../node_modules/zx/node_modules/chalk/source/index.js
function _array_like_to_array3(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes2(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array3(arr);
}
function _define_property2(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array2(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit3(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property2(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array3(arr, i) {
  return _array_with_holes3(arr) || _iterable_to_array_limit3(arr, i) || _unsupported_iterable_to_array3(arr, i) || _non_iterable_rest3();
}
function _to_consumable_array2(arr) {
  return _array_without_holes2(arr) || _iterable_to_array2(arr) || _unsupported_iterable_to_array3(arr) || _non_iterable_spread2();
}
function _unsupported_iterable_to_array3(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array3(o, minLen);
  }
}
var stdoutColor = supports_color_default.stdout, stderrColor = supports_color_default.stderr, GENERATOR = Symbol("GENERATOR"), STYLER = Symbol("STYLER"), IS_EMPTY = Symbol("IS_EMPTY"), levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], styles2 = /* @__PURE__ */ Object.create(null), applyOptions = function(object) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  var colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = function(options) {
  var chalk13 = function() {
    for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++)
      strings[_key] = arguments[_key];
    return strings.join(" ");
  };
  return applyOptions(chalk13, options), Object.setPrototypeOf(chalk13, createChalk.prototype), chalk13;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
try {
  for (_loop = function() {
    var _step_value = _sliced_to_array3(_step.value, 2), styleName = _step_value[0], style = _step_value[1];
    styles2[styleName] = {
      get: function() {
        var builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
        return Object.defineProperty(this, styleName, {
          value: builder
        }), builder;
      }
    };
  }, _iterator = Object.entries(ansi_styles_default)[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0)
    _loop();
} catch (err) {
  _didIteratorError = !0, _iteratorError = err;
} finally {
  try {
    !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
  } finally {
    if (_didIteratorError)
      throw _iteratorError;
  }
}
var _loop, _iterator, _step;
styles2.visible = {
  get: function() {
    var builder = createBuilder(this, this[STYLER], !0);
    return Object.defineProperty(this, "visible", {
      value: builder
    }), builder;
  }
};
var getModelAnsi = function(model, level, type) {
  for (var _len = arguments.length, arguments_ = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++)
    arguments_[_key - 3] = arguments[_key];
  var _ansiStyles_type;
  if (model === "rgb") {
    var _ansiStyles;
    if (level === "ansi16m") {
      var _ansiStyles_type1;
      return (_ansiStyles_type1 = ansi_styles_default[type]).ansi16m.apply(_ansiStyles_type1, _to_consumable_array2(arguments_));
    }
    if (level === "ansi256") {
      var _ansiStyles1;
      return ansi_styles_default[type].ansi256((_ansiStyles1 = ansi_styles_default).rgbToAnsi256.apply(_ansiStyles1, _to_consumable_array2(arguments_)));
    }
    return ansi_styles_default[type].ansi((_ansiStyles = ansi_styles_default).rgbToAnsi.apply(_ansiStyles, _to_consumable_array2(arguments_)));
  }
  if (model === "hex") {
    var _ansiStyles2;
    return getModelAnsi.apply(void 0, [
      "rgb",
      level,
      type
    ].concat(_to_consumable_array2((_ansiStyles2 = ansi_styles_default).hexToRgb.apply(_ansiStyles2, _to_consumable_array2(arguments_)))));
  }
  return (_ansiStyles_type = ansi_styles_default[type])[model].apply(_ansiStyles_type, _to_consumable_array2(arguments_));
}, usedModels = [
  "rgb",
  "hex",
  "ansi256"
], _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
try {
  for (_loop1 = function() {
    var model = _step1.value;
    styles2[model] = {
      get: function() {
        var level = this.level;
        return function() {
          for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
            arguments_[_key] = arguments[_key];
          var styler = createStyler(getModelAnsi.apply(void 0, [
            model,
            levelMapping[level],
            "color"
          ].concat(_to_consumable_array2(arguments_))), ansi_styles_default.color.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
    var bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles2[bgModel] = {
      get: function() {
        var level = this.level;
        return function() {
          for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
            arguments_[_key] = arguments[_key];
          var styler = createStyler(getModelAnsi.apply(void 0, [
            model,
            levelMapping[level],
            "bgColor"
          ].concat(_to_consumable_array2(arguments_))), ansi_styles_default.bgColor.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
  }, _iterator1 = usedModels[Symbol.iterator](); !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0)
    _loop1();
} catch (err) {
  _didIteratorError1 = !0, _iteratorError1 = err;
} finally {
  try {
    !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
  } finally {
    if (_didIteratorError1)
      throw _iteratorError1;
  }
}
var _loop1, _iterator1, _step1, proto = Object.defineProperties(function() {
}, _object_spread_props(_object_spread2({}, styles2), {
  level: {
    enumerable: !0,
    get: function() {
      return this[GENERATOR].level;
    },
    set: function(level) {
      this[GENERATOR].level = level;
    }
  }
})), createStyler = function(open3, close, parent) {
  var openAll, closeAll;
  return parent === void 0 ? (openAll = open3, closeAll = close) : (openAll = parent.openAll + open3, closeAll = close + parent.closeAll), {
    open: open3,
    close,
    openAll,
    closeAll,
    parent
  };
}, createBuilder = function(self, _styler, _isEmpty) {
  var builder = function() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
      arguments_[_key] = arguments[_key];
    return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  };
  return Object.setPrototypeOf(builder, proto), builder[GENERATOR] = self, builder[STYLER] = _styler, builder[IS_EMPTY] = _isEmpty, builder;
}, applyStyle = function(self, string) {
  if (self.level <= 0 || !string)
    return self[IS_EMPTY] ? "" : string;
  var styler = self[STYLER];
  if (styler === void 0)
    return string;
  var openAll = styler.openAll, closeAll = styler.closeAll;
  if (string.includes("\x1B"))
    for (; styler !== void 0; )
      string = stringReplaceAll(string, styler.close, styler.open), styler = styler.parent;
  var lfIndex = string.indexOf(`
`);
  return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk(), chalkStderr = createChalk({
  level: stderrColor ? stderrColor.level : 0
});
var source_default = chalk;

// ../../node_modules/zx/build/core.js
var import_which = __toESM(require_lib3(), 1);

// ../../node_modules/zx/build/util.js
var import_node_util = require("node:util"), import_ps_tree = __toESM(require_ps_tree(), 1);
function _array_like_to_array4(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes3(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array4(arr);
}
function _iterable_to_array3(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _non_iterable_spread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array3(arr) {
  return _array_without_holes3(arr) || _iterable_to_array3(arr) || _unsupported_iterable_to_array4(arr) || _non_iterable_spread3();
}
function _unsupported_iterable_to_array4(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array4(o, minLen);
  }
}
var psTree = (0, import_node_util.promisify)(import_ps_tree.default);
function noop() {
}
function quote(arg) {
  return /^[a-z0-9/_.\-@:=]+$/i.test(arg) || arg === "" ? arg : "$'" + arg.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0") + "'";
}
function quotePowerShell(arg) {
  return /^[a-z0-9/_.\-]+$/i.test(arg) || arg === "" ? arg : "'" + arg.replace(/'/g, "''") + "'";
}
function exitCodeInfo(exitCode) {
  return {
    2: "Misuse of shell builtins",
    126: "Invoked command cannot execute",
    127: "Command not found",
    128: "Invalid exit argument",
    129: "Hangup",
    130: "Interrupt",
    131: "Quit and dump core",
    132: "Illegal instruction",
    133: "Trace/breakpoint trap",
    134: "Process aborted",
    135: 'Bus error: "access to undefined portion of memory object"',
    136: 'Floating point exception: "erroneous arithmetic operation"',
    137: "Kill (terminate immediately)",
    138: "User-defined 1",
    139: "Segmentation violation",
    140: "User-defined 2",
    141: "Write to pipe with no one reading",
    142: "Signal raised by alarm",
    143: "Termination (request to terminate)",
    145: "Child process terminated, stopped (or continued*)",
    146: "Continue if stopped",
    147: "Stop executing temporarily",
    148: "Terminal stop signal",
    149: 'Background process attempting to read from tty ("in")',
    150: 'Background process attempting to write to tty ("out")',
    151: "Urgent data available on socket",
    152: "CPU time limit exceeded",
    153: "File size limit exceeded",
    154: 'Signal raised by timer counting virtual time: "virtual timer expired"',
    155: "Profiling timer expired",
    157: "Pollable event",
    159: "Bad syscall"
  }[exitCode || -1];
}
function errnoMessage(errno) {
  return errno === void 0 ? "Unknown error" : {
    0: "Success",
    1: "Not super-user",
    2: "No such file or directory",
    3: "No such process",
    4: "Interrupted system call",
    5: "I/O error",
    6: "No such device or address",
    7: "Arg list too long",
    8: "Exec format error",
    9: "Bad file number",
    10: "No children",
    11: "No more processes",
    12: "Not enough core",
    13: "Permission denied",
    14: "Bad address",
    15: "Block device required",
    16: "Mount device busy",
    17: "File exists",
    18: "Cross-device link",
    19: "No such device",
    20: "Not a directory",
    21: "Is a directory",
    22: "Invalid argument",
    23: "Too many open files in system",
    24: "Too many open files",
    25: "Not a typewriter",
    26: "Text file busy",
    27: "File too large",
    28: "No space left on device",
    29: "Illegal seek",
    30: "Read only file system",
    31: "Too many links",
    32: "Broken pipe",
    33: "Math arg out of domain of func",
    34: "Math result not representable",
    35: "File locking deadlock error",
    36: "File or path name too long",
    37: "No record locks available",
    38: "Function not implemented",
    39: "Directory not empty",
    40: "Too many symbolic links",
    42: "No message of desired type",
    43: "Identifier removed",
    44: "Channel number out of range",
    45: "Level 2 not synchronized",
    46: "Level 3 halted",
    47: "Level 3 reset",
    48: "Link number out of range",
    49: "Protocol driver not attached",
    50: "No CSI structure available",
    51: "Level 2 halted",
    52: "Invalid exchange",
    53: "Invalid request descriptor",
    54: "Exchange full",
    55: "No anode",
    56: "Invalid request code",
    57: "Invalid slot",
    59: "Bad font file fmt",
    60: "Device not a stream",
    61: "No data (for no delay io)",
    62: "Timer expired",
    63: "Out of streams resources",
    64: "Machine is not on the network",
    65: "Package not installed",
    66: "The object is remote",
    67: "The link has been severed",
    68: "Advertise error",
    69: "Srmount error",
    70: "Communication error on send",
    71: "Protocol error",
    72: "Multihop attempted",
    73: "Cross mount point (not really error)",
    74: "Trying to read unreadable message",
    75: "Value too large for defined data type",
    76: "Given log. name not unique",
    77: "f.d. invalid for this operation",
    78: "Remote address changed",
    79: "Can   access a needed shared lib",
    80: "Accessing a corrupted shared lib",
    81: ".lib section in a.out corrupted",
    82: "Attempting to link in too many libs",
    83: "Attempting to exec a shared library",
    84: "Illegal byte sequence",
    86: "Streams pipe error",
    87: "Too many users",
    88: "Socket operation on non-socket",
    89: "Destination address required",
    90: "Message too long",
    91: "Protocol wrong type for socket",
    92: "Protocol not available",
    93: "Unknown protocol",
    94: "Socket type not supported",
    95: "Not supported",
    96: "Protocol family not supported",
    97: "Address family not supported by protocol family",
    98: "Address already in use",
    99: "Address not available",
    100: "Network interface is not configured",
    101: "Network is unreachable",
    102: "Connection reset by network",
    103: "Connection aborted",
    104: "Connection reset by peer",
    105: "No buffer space available",
    106: "Socket is already connected",
    107: "Socket is not connected",
    108: "Can't send after socket shutdown",
    109: "Too many references",
    110: "Connection timed out",
    111: "Connection refused",
    112: "Host is down",
    113: "Host is unreachable",
    114: "Socket already connected",
    115: "Connection already in progress",
    116: "Stale file handle",
    122: "Quota exceeded",
    123: "No medium (in tape drive)",
    125: "Operation canceled",
    130: "Previous owner died",
    131: "State not recoverable"
  }[-errno] || "Unknown error";
}
function parseDuration(d) {
  if (typeof d == "number") {
    if (isNaN(d) || d < 0)
      throw new Error('Invalid duration: "'.concat(d, '".'));
    return d;
  } else {
    if (/\d+s/.test(d))
      return +d.slice(0, -1) * 1e3;
    if (/\d+ms/.test(d))
      return +d.slice(0, -2);
  }
  throw new Error('Unknown duration: "'.concat(d, '".'));
}
function formatCmd(cmd) {
  if (cmd == null)
    return source_default.grey("undefined");
  for (var chars = _to_consumable_array3(cmd), out = "$ ", buf = "", ch, state = root, wordCount = 0; state; ) {
    if (ch = chars.shift() || "EOF", ch == `
`) {
      out += style(state, buf) + `
> `, buf = "";
      continue;
    }
    var next = ch == "EOF" ? void 0 : state();
    next != state && (out += style(state, buf), buf = ""), state = next == root ? next() : next, buf += ch;
  }
  function style(state2, s) {
    return s == "" ? "" : reservedWords.includes(s) ? source_default.cyanBright(s) : state2 == word && wordCount == 0 ? (wordCount++, source_default.greenBright(s)) : state2 == syntax ? (wordCount = 0, source_default.cyanBright(s)) : state2 == dollar ? source_default.yellowBright(s) : state2 != null && state2.name.startsWith("str") ? source_default.yellowBright(s) : s;
  }
  function isSyntax(ch2) {
    return "()[]{}<>;:+|&=".includes(ch2);
  }
  function root() {
    return /\s/.test(ch) ? space : isSyntax(ch) ? syntax : /[$]/.test(ch) ? dollar : /["]/.test(ch) ? strDouble : /[']/.test(ch) ? strSingle : word;
  }
  function space() {
    return /\s/.test(ch) ? space : root;
  }
  function word() {
    return /[0-9a-z/_.]/i.test(ch) ? word : root;
  }
  function syntax() {
    return isSyntax(ch) ? syntax : root;
  }
  function dollar() {
    return /[']/.test(ch) ? str : root;
  }
  function str() {
    return /[']/.test(ch) ? strEnd : /[\\]/.test(ch) ? strBackslash : str;
  }
  function strBackslash() {
    return strEscape;
  }
  function strEscape() {
    return str;
  }
  function strDouble() {
    return /["]/.test(ch) ? strEnd : strDouble;
  }
  function strSingle() {
    return /[']/.test(ch) ? strEnd : strSingle;
  }
  function strEnd() {
    return root;
  }
  return out + `
`;
}
var reservedWords = [
  "if",
  "then",
  "else",
  "elif",
  "fi",
  "case",
  "esac",
  "for",
  "select",
  "while",
  "until",
  "do",
  "done",
  "in"
];

// ../../node_modules/zx/build/core.js
function _array_like_to_array5(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes4(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _assert_this_initialized(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function asyncGeneratorStep2(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator2(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep2(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep2(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _construct(Parent, args, Class) {
  return _is_native_reflect_construct() ? _construct = Reflect.construct : _construct = function(Parent2, args2, Class2) {
    var a = [
      null
    ];
    a.push.apply(a, args2);
    var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
    return Class2 && _set_prototype_of(instance, Class2.prototype), instance;
  }, _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _define_property3(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _get(target, property, receiver) {
  return typeof Reflect < "u" && Reflect.get ? _get = Reflect.get : _get = function(target2, property2, receiver2) {
    var base = _super_prop_base(target2, property2);
    if (base) {
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
    }
  }, _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
  return _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of(subClass, superClass);
}
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _is_native_function(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array_limit4(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property3(target, key, source[key]);
    });
  }
  return target;
}
function _possible_constructor_return(self, call) {
  return call && (_type_of(call) === "object" || typeof call == "function") ? call : _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
  return _set_prototype_of = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of(o, p);
}
function _sliced_to_array4(arr, i) {
  return _array_with_holes4(arr) || _iterable_to_array_limit4(arr, i) || _unsupported_iterable_to_array5(arr, i) || _non_iterable_rest4();
}
function _super_prop_base(object, property) {
  for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of(object), object !== null); )
    ;
  return object;
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array5(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array5(o, minLen);
  }
}
function _wrap_native_super(Class) {
  var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return _wrap_native_super = function(Class2) {
    if (Class2 === null || !_is_native_function(Class2))
      return Class2;
    if (typeof Class2 != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof _cache < "u") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _get_prototype_of(this).constructor);
    }
    return Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), _set_prototype_of(Wrapper, Class2);
  }, _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct();
  return function() {
    var Super = _get_prototype_of(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return(this, result);
  };
}
function _ts_generator2(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var processCwd = Symbol("processCwd"), storage = new import_node_async_hooks.AsyncLocalStorage(), hook = (0, import_node_async_hooks.createHook)({
  init: syncCwd,
  before: syncCwd,
  promiseResolve: syncCwd,
  after: syncCwd,
  destroy: syncCwd
});
hook.enable();
var _obj, defaults = (_obj = {}, _define_property3(_obj, processCwd, process.cwd()), _define_property3(_obj, "verbose", !0), _define_property3(_obj, "env", process.env), _define_property3(_obj, "shell", !0), _define_property3(_obj, "prefix", ""), _define_property3(_obj, "quote", function() {
  throw new Error("No quote function is defined: https://\xEF.at/no-quote-func");
}), _define_property3(_obj, "spawn", import_node_child_process.spawn), _define_property3(_obj, "log", log), _obj);
try {
  defaults.shell = import_which.default.sync("bash"), defaults.prefix = "set -euo pipefail;", defaults.quote = quote;
} catch {
  process.platform == "win32" && (defaults.shell = import_which.default.sync("powershell.exe"), defaults.quote = quotePowerShell);
}
function getStore() {
  return storage.getStore() || defaults;
}
var $ = new Proxy(function(pieces) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
    args[_key - 1] = arguments[_key];
  var from = new Error().stack.split(/^\s*at\s/m)[2].trim();
  if (pieces.some(function(p) {
    return p == null;
  }))
    throw new Error("Malformed command at ".concat(from));
  for (var resolve7, reject, promise = new ProcessPromise(function() {
    for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
      args2[_key2] = arguments[_key2];
    var ref;
    return ref = _sliced_to_array4(args2, 2), resolve7 = ref[0], reject = ref[1], ref;
  }), cmd = pieces[0], i = 0; i < args.length; ) {
    var s = void 0;
    Array.isArray(args[i]) ? s = args[i].map(function(x) {
      return $.quote(substitute(x));
    }).join(" ") : s = $.quote(substitute(args[i])), cmd += s + pieces[++i];
  }
  return promise._bind(cmd, from, resolve7, reject, getStore()), setImmediate(function() {
    return promise.isHalted || promise.run();
  }), promise;
}, {
  set: function(_, key, value) {
    var target = key in Function.prototype ? _ : getStore();
    return Reflect.set(target, key, value), !0;
  },
  get: function(_, key) {
    var target = key in Function.prototype ? _ : getStore();
    return Reflect.get(target, key);
  }
});
function substitute(arg) {
  return arg != null && arg.stdout ? arg.stdout.replace(/\n$/, "") : "".concat(arg);
}
var ProcessPromise = /* @__PURE__ */ function(Promise1) {
  "use strict";
  _inherits(ProcessPromise2, Promise1);
  var _super = _create_super(ProcessPromise2);
  function ProcessPromise2() {
    _class_call_check(this, ProcessPromise2);
    var _this;
    return _this = _super.call.apply(_super, [
      this
    ].concat(Array.prototype.slice.call(arguments))), _this._command = "", _this._from = "", _this._resolve = noop, _this._reject = noop, _this._snapshot = getStore(), _this._stdio = [
      "inherit",
      "pipe",
      "pipe"
    ], _this._nothrow = !1, _this._quiet = !1, _this._resolved = !1, _this._halted = !1, _this._piped = !1, _this._prerun = noop, _this._postrun = noop, _this;
  }
  return _create_class(ProcessPromise2, [
    {
      key: "_bind",
      value: function(cmd, from, resolve7, reject, options) {
        this._command = cmd, this._from = from, this._resolve = resolve7, this._reject = reject, this._snapshot = _object_spread3({}, options);
      }
    },
    {
      key: "run",
      value: function() {
        var _this = this, _this_child_stdout, _this_child_stderr, $2 = this._snapshot;
        if (this.child)
          return this;
        this._prerun(), $2.log({
          kind: "cmd",
          cmd: this._command,
          verbose: $2.verbose && !this._quiet
        });
        var _$_cwd;
        this.child = $2.spawn($2.prefix + this._command, {
          cwd: (_$_cwd = $2.cwd) !== null && _$_cwd !== void 0 ? _$_cwd : $2[processCwd],
          shell: typeof $2.shell == "string" ? $2.shell : !0,
          stdio: this._stdio,
          windowsHide: !0,
          env: $2.env
        }), this.child.on("close", function(code, signal) {
          var message = "exit code: ".concat(code);
          (code != 0 || signal != null) && (message = "".concat(stderr || `
`, "    at ").concat(_this._from), message += `
    exit code: `.concat(code).concat(exitCodeInfo(code) ? " (" + exitCodeInfo(code) + ")" : ""), signal != null && (message += `
    signal: `.concat(signal)));
          var output = new ProcessOutput(code, signal, stdout, stderr, combined, message);
          code === 0 || _this._nothrow ? _this._resolve(output) : _this._reject(output), _this._resolved = !0;
        }), this.child.on("error", function(err) {
          var message = "".concat(err.message, `
`) + "    errno: ".concat(err.errno, " (").concat(errnoMessage(err.errno), `)
`) + "    code: ".concat(err.code, `
`) + "    at ".concat(_this._from);
          _this._reject(new ProcessOutput(null, null, stdout, stderr, combined, message)), _this._resolved = !0;
        });
        var stdout = "", stderr = "", combined = "", onStdout = function(data) {
          $2.log({
            kind: "stdout",
            data,
            verbose: $2.verbose && !_this._quiet
          }), stdout += data, combined += data;
        }, onStderr = function(data) {
          $2.log({
            kind: "stderr",
            data,
            verbose: $2.verbose && !_this._quiet
          }), stderr += data, combined += data;
        };
        if (this._piped || (_this_child_stdout = this.child.stdout) === null || _this_child_stdout === void 0 || _this_child_stdout.on("data", onStdout), (_this_child_stderr = this.child.stderr) === null || _this_child_stderr === void 0 || _this_child_stderr.on("data", onStderr), this._postrun(), this._timeout && this._timeoutSignal) {
          var t = setTimeout(function() {
            return _this.kill(_this._timeoutSignal);
          }, this._timeout);
          this.finally(function() {
            return clearTimeout(t);
          }).catch(noop);
        }
        return this;
      }
    },
    {
      key: "stdin",
      get: function() {
        if (this.stdio("pipe"), this.run(), (0, import_node_assert.default)(this.child), this.child.stdin == null)
          throw new Error("The stdin of subprocess is null.");
        return this.child.stdin;
      }
    },
    {
      key: "stdout",
      get: function() {
        if (this.run(), (0, import_node_assert.default)(this.child), this.child.stdout == null)
          throw new Error("The stdout of subprocess is null.");
        return this.child.stdout;
      }
    },
    {
      key: "stderr",
      get: function() {
        if (this.run(), (0, import_node_assert.default)(this.child), this.child.stderr == null)
          throw new Error("The stderr of subprocess is null.");
        return this.child.stderr;
      }
    },
    {
      key: "exitCode",
      get: function() {
        return this.then(function(p) {
          return p.exitCode;
        }, function(p) {
          return p.exitCode;
        });
      }
    },
    {
      key: "then",
      value: function(onfulfilled, onrejected) {
        if (this.isHalted && !this.child)
          throw new Error("The process is halted!");
        return _get(_get_prototype_of(ProcessPromise2.prototype), "then", this).call(this, onfulfilled, onrejected);
      }
    },
    {
      key: "catch",
      value: function(onrejected) {
        return _get(_get_prototype_of(ProcessPromise2.prototype), "catch", this).call(this, onrejected);
      }
    },
    {
      key: "pipe",
      value: function(dest) {
        var _this = this;
        if (typeof dest == "string")
          throw new Error("The pipe() method does not take strings. Forgot $?");
        if (this._resolved)
          throw _instanceof(dest, ProcessPromise2) && dest.stdin.end(), new Error("The pipe() method shouldn't be called after promise is already resolved!");
        return this._piped = !0, _instanceof(dest, ProcessPromise2) ? (dest.stdio("pipe"), dest._prerun = this.run.bind(this), dest._postrun = function() {
          if (!dest.child)
            throw new Error("Access to stdin of pipe destination without creation a subprocess.");
          _this.stdout.pipe(dest.stdin);
        }, dest) : (this._postrun = function() {
          return _this.stdout.pipe(dest);
        }, this);
      }
    },
    {
      key: "kill",
      value: function() {
        var signal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "SIGTERM", _this = this;
        return _async_to_generator2(function() {
          var children, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, p;
          return _ts_generator2(this, function(_state) {
            switch (_state.label) {
              case 0:
                if (!_this.child)
                  throw new Error("Trying to kill a process without creating one.");
                if (!_this.child.pid)
                  throw new Error("The process pid is undefined.");
                return [
                  4,
                  psTree(_this.child.pid)
                ];
              case 1:
                children = _state.sent(), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                try {
                  for (_iterator = children[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                    p = _step.value;
                    try {
                      process.kill(+p.PID, signal);
                    } catch {
                    }
                  }
                } catch (err) {
                  _didIteratorError2 = !0, _iteratorError2 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                }
                try {
                  process.kill(_this.child.pid, signal);
                } catch {
                }
                return [
                  2
                ];
            }
          });
        })();
      }
    },
    {
      key: "stdio",
      value: function(stdin) {
        var stdout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "pipe", stderr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "pipe";
        return this._stdio = [
          stdin,
          stdout,
          stderr
        ], this;
      }
    },
    {
      key: "nothrow",
      value: function() {
        return this._nothrow = !0, this;
      }
    },
    {
      key: "quiet",
      value: function() {
        return this._quiet = !0, this;
      }
    },
    {
      key: "timeout",
      value: function(d) {
        var signal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "SIGTERM";
        return this._timeout = parseDuration(d), this._timeoutSignal = signal, this;
      }
    },
    {
      key: "halt",
      value: function() {
        return this._halted = !0, this;
      }
    },
    {
      key: "isHalted",
      get: function() {
        return this._halted;
      }
    }
  ]), ProcessPromise2;
}(_wrap_native_super(Promise)), ProcessOutput = /* @__PURE__ */ function(Error1) {
  "use strict";
  _inherits(ProcessOutput2, Error1);
  var _super = _create_super(ProcessOutput2);
  function ProcessOutput2(code, signal, stdout, stderr, combined, message) {
    _class_call_check(this, ProcessOutput2);
    var _this;
    return _this = _super.call(this, message), _this._code = code, _this._signal = signal, _this._stdout = stdout, _this._stderr = stderr, _this._combined = combined, _this;
  }
  return _create_class(ProcessOutput2, [
    {
      key: "toString",
      value: function() {
        return this._combined;
      }
    },
    {
      key: "stdout",
      get: function() {
        return this._stdout;
      }
    },
    {
      key: "stderr",
      get: function() {
        return this._stderr;
      }
    },
    {
      key: "exitCode",
      get: function() {
        return this._code;
      }
    },
    {
      key: "signal",
      get: function() {
        return this._signal;
      }
    },
    {
      key: import_node_util2.inspect.custom,
      value: function() {
        var stringify = function(s, c) {
          return s.length === 0 ? "''" : c((0, import_node_util2.inspect)(s));
        };
        return `ProcessOutput {
  stdout: `.concat(stringify(this.stdout, source_default.green), `,
  stderr: `).concat(stringify(this.stderr, source_default.red), `,
  signal: `).concat((0, import_node_util2.inspect)(this.signal), `,
  exitCode: `).concat((this.exitCode === 0 ? source_default.green : source_default.red)(this.exitCode)).concat(exitCodeInfo(this.exitCode) ? source_default.grey(" (" + exitCodeInfo(this.exitCode) + ")") : "", `
}`);
      }
    }
  ]), ProcessOutput2;
}(_wrap_native_super(Error));
function syncCwd() {
  $[processCwd] != process.cwd() && process.chdir($[processCwd]);
}
function cd(dir) {
  _instanceof(dir, ProcessOutput) && (dir = dir.toString().replace(/\n+$/, "")), $.log({
    kind: "cd",
    dir
  }), process.chdir(dir), $[processCwd] = process.cwd();
}
function log(entry) {
  switch (entry.kind) {
    case "cmd":
      if (!entry.verbose)
        return;
      process.stderr.write(formatCmd(entry.cmd));
      break;
    case "stdout":
    case "stderr":
      if (!entry.verbose)
        return;
      process.stderr.write(entry.data);
      break;
    case "cd":
      if (!$.verbose)
        return;
      process.stderr.write("$ " + source_default.greenBright("cd") + " ".concat(entry.dir, `
`));
      break;
    case "fetch":
      if (!$.verbose)
        return;
      var init = entry.init ? " " + (0, import_node_util2.inspect)(entry.init) : "";
      process.stderr.write("$ " + source_default.greenBright("fetch") + " ".concat(entry.url).concat(init, `
`));
      break;
    case "retry":
      if (!$.verbose)
        return;
      process.stderr.write(entry.error + `
`);
  }
}

// ../../node_modules/zx/node_modules/globby/index.js
var globby_exports = {};
__export(globby_exports, {
  generateGlobTasks: () => generateGlobTasks,
  generateGlobTasksSync: () => generateGlobTasksSync,
  globby: () => globby,
  globbyStream: () => globbyStream,
  globbySync: () => globbySync,
  isDynamicPattern: () => isDynamicPattern,
  isGitIgnored: () => isGitIgnored,
  isGitIgnoredSync: () => isGitIgnoredSync
});
var import_node_fs2 = __toESM(require("node:fs"), 1), import_node_path2 = __toESM(require("node:path"), 1), import_merge2 = __toESM(require_merge2(), 1), import_fast_glob2 = __toESM(require_out4(), 1), import_dir_glob = __toESM(require_dir_glob(), 1);

// ../../node_modules/zx/node_modules/globby/ignore.js
var import_node_process2 = __toESM(require("node:process"), 1), import_node_fs = __toESM(require("node:fs"), 1), import_node_path = __toESM(require("node:path"), 1), import_fast_glob = __toESM(require_out4(), 1), import_ignore = __toESM(require_ignore(), 1);

// ../../node_modules/zx/node_modules/slash/index.js
function slash(path6) {
  var isExtendedLengthPath = /^\\\\\?\\/.test(path6), hasNonAscii = /[^\u0000-\u0080]+/.test(path6);
  return isExtendedLengthPath || hasNonAscii ? path6 : path6.replace(/\\/g, "/");
}

// ../../node_modules/zx/node_modules/globby/utilities.js
var import_node_url = require("node:url"), import_node_stream = require("node:stream");
function _assert_this_initialized2(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function _class_call_check2(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _get_prototype_of2(o) {
  return _get_prototype_of2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of2(o);
}
function _inherits2(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of2(subClass, superClass);
}
function _instanceof2(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _possible_constructor_return2(self, call) {
  return call && (_type_of2(call) === "object" || typeof call == "function") ? call : _assert_this_initialized2(self);
}
function _set_prototype_of2(o, p) {
  return _set_prototype_of2 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of2(o, p);
}
function _type_of2(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct2() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super2(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct2();
  return function() {
    var Super = _get_prototype_of2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return2(this, result);
  };
}
var toPath = function(urlOrPath) {
  return _instanceof2(urlOrPath, URL) ? (0, import_node_url.fileURLToPath)(urlOrPath) : urlOrPath;
}, FilterStream = /* @__PURE__ */ function(Transform2) {
  "use strict";
  _inherits2(FilterStream2, Transform2);
  var _super = _create_super2(FilterStream2);
  function FilterStream2(filter2) {
    return _class_call_check2(this, FilterStream2), _super.call(this, {
      objectMode: !0,
      transform: function(data, encoding, callback) {
        callback(void 0, filter2(data) ? data : void 0);
      }
    });
  }
  return FilterStream2;
}(import_node_stream.Transform), isNegativePattern = function(pattern) {
  return pattern[0] === "!";
};

// ../../node_modules/zx/node_modules/globby/ignore.js
function asyncGeneratorStep3(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator3(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep3(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep3(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _define_property4(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _object_spread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property4(target, key, source[key]);
    });
  }
  return target;
}
function _ts_generator3(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var ignoreFilesGlobOptions = {
  ignore: [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ],
  absolute: !0,
  dot: !0
}, GITIGNORE_FILES_PATTERN = "**/.gitignore", applyBaseToPattern = function(pattern, base) {
  return isNegativePattern(pattern) ? "!" + import_node_path.default.posix.join(base, pattern.slice(1)) : import_node_path.default.posix.join(base, pattern);
}, parseIgnoreFile = function(file, cwd2) {
  var base = slash(import_node_path.default.relative(cwd2, import_node_path.default.dirname(file.filePath)));
  return file.content.split(/\r?\n/).filter(function(line) {
    return line && !line.startsWith("#");
  }).map(function(pattern) {
    return applyBaseToPattern(pattern, base);
  });
}, toRelativePath = function(fileOrDirectory, cwd2) {
  if (cwd2 = slash(cwd2), import_node_path.default.isAbsolute(fileOrDirectory)) {
    if (slash(fileOrDirectory).startsWith(cwd2))
      return import_node_path.default.relative(cwd2, fileOrDirectory);
    throw new Error("Path ".concat(fileOrDirectory, " is not in cwd ").concat(cwd2));
  }
  return fileOrDirectory;
}, getIsIgnoredPredicate = function(files, cwd2) {
  var patterns = files.flatMap(function(file) {
    return parseIgnoreFile(file, cwd2);
  }), ignores = (0, import_ignore.default)().add(patterns);
  return function(fileOrDirectory) {
    return fileOrDirectory = toPath(fileOrDirectory), fileOrDirectory = toRelativePath(fileOrDirectory, cwd2), fileOrDirectory ? ignores.ignores(slash(fileOrDirectory)) : !1;
  };
}, normalizeOptions = function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    cwd: toPath(options.cwd) || import_node_process2.default.cwd(),
    suppressErrors: !!options.suppressErrors,
    deep: typeof options.deep == "number" ? options.deep : Number.POSITIVE_INFINITY
  };
}, isIgnoredByIgnoreFiles = function() {
  var _ref = _async_to_generator3(function(patterns, options) {
    var _normalizeOptions, cwd2, suppressErrors, deep, paths, files;
    return _ts_generator3(this, function(_state) {
      switch (_state.label) {
        case 0:
          return _normalizeOptions = normalizeOptions(options), cwd2 = _normalizeOptions.cwd, suppressErrors = _normalizeOptions.suppressErrors, deep = _normalizeOptions.deep, [
            4,
            (0, import_fast_glob.default)(patterns, _object_spread4({
              cwd: cwd2,
              suppressErrors,
              deep
            }, ignoreFilesGlobOptions))
          ];
        case 1:
          return paths = _state.sent(), [
            4,
            Promise.all(paths.map(function() {
              var _ref2 = _async_to_generator3(function(filePath) {
                var _tmp;
                return _ts_generator3(this, function(_state2) {
                  switch (_state2.label) {
                    case 0:
                      return _tmp = {
                        filePath
                      }, [
                        4,
                        import_node_fs.default.promises.readFile(filePath, "utf8")
                      ];
                    case 1:
                      return [
                        2,
                        (_tmp.content = _state2.sent(), _tmp)
                      ];
                  }
                });
              });
              return function(filePath) {
                return _ref2.apply(this, arguments);
              };
            }()))
          ];
        case 2:
          return files = _state.sent(), [
            2,
            getIsIgnoredPredicate(files, cwd2)
          ];
      }
    });
  });
  return function(patterns, options) {
    return _ref.apply(this, arguments);
  };
}(), isIgnoredByIgnoreFilesSync = function(patterns, options) {
  var _normalizeOptions = normalizeOptions(options), cwd2 = _normalizeOptions.cwd, suppressErrors = _normalizeOptions.suppressErrors, deep = _normalizeOptions.deep, paths = import_fast_glob.default.sync(patterns, _object_spread4({
    cwd: cwd2,
    suppressErrors,
    deep
  }, ignoreFilesGlobOptions)), files = paths.map(function(filePath) {
    return {
      filePath,
      content: import_node_fs.default.readFileSync(filePath, "utf8")
    };
  });
  return getIsIgnoredPredicate(files, cwd2);
}, isGitIgnored = function(options) {
  return isIgnoredByIgnoreFiles(GITIGNORE_FILES_PATTERN, options);
}, isGitIgnoredSync = function(options) {
  return isIgnoredByIgnoreFilesSync(GITIGNORE_FILES_PATTERN, options);
};

// ../../node_modules/zx/node_modules/globby/index.js
function _array_like_to_array6(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes5(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes4(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array6(arr);
}
function asyncGeneratorStep4(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator4(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep4(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep4(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _define_property5(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array4(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit5(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property5(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props2(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array5(arr, i) {
  return _array_with_holes5(arr) || _iterable_to_array_limit5(arr, i) || _unsupported_iterable_to_array6(arr, i) || _non_iterable_rest5();
}
function _to_consumable_array4(arr) {
  return _array_without_holes4(arr) || _iterable_to_array4(arr) || _unsupported_iterable_to_array6(arr) || _non_iterable_spread4();
}
function _unsupported_iterable_to_array6(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array6(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array6(o, minLen);
  }
}
function _ts_generator4(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var assertPatternsInput = function(patterns) {
  if (patterns.some(function(pattern) {
    return typeof pattern != "string";
  }))
    throw new TypeError("Patterns must be a string or an array of strings");
}, toPatternsArray = function(patterns) {
  return patterns = _to_consumable_array4(new Set([
    patterns
  ].flat())), assertPatternsInput(patterns), patterns;
}, checkCwdOption = function(options) {
  if (options.cwd) {
    var stat3;
    try {
      stat3 = import_node_fs2.default.statSync(options.cwd);
    } catch {
      return;
    }
    if (!stat3.isDirectory())
      throw new Error("The `cwd` option must be a path to a directory");
  }
}, normalizeOptions2 = function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return options = _object_spread_props2(_object_spread5({}, options), {
    ignore: options.ignore || [],
    expandDirectories: options.expandDirectories === void 0 ? !0 : options.expandDirectories,
    cwd: toPath(options.cwd)
  }), checkCwdOption(options), options;
}, normalizeArguments = function(fn) {
  return function() {
    var _ref = _async_to_generator4(function(patterns, options) {
      return _ts_generator4(this, function(_state) {
        return [
          2,
          fn(toPatternsArray(patterns), normalizeOptions2(options))
        ];
      });
    });
    return function(patterns, options) {
      return _ref.apply(this, arguments);
    };
  }();
}, normalizeArgumentsSync = function(fn) {
  return function(patterns, options) {
    return fn(toPatternsArray(patterns), normalizeOptions2(options));
  };
}, getIgnoreFilesPatterns = function(options) {
  var ignoreFiles = options.ignoreFiles, gitignore = options.gitignore, patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];
  return gitignore && patterns.push(GITIGNORE_FILES_PATTERN), patterns;
}, getFilter = function() {
  var _ref = _async_to_generator4(function(options) {
    var ignoreFilesPatterns, _tmp;
    return _ts_generator4(this, function(_state) {
      switch (_state.label) {
        case 0:
          return ignoreFilesPatterns = getIgnoreFilesPatterns(options), _tmp = ignoreFilesPatterns.length > 0, _tmp ? [
            4,
            isIgnoredByIgnoreFiles(ignoreFilesPatterns, options)
          ] : [
            3,
            2
          ];
        case 1:
          _tmp = _state.sent(), _state.label = 2;
        case 2:
          return [
            2,
            createFilterFunction.apply(void 0, [
              _tmp
            ])
          ];
      }
    });
  });
  return function(options) {
    return _ref.apply(this, arguments);
  };
}(), getFilterSync = function(options) {
  var ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(ignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, options));
}, createFilterFunction = function(isIgnored) {
  var seen = /* @__PURE__ */ new Set();
  return function(fastGlobResult) {
    var path6 = fastGlobResult.path || fastGlobResult, pathKey = import_node_path2.default.normalize(path6), seenOrIgnored = seen.has(pathKey) || isIgnored && isIgnored(path6);
    return seen.add(pathKey), !seenOrIgnored;
  };
}, unionFastGlobResults = function(results, filter2) {
  return results.flat().filter(function(fastGlobResult) {
    return filter2(fastGlobResult);
  });
}, unionFastGlobStreams = function(streams, filter2) {
  return (0, import_merge2.default)(streams).pipe(new FilterStream(function(fastGlobResult) {
    return filter2(fastGlobResult);
  }));
}, convertNegativePatterns = function(patterns, options) {
  for (var _loop = function() {
    var index = patterns.findIndex(function(pattern) {
      return isNegativePattern(pattern);
    });
    if (index === -1)
      return tasks.push({
        patterns,
        options
      }), "break";
    var ignorePattern = patterns[index].slice(1), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
    try {
      for (var _iterator = tasks[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
        var task = _step.value;
        task.options.ignore.push(ignorePattern);
      }
    } catch (err) {
      _didIteratorError2 = !0, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError2)
          throw _iteratorError2;
      }
    }
    index !== 0 && tasks.push({
      patterns: patterns.slice(0, index),
      options: _object_spread_props2(_object_spread5({}, options), {
        ignore: _to_consumable_array4(options.ignore).concat([
          ignorePattern
        ])
      })
    }), patterns = patterns.slice(index + 1);
  }, tasks = []; patterns.length > 0; ) {
    var _ret = _loop();
    if (_ret === "break")
      break;
  }
  return tasks;
}, getDirGlobOptions = function(options, cwd2) {
  return _object_spread5({}, cwd2 ? {
    cwd: cwd2
  } : {}, Array.isArray(options) ? {
    files: options
  } : options);
}, generateTasks = function() {
  var _ref = _async_to_generator4(function(patterns, options) {
    var globTasks, cwd2, expandDirectories, patternExpandOptions, ignoreExpandOptions;
    return _ts_generator4(this, function(_state) {
      return globTasks = convertNegativePatterns(patterns, options), cwd2 = options.cwd, expandDirectories = options.expandDirectories, expandDirectories ? (patternExpandOptions = getDirGlobOptions(expandDirectories, cwd2), ignoreExpandOptions = cwd2 ? {
        cwd: cwd2
      } : void 0, [
        2,
        Promise.all(globTasks.map(function() {
          var _ref2 = _async_to_generator4(function(task) {
            var _$patterns, _$options, ref;
            return _ts_generator4(this, function(_state2) {
              switch (_state2.label) {
                case 0:
                  return _$patterns = task.patterns, _$options = task.options, [
                    4,
                    Promise.all([
                      (0, import_dir_glob.default)(_$patterns, patternExpandOptions),
                      (0, import_dir_glob.default)(_$options.ignore, ignoreExpandOptions)
                    ])
                  ];
                case 1:
                  return ref = _sliced_to_array5.apply(void 0, [
                    _state2.sent(),
                    2
                  ]), _$patterns = ref[0], _$options.ignore = ref[1], [
                    2,
                    {
                      patterns: _$patterns,
                      options: _$options
                    }
                  ];
              }
            });
          });
          return function(task) {
            return _ref2.apply(this, arguments);
          };
        }()))
      ]) : [
        2,
        globTasks
      ];
    });
  });
  return function(patterns, options) {
    return _ref.apply(this, arguments);
  };
}(), generateTasksSync = function(patterns, options) {
  var globTasks = convertNegativePatterns(patterns, options), cwd2 = options.cwd, expandDirectories = options.expandDirectories;
  if (!expandDirectories)
    return globTasks;
  var patternExpandOptions = getDirGlobOptions(expandDirectories, cwd2), ignoreExpandOptions = cwd2 ? {
    cwd: cwd2
  } : void 0;
  return globTasks.map(function(task) {
    var _$patterns = task.patterns, _$options = task.options;
    return _$patterns = import_dir_glob.default.sync(_$patterns, patternExpandOptions), _$options.ignore = import_dir_glob.default.sync(_$options.ignore, ignoreExpandOptions), {
      patterns: _$patterns,
      options: _$options
    };
  });
}, globby = normalizeArguments(function() {
  var _ref = _async_to_generator4(function(patterns, options) {
    var _ref2, tasks, filter2, results;
    return _ts_generator4(this, function(_state) {
      switch (_state.label) {
        case 0:
          return [
            4,
            Promise.all([
              generateTasks(patterns, options),
              getFilter(options)
            ])
          ];
        case 1:
          return _ref2 = _sliced_to_array5.apply(void 0, [
            _state.sent(),
            2
          ]), tasks = _ref2[0], filter2 = _ref2[1], [
            4,
            Promise.all(tasks.map(function(task) {
              return (0, import_fast_glob2.default)(task.patterns, task.options);
            }))
          ];
        case 2:
          return results = _state.sent(), [
            2,
            unionFastGlobResults(results, filter2)
          ];
      }
    });
  });
  return function(patterns, options) {
    return _ref.apply(this, arguments);
  };
}()), globbySync = normalizeArgumentsSync(function(patterns, options) {
  var tasks = generateTasksSync(patterns, options), filter2 = getFilterSync(options), results = tasks.map(function(task) {
    return import_fast_glob2.default.sync(task.patterns, task.options);
  });
  return unionFastGlobResults(results, filter2);
}), globbyStream = normalizeArgumentsSync(function(patterns, options) {
  var tasks = generateTasksSync(patterns, options), filter2 = getFilterSync(options), streams = tasks.map(function(task) {
    return import_fast_glob2.default.stream(task.patterns, task.options);
  });
  return unionFastGlobStreams(streams, filter2);
}), isDynamicPattern = normalizeArgumentsSync(function(patterns, options) {
  return patterns.some(function(pattern) {
    return import_fast_glob2.default.isDynamicPattern(pattern, options);
  });
}), generateGlobTasks = normalizeArguments(generateTasks), generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);

// ../../node_modules/zx/build/goods.js
var import_minimist = __toESM(require_minimist(), 1);
var import_which2 = __toESM(require_lib3(), 1), import_yaml = __toESM(require_dist2(), 1);

// ../../node_modules/webpod/dist/ssh.js
function _assert_this_initialized3(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function _class_call_check3(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _construct2(Parent, args, Class) {
  return _is_native_reflect_construct3() ? _construct2 = Reflect.construct : _construct2 = function(Parent2, args2, Class2) {
    var a = [
      null
    ];
    a.push.apply(a, args2);
    var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
    return Class2 && _set_prototype_of3(instance, Class2.prototype), instance;
  }, _construct2.apply(null, arguments);
}
function _get_prototype_of3(o) {
  return _get_prototype_of3 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of3(o);
}
function _inherits3(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of3(subClass, superClass);
}
function _is_native_function2(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _possible_constructor_return3(self, call) {
  return call && (_type_of3(call) === "object" || typeof call == "function") ? call : _assert_this_initialized3(self);
}
function _set_prototype_of3(o, p) {
  return _set_prototype_of3 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of3(o, p);
}
function _type_of3(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _wrap_native_super2(Class) {
  var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return _wrap_native_super2 = function(Class2) {
    if (Class2 === null || !_is_native_function2(Class2))
      return Class2;
    if (typeof Class2 != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof _cache < "u") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct2(Class2, arguments, _get_prototype_of3(this).constructor);
    }
    return Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), _set_prototype_of3(Wrapper, Class2);
  }, _wrap_native_super2(Class);
}
function _is_native_reflect_construct3() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super3(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct3();
  return function() {
    var Super = _get_prototype_of3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return3(this, result);
  };
}
var Result = /* @__PURE__ */ function(String1) {
  "use strict";
  _inherits3(Result2, String1);
  var _super = _create_super3(Result2);
  function Result2(source, exitCode, stdout, stderr, combined, error) {
    _class_call_check3(this, Result2);
    var _this;
    return _this = _super.call(this, combined), _this.source = source, _this.stdout = stdout, _this.stderr = stderr, _this.exitCode = exitCode, _this.error = error, _this;
  }
  return Result2;
}(_wrap_native_super2(String));

// ../../node_modules/zx/build/goods.js
var argv = (0, import_minimist.default)(process.argv.slice(2));
var globby2 = Object.assign(function(patterns, options) {
  return globby(patterns, options);
}, globby_exports);

// package.json
var package_default = {
  name: "create-tamagui",
  version: "1.94.4",
  bin: "./run.js",
  main: "dist",
  files: [
    "run.js",
    "dist"
  ],
  scripts: {
    start: "./run.js",
    test: "NODE_ENV=test node -r esbuild-register ../../node_modules/.bin/playwright test integration.test.ts",
    "test:debug": "yarn test --debug",
    prerelease: "rimraf ./dist/",
    prepublish: "yarn build",
    build: "tamagui-build --skip-types --bundle --bundle-modules",
    watch: "yarn build --watch",
    clean: "tamagui-build clean",
    "clean:build": "tamagui-build clean:build"
  },
  devDependencies: {
    "@expo/package-manager": "^1.1.2",
    "@playwright/test": "^1.40.1",
    "@tamagui/build": "1.94.4",
    "@types/async-retry": "1.4.2",
    "@types/cross-spawn": "^6.0.2",
    "@types/node": "^16.11.9",
    "@types/opener": "^1.4.3",
    "@types/prompts": "2.0.1",
    "@types/rimraf": "3.0.0",
    "@types/tar": "4.0.3",
    "@types/validate-npm-package-name": "3.0.0",
    "async-retry": "1.3.1",
    chalk: "^4.1.2",
    commander: "2.20.0",
    cpy: "7.3.0",
    "cross-spawn": "6.0.5",
    "detect-package-manager": "^3.0.1",
    "esbuild-register": "^3.5.0",
    "fs-extra": "^11.2.0",
    got: "10.7.0",
    opener: "^1.5.2",
    prompts: "2.1.0",
    rimraf: "^5.0.1",
    tar: "4.4.10",
    "update-check": "1.5.4",
    "validate-npm-package-name": "3.0.0",
    "wait-port": "^0.3.0",
    zx: "^7.2.3"
  },
  engines: {
    node: ">=12.22.0"
  },
  publishConfig: {
    access: "public"
  },
  gitHead: "a49cc7ea6b93ba384e77a4880ae48ac4a5635c14"
};

// src/create-tamagui-constants.ts
var IS_TEST = process.env.NODE_ENV === "test";

// src/helpers/asciiArts.ts
var import_chalk6 = __toESM(require_source());

// src/helpers/rainbowChalk.ts
var import_chalk5 = __toESM(require_source()), rainbowColors = [
  "#f76808",
  "#f5d90a",
  "#30a46c",
  "#0091ff",
  "#8e4ec6",
  "#d6409f",
  "#e5484d"
];

// src/helpers/asciiArts.ts
var tamaguiRainbowAsciiArt = function() {
  var char0_1 = import_chalk6.default.hex(rainbowColors[0])("\u2580\u2588\u2580"), char0_2 = import_chalk6.default.hex(rainbowColors[0])(" \u2588 "), char1_1 = import_chalk6.default.hex(rainbowColors[1])("\u2584\u2580\u2588"), char1_2 = import_chalk6.default.hex(rainbowColors[1])("\u2588\u2580\u2588"), char2_1 = import_chalk6.default.hex(rainbowColors[2])("\u2588\u2580\u2584\u2580\u2588"), char2_2 = import_chalk6.default.hex(rainbowColors[2])("\u2588 \u2580 \u2588"), char3_1 = import_chalk6.default.hex(rainbowColors[3])("\u2584\u2580\u2588"), char3_2 = import_chalk6.default.hex(rainbowColors[3])("\u2588\u2580\u2588"), char4_1 = import_chalk6.default.hex(rainbowColors[4])("\u2588\u2580\u2580"), char4_2 = import_chalk6.default.hex(rainbowColors[4])("\u2588\u2584\u2588"), char5_1 = import_chalk6.default.hex(rainbowColors[5])("\u2588 \u2588"), char5_2 = import_chalk6.default.hex(rainbowColors[5])("\u2588\u2584\u2588"), char6_1 = import_chalk6.default.hex(rainbowColors[6])("\u2588"), char6_2 = import_chalk6.default.hex(rainbowColors[6])("\u2588");
  return "".concat(char0_1, "\u2003").concat(char1_1, "\u2003").concat(char2_1, "\u2003").concat(char3_1, "\u2003").concat(char4_1, "\u2003").concat(char5_1, "\u2003").concat(char6_1, `
`).concat(char0_2, "\u2003").concat(char1_2, "\u2003").concat(char2_2, "\u2003").concat(char3_2, "\u2003").concat(char4_2, "\u2003").concat(char5_2, "\u2003").concat(char6_2, `
`);
}(), takeoutAsciiArt = `\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557
\u255A\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2588\u2588\u2554\u255D\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u255A\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255D
\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2550\u255D\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591
\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u2550\u2550\u255D\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591
\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255A\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255A\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591
\u2591\u2591\u2591\u255A\u2550\u255D\u2591\u2591\u2591\u255A\u2550\u255D\u2591\u2591\u255A\u2550\u255D\u255A\u2550\u255D\u2591\u2591\u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u2591\u255A\u2550\u2550\u2550\u2550\u255D\u2591\u2591\u255A\u2550\u2550\u2550\u2550\u2550\u255D\u2591\u2591\u2591\u2591\u255A\u2550\u255D\u2591\u2591\u2591`, tamaguiDuckAsciiArt = `        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588          
      \u2588\u2588            \u2588\u2588        
    \u2588\u2588            \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  
  \u2588\u2588        \u2588\u2588              \u2588\u2588
  \u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588
  \u2588\u2588                        \u2588\u2588
  \u2588\u2588                    \u2588\u2588\u2588\u2588  
\u2588\u2588                    \u2588\u2588      
\u2588\u2588                    \u2588\u2588      `;

// src/helpers/cloneStarter.ts
var import_child_process = require("child_process"), import_os2 = require("os"), import_path8 = require("path"), import_chalk7 = __toESM(require_source()), import_fs_extra = __toESM(require_lib());

// ../../node_modules/rimraf/dist/mjs/opt-arg.js
function _define_property6(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _object_spread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property6(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props3(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null)
    return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
var optArgT = function(opt) {
  assertRimrafOptions(opt);
  var glob2 = opt.glob, options = _object_without_properties(opt, [
    "glob"
  ]);
  if (!glob2)
    return options;
  var globOpt = glob2 === !0 ? opt.signal ? {
    signal: opt.signal
  } : {} : opt.signal ? _object_spread6({
    signal: opt.signal
  }, glob2) : glob2;
  return _object_spread_props3(_object_spread6({}, options), {
    glob: _object_spread_props3(_object_spread6({}, globOpt), {
      // always get absolute paths from glob, to ensure
      // that we are referencing the correct thing.
      absolute: !0,
      withFileTypes: !1
    })
  });
}, optArg = function() {
  var opt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return optArgT(opt);
}, optArgSync = function() {
  var opt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return optArgT(opt);
};

// ../../node_modules/rimraf/dist/mjs/path-arg.js
var import_path2 = require("path"), import_util4 = require("util");

// ../../node_modules/rimraf/dist/mjs/platform.js
var platform_default = process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform;

// ../../node_modules/rimraf/dist/mjs/path-arg.js
function _type_of4(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var pathArg = function(path6) {
  var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, type = typeof path6 > "u" ? "undefined" : _type_of4(path6);
  if (type !== "string") {
    var ctor = path6 && type === "object" && path6.constructor, received = ctor && ctor.name ? "an instance of ".concat(ctor.name) : type === "object" ? (0, import_util4.inspect)(path6) : "type ".concat(type, " ").concat(path6), msg = 'The "path" argument must be of type string. ' + "Received ".concat(received);
    throw Object.assign(new TypeError(msg), {
      path: path6,
      code: "ERR_INVALID_ARG_TYPE"
    });
  }
  if (/\0/.test(path6)) {
    var msg1 = "path must be a string without null bytes";
    throw Object.assign(new TypeError(msg1), {
      path: path6,
      code: "ERR_INVALID_ARG_VALUE"
    });
  }
  path6 = (0, import_path2.resolve)(path6);
  var root = (0, import_path2.parse)(path6).root;
  if (path6 === root && opt.preserveRoot !== !1) {
    var msg2 = "refusing to remove root directory without preserveRoot:false";
    throw Object.assign(new Error(msg2), {
      path: path6,
      code: "ERR_PRESERVE_ROOT"
    });
  }
  if (platform_default === "win32") {
    var badWinChars = /[*|"<>?:]/, root1 = (0, import_path2.parse)(path6).root;
    if (badWinChars.test(path6.substring(root1.length)))
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path6,
        code: "EINVAL"
      });
  }
  return path6;
}, path_arg_default = pathArg;

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 65536, assertValidPattern = function(pattern) {
  if (typeof pattern != "string")
    throw new TypeError("invalid pattern");
  if (pattern.length > MAX_PATTERN_LENGTH)
    throw new TypeError("pattern is too long");
};

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/brace-expressions.js
function _array_like_to_array7(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes6(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterable_to_array_limit6(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array6(arr, i) {
  return _array_with_holes6(arr) || _iterable_to_array_limit6(arr, i) || _unsupported_iterable_to_array7(arr, i) || _non_iterable_rest6();
}
function _unsupported_iterable_to_array7(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array7(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array7(o, minLen);
  }
}
var posixClasses = {
  "[:alnum:]": [
    "\\p{L}\\p{Nl}\\p{Nd}",
    !0
  ],
  "[:alpha:]": [
    "\\p{L}\\p{Nl}",
    !0
  ],
  "[:ascii:]": [
    "\\x00-\\x7f",
    !1
  ],
  "[:blank:]": [
    "\\p{Zs}\\t",
    !0
  ],
  "[:cntrl:]": [
    "\\p{Cc}",
    !0
  ],
  "[:digit:]": [
    "\\p{Nd}",
    !0
  ],
  "[:graph:]": [
    "\\p{Z}\\p{C}",
    !0,
    !0
  ],
  "[:lower:]": [
    "\\p{Ll}",
    !0
  ],
  "[:print:]": [
    "\\p{C}",
    !0
  ],
  "[:punct:]": [
    "\\p{P}",
    !0
  ],
  "[:space:]": [
    "\\p{Z}\\t\\r\\n\\v\\f",
    !0
  ],
  "[:upper:]": [
    "\\p{Lu}",
    !0
  ],
  "[:word:]": [
    "\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}",
    !0
  ],
  "[:xdigit:]": [
    "A-Fa-f0-9",
    !1
  ]
}, braceEscape = function(s) {
  return s.replace(/[[\]\\-]/g, "\\$&");
}, regexpEscape = function(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}, rangesToString = function(ranges) {
  return ranges.join("");
}, parseClass = function(glob2, position) {
  var pos = position;
  if (glob2.charAt(pos) !== "[")
    throw new Error("not in a brace expression");
  var ranges = [], negs = [], i = pos + 1, sawStart = !1, uflag = !1, escaping = !1, negate = !1, endPos = pos, rangeStart = "";
  WHILE:
    for (; i < glob2.length; ) {
      var c = glob2.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = !0, i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      if (sawStart = !0, c === "\\" && !escaping) {
        escaping = !0, i++;
        continue;
      }
      if (c === "[" && !escaping) {
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = Object.entries(posixClasses)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array6(_step.value, 2), cls = _step_value[0], _step_value_ = _sliced_to_array6(_step_value[1], 3), unip = _step_value_[0], u = _step_value_[1], neg = _step_value_[2];
            if (glob2.startsWith(cls, i)) {
              if (rangeStart)
                return [
                  "$.",
                  !1,
                  glob2.length - pos,
                  !0
                ];
              i += cls.length, neg ? negs.push(unip) : ranges.push(unip), uflag = uflag || u;
              continue WHILE;
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
      if (escaping = !1, rangeStart) {
        c > rangeStart ? ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c)) : c === rangeStart && ranges.push(braceEscape(c)), rangeStart = "", i++;
        continue;
      }
      if (glob2.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-")), i += 2;
        continue;
      }
      if (glob2.startsWith("-", i + 1)) {
        rangeStart = c, i += 2;
        continue;
      }
      ranges.push(braceEscape(c)), i++;
    }
  if (endPos < i)
    return [
      "",
      !1,
      0,
      !1
    ];
  if (!ranges.length && !negs.length)
    return [
      "$.",
      !1,
      glob2.length - pos,
      !0
    ];
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    var r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [
      regexpEscape(r),
      !1,
      endPos - pos,
      !1
    ];
  }
  var sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]", snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]", comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [
    comb,
    uflag,
    endPos - pos,
    !0
  ];
};

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/unescape.js
var unescape = function(s) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref_windowsPathsNoEscape = _ref.windowsPathsNoEscape, windowsPathsNoEscape = _ref_windowsPathsNoEscape === void 0 ? !1 : _ref_windowsPathsNoEscape;
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/ast.js
function _array_like_to_array8(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes7(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes5(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array8(arr);
}
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _class_apply_descriptor_get(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _class_call_check4(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap), privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  return _class_apply_descriptor_set(receiver, descriptor, value), value;
}
function _class_private_method_get(receiver, privateSet, fn) {
  if (!privateSet.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return fn;
}
function _class_private_method_init(obj, privateSet) {
  _check_private_redeclaration(obj, privateSet), privateSet.add(obj);
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class2(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties2(Constructor.prototype, protoProps), staticProps && _defineProperties2(Constructor, staticProps), Constructor;
}
function _define_property7(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _instanceof3(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array5(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit7(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array7(arr, i) {
  return _array_with_holes7(arr) || _iterable_to_array_limit7(arr, i) || _unsupported_iterable_to_array8(arr, i) || _non_iterable_rest7();
}
function _to_consumable_array5(arr) {
  return _array_without_holes5(arr) || _iterable_to_array5(arr) || _unsupported_iterable_to_array8(arr) || _non_iterable_spread5();
}
function _unsupported_iterable_to_array8(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array8(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array8(o, minLen);
  }
}
function _class_static_private_method_get(receiver, classConstructor, method) {
  return _class_check_private_static_access(receiver, classConstructor), method;
}
function _class_check_private_static_access(receiver, classConstructor) {
  if (receiver !== classConstructor)
    throw new TypeError("Private static access of wrong provenance");
}
var types = /* @__PURE__ */ new Set([
  "!",
  "?",
  "+",
  "*",
  "@"
]), isExtglobType = function(c) {
  return types.has(c);
}, startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))", startNoDot = "(?!\\.)", addPatternStart = /* @__PURE__ */ new Set([
  "[",
  "."
]), justDots = /* @__PURE__ */ new Set([
  "..",
  "."
]), reSpecials = new Set("().*{}+?[]^$\\!"), regExpEscape = function(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}, qmark = "[^/]", star = qmark + "*?", starNoEmpty = qmark + "+?", _root = /* @__PURE__ */ new WeakMap(), _hasMagic = /* @__PURE__ */ new WeakMap(), _uflag = /* @__PURE__ */ new WeakMap(), _parts = /* @__PURE__ */ new WeakMap(), _parent = /* @__PURE__ */ new WeakMap(), _parentIndex = /* @__PURE__ */ new WeakMap(), _negs = /* @__PURE__ */ new WeakMap(), _filledNegs = /* @__PURE__ */ new WeakMap(), _options = /* @__PURE__ */ new WeakMap(), _toString = /* @__PURE__ */ new WeakMap(), _emptyExt = /* @__PURE__ */ new WeakMap(), _fillNegs = /* @__PURE__ */ new WeakSet(), _partsToRegExp = /* @__PURE__ */ new WeakSet(), AST = /* @__PURE__ */ function() {
  "use strict";
  function AST2(type, parent) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _class_call_check4(this, AST2);
    var _$_class_private_field_get, _$_class_private_field_get1, _$_class_private_field_get2, _$_class_private_field_get3, _$_class_private_field_get4;
    _class_private_method_init(this, _fillNegs), _class_private_method_init(this, _partsToRegExp), _define_property7(this, "type", void 0), _class_private_field_init(this, _root, {
      writable: !0,
      value: void 0
    }), _class_private_field_init(this, _hasMagic, {
      writable: !0,
      value: void 0
    }), _class_private_field_init(this, _uflag, {
      writable: !0,
      value: !1
    }), _class_private_field_init(this, _parts, {
      writable: !0,
      value: []
    }), _class_private_field_init(this, _parent, {
      writable: !0,
      value: void 0
    }), _class_private_field_init(this, _parentIndex, {
      writable: !0,
      value: void 0
    }), _class_private_field_init(this, _negs, {
      writable: !0,
      value: void 0
    }), _class_private_field_init(this, _filledNegs, {
      writable: !0,
      value: !1
    }), _class_private_field_init(this, _options, {
      writable: !0,
      value: void 0
    }), _class_private_field_init(this, _toString, {
      writable: !0,
      value: void 0
    }), _class_private_field_init(this, _emptyExt, {
      writable: !0,
      value: !1
    }), this.type = type, type && _class_private_field_set(this, _hasMagic, !0), _class_private_field_set(this, _parent, parent), _class_private_field_set(this, _root, _class_private_field_get(this, _parent) ? _class_private_field_get(_$_class_private_field_get = _class_private_field_get(this, _parent), _root) : this), _class_private_field_set(this, _options, _class_private_field_get(this, _root) === this ? options : _class_private_field_get(_$_class_private_field_get1 = _class_private_field_get(this, _root), _options)), _class_private_field_set(this, _negs, _class_private_field_get(this, _root) === this ? [] : _class_private_field_get(_$_class_private_field_get2 = _class_private_field_get(this, _root), _negs)), type === "!" && !_class_private_field_get(_$_class_private_field_get3 = _class_private_field_get(this, _root), _filledNegs) && _class_private_field_get(this, _negs).push(this), _class_private_field_set(this, _parentIndex, _class_private_field_get(this, _parent) ? _class_private_field_get(_$_class_private_field_get4 = _class_private_field_get(this, _parent), _parts).length : 0);
  }
  return _create_class2(AST2, [
    {
      key: "hasMagic",
      get: function() {
        if (_class_private_field_get(this, _hasMagic) !== void 0)
          return _class_private_field_get(this, _hasMagic);
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_field_get(this, _parts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var p = _step.value;
            if (typeof p != "string" && (p.type || p.hasMagic))
              return _class_private_field_set(this, _hasMagic, !0);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return _class_private_field_get(this, _hasMagic);
      }
    },
    {
      // reconstructs the pattern
      key: "toString",
      value: function() {
        return _class_private_field_get(this, _toString) !== void 0 ? _class_private_field_get(this, _toString) : this.type ? _class_private_field_set(this, _toString, this.type + "(" + _class_private_field_get(this, _parts).map(function(p) {
          return String(p);
        }).join("|") + ")") : _class_private_field_set(this, _toString, _class_private_field_get(this, _parts).map(function(p) {
          return String(p);
        }).join(""));
      }
    },
    {
      key: "push",
      value: function() {
        for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++)
          parts[_key] = arguments[_key];
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var p = _step.value;
            if (p !== "") {
              if (typeof p != "string" && !(_instanceof3(p, AST2) && _class_private_field_get(p, _parent) === this))
                throw new Error("invalid part: " + p);
              _class_private_field_get(this, _parts).push(p);
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
    },
    {
      key: "toJSON",
      value: function() {
        var _$_class_private_field_get, _$_class_private_field_get1, ret = this.type === null ? _class_private_field_get(this, _parts).slice().map(function(p) {
          return typeof p == "string" ? p : p.toJSON();
        }) : [
          this.type
        ].concat(_to_consumable_array5(_class_private_field_get(this, _parts).map(function(p) {
          return p.toJSON();
        })));
        return this.isStart() && !this.type && ret.unshift([]), this.isEnd() && (this === _class_private_field_get(this, _root) || _class_private_field_get(_$_class_private_field_get1 = _class_private_field_get(this, _root), _filledNegs) && ((_$_class_private_field_get = _class_private_field_get(this, _parent)) === null || _$_class_private_field_get === void 0 ? void 0 : _$_class_private_field_get.type) === "!") && ret.push({}), ret;
      }
    },
    {
      key: "isStart",
      value: function() {
        var _$_class_private_field_get;
        if (_class_private_field_get(this, _root) === this)
          return !0;
        if (!(!((_$_class_private_field_get = _class_private_field_get(this, _parent)) === null || _$_class_private_field_get === void 0) && _$_class_private_field_get.isStart()))
          return !1;
        if (_class_private_field_get(this, _parentIndex) === 0)
          return !0;
        for (var p = _class_private_field_get(this, _parent), i = 0; i < _class_private_field_get(this, _parentIndex); i++) {
          var pp = _class_private_field_get(p, _parts)[i];
          if (!(_instanceof3(pp, AST2) && pp.type === "!"))
            return !1;
        }
        return !0;
      }
    },
    {
      key: "isEnd",
      value: function() {
        var _$_class_private_field_get, _$_class_private_field_get1, _$_class_private_field_get2, _$_class_private_field_get3;
        if (_class_private_field_get(this, _root) === this || ((_$_class_private_field_get = _class_private_field_get(this, _parent)) === null || _$_class_private_field_get === void 0 ? void 0 : _$_class_private_field_get.type) === "!")
          return !0;
        if (!(!((_$_class_private_field_get1 = _class_private_field_get(this, _parent)) === null || _$_class_private_field_get1 === void 0) && _$_class_private_field_get1.isEnd()))
          return !1;
        if (!this.type)
          return (_$_class_private_field_get2 = _class_private_field_get(this, _parent)) === null || _$_class_private_field_get2 === void 0 ? void 0 : _$_class_private_field_get2.isEnd();
        var pl = _class_private_field_get(this, _parent) ? _class_private_field_get(_$_class_private_field_get3 = _class_private_field_get(this, _parent), _parts).length : 0;
        return _class_private_field_get(this, _parentIndex) === pl - 1;
      }
    },
    {
      key: "copyIn",
      value: function(part) {
        typeof part == "string" ? this.push(part) : this.push(part.clone(this));
      }
    },
    {
      key: "clone",
      value: function(parent) {
        var c = new AST2(this.type, parent), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_field_get(this, _parts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var p = _step.value;
            c.copyIn(p);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return c;
      }
    },
    {
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      key: "toMMPattern",
      value: function() {
        if (this !== _class_private_field_get(this, _root))
          return _class_private_field_get(this, _root).toMMPattern();
        var glob2 = this.toString(), _this_toRegExpSource = _sliced_to_array7(this.toRegExpSource(), 4), re = _this_toRegExpSource[0], body = _this_toRegExpSource[1], hasMagic2 = _this_toRegExpSource[2], uflag = _this_toRegExpSource[3], anyMagic = hasMagic2 || _class_private_field_get(this, _hasMagic) || _class_private_field_get(this, _options).nocase && !_class_private_field_get(this, _options).nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
        if (!anyMagic)
          return body;
        var flags = (_class_private_field_get(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp("^".concat(re, "$"), flags), {
          _src: re,
          _glob: glob2
        });
      }
    },
    {
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      key: "toRegExpSource",
      value: function(allowDot) {
        var _this = this, _$_class_private_field_get, dot = allowDot ?? !!_class_private_field_get(this, _options).dot;
        if (_class_private_field_get(this, _root) === this && _class_private_method_get(this, _fillNegs, fillNegs).call(this), !this.type) {
          var _$_class_private_field_get1, noEmpty = this.isStart() && this.isEnd(), src = _class_private_field_get(this, _parts).map(function(p) {
            var _ref = _sliced_to_array7(typeof p == "string" ? _class_static_private_method_get(AST2, AST2, parseGlob).call(AST2, p, _class_private_field_get(_this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot), 4), re = _ref[0], _ = _ref[1], hasMagic2 = _ref[2], uflag = _ref[3];
            return _class_private_field_set(_this, _hasMagic, _class_private_field_get(_this, _hasMagic) || hasMagic2), _class_private_field_set(_this, _uflag, _class_private_field_get(_this, _uflag) || uflag), re;
          }).join(""), start = "";
          if (this.isStart() && typeof _class_private_field_get(this, _parts)[0] == "string") {
            var dotTravAllowed = _class_private_field_get(this, _parts).length === 1 && justDots.has(_class_private_field_get(this, _parts)[0]);
            if (!dotTravAllowed) {
              var aps = addPatternStart, needNoTrav = (
                // dots are allowed, and the pattern starts with [ or .
                dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                src.startsWith("\\.\\.") && aps.has(src.charAt(4))
              ), needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
          var end = "";
          this.isEnd() && _class_private_field_get(_$_class_private_field_get = _class_private_field_get(this, _root), _filledNegs) && ((_$_class_private_field_get1 = _class_private_field_get(this, _parent)) === null || _$_class_private_field_get1 === void 0 ? void 0 : _$_class_private_field_get1.type) === "!" && (end = "(?:$|\\/)");
          var final = start + src + end;
          return [
            final,
            unescape(src),
            _class_private_field_set(this, _hasMagic, !!_class_private_field_get(this, _hasMagic)),
            _class_private_field_get(this, _uflag)
          ];
        }
        var repeated = this.type === "*" || this.type === "+", start1 = this.type === "!" ? "(?:(?!(?:" : "(?:", body = _class_private_method_get(this, _partsToRegExp, partsToRegExp).call(this, dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          var s = this.toString();
          return _class_private_field_set(this, _parts, [
            s
          ]), this.type = null, _class_private_field_set(this, _hasMagic, void 0), [
            s,
            unescape(this.toString()),
            !1,
            !1
          ];
        }
        var bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : _class_private_method_get(this, _partsToRegExp, partsToRegExp).call(this, !0);
        bodyDotAllowed === body && (bodyDotAllowed = ""), bodyDotAllowed && (body = "(?:".concat(body, ")(?:").concat(bodyDotAllowed, ")*?"));
        var final1 = "";
        if (this.type === "!" && _class_private_field_get(this, _emptyExt))
          final1 = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        else {
          var close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : ")".concat(this.type);
          final1 = start1 + body + close;
        }
        return [
          final1,
          unescape(body),
          _class_private_field_set(this, _hasMagic, !!_class_private_field_get(this, _hasMagic)),
          _class_private_field_get(this, _uflag)
        ];
      }
    }
  ], [
    {
      key: "fromGlob",
      value: function(pattern) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ast = new AST2(null, void 0, options);
        return _class_static_private_method_get(AST2, AST2, parseAST).call(AST2, pattern, ast, 0, options), ast;
      }
    }
  ]), AST2;
}();
function fillNegs() {
  if (this !== _class_private_field_get(this, _root))
    throw new Error("should only call on root");
  if (_class_private_field_get(this, _filledNegs))
    return this;
  this.toString(), _class_private_field_set(this, _filledNegs, !0);
  for (var n; n = _class_private_field_get(this, _negs).pop(); )
    if (n.type === "!")
      for (var p = n, pp = _class_private_field_get(p, _parent); pp; ) {
        for (var i = _class_private_field_get(p, _parentIndex) + 1; !pp.type && i < _class_private_field_get(pp, _parts).length; i++) {
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = _class_private_field_get(n, _parts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var part = _step.value;
              if (typeof part == "string")
                throw new Error("string part in extglob AST??");
              part.copyIn(_class_private_field_get(pp, _parts)[i]);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        }
        p = pp, pp = _class_private_field_get(p, _parent);
      }
  return this;
}
function parseAST(str, ast, pos, opt) {
  var escaping = !1, inBrace = !1, braceStart = -1, braceNeg = !1;
  if (ast.type === null) {
    for (var i = pos, acc = ""; i < str.length; ) {
      var c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping, acc += c;
        continue;
      }
      if (inBrace) {
        i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
        continue;
      } else if (c === "[") {
        inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
        continue;
      }
      if (!opt.noext && isExtglobType(c) && str.charAt(i) === "(") {
        ast.push(acc), acc = "";
        var ext2 = new AST(c, ast);
        i = _class_static_private_method_get(AST, AST, parseAST).call(AST, str, ext2, i, opt), ast.push(ext2);
        continue;
      }
      acc += c;
    }
    return ast.push(acc), i;
  }
  for (var i1 = pos + 1, part = new AST(null, ast), parts = [], acc1 = ""; i1 < str.length; ) {
    var c1 = str.charAt(i1++);
    if (escaping || c1 === "\\") {
      escaping = !escaping, acc1 += c1;
      continue;
    }
    if (inBrace) {
      i1 === braceStart + 1 ? (c1 === "^" || c1 === "!") && (braceNeg = !0) : c1 === "]" && !(i1 === braceStart + 2 && braceNeg) && (inBrace = !1), acc1 += c1;
      continue;
    } else if (c1 === "[") {
      inBrace = !0, braceStart = i1, braceNeg = !1, acc1 += c1;
      continue;
    }
    if (isExtglobType(c1) && str.charAt(i1) === "(") {
      part.push(acc1), acc1 = "";
      var ext1 = new AST(c1, part);
      part.push(ext1), i1 = _class_static_private_method_get(AST, AST, parseAST).call(AST, str, ext1, i1, opt);
      continue;
    }
    if (c1 === "|") {
      part.push(acc1), acc1 = "", parts.push(part), part = new AST(null, ast);
      continue;
    }
    if (c1 === ")") {
      var _ast;
      return acc1 === "" && _class_private_field_get(ast, _parts).length === 0 && _class_private_field_set(ast, _emptyExt, !0), part.push(acc1), acc1 = "", (_ast = ast).push.apply(_ast, _to_consumable_array5(parts).concat([
        part
      ])), i1;
    }
    acc1 += c1;
  }
  return ast.type = null, _class_private_field_set(ast, _hasMagic, void 0), _class_private_field_set(ast, _parts, [
    str.substring(pos - 1)
  ]), i1;
}
function partsToRegExp(dot) {
  var _this = this;
  return _class_private_field_get(this, _parts).map(function(p) {
    if (typeof p == "string")
      throw new Error("string type in extglob ast??");
    var _p_toRegExpSource = _sliced_to_array7(p.toRegExpSource(dot), 4), re = _p_toRegExpSource[0], _ = _p_toRegExpSource[1], _hasMagic2 = _p_toRegExpSource[2], uflag = _p_toRegExpSource[3];
    return _class_private_field_set(_this, _uflag, _class_private_field_get(_this, _uflag) || uflag), re;
  }).filter(function(p) {
    return !(_this.isStart() && _this.isEnd()) || !!p;
  }).join("|");
}
function parseGlob(glob2, hasMagic2) {
  for (var noEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, escaping = !1, re = "", uflag = !1, i = 0; i < glob2.length; i++) {
    var c = glob2.charAt(i);
    if (escaping) {
      escaping = !1, re += (reSpecials.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      i === glob2.length - 1 ? re += "\\\\" : escaping = !0;
      continue;
    }
    if (c === "[") {
      var _parseClass = _sliced_to_array7(parseClass(glob2, i), 4), src = _parseClass[0], needUflag = _parseClass[1], consumed = _parseClass[2], magic = _parseClass[3];
      if (consumed) {
        re += src, uflag = uflag || needUflag, i += consumed - 1, hasMagic2 = hasMagic2 || magic;
        continue;
      }
    }
    if (c === "*") {
      noEmpty && glob2 === "*" ? re += starNoEmpty : re += star, hasMagic2 = !0;
      continue;
    }
    if (c === "?") {
      re += qmark, hasMagic2 = !0;
      continue;
    }
    re += regExpEscape(c);
  }
  return [
    re,
    unescape(glob2),
    !!hasMagic2,
    uflag
  ];
}

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/escape.js
var escape = function(s) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref_windowsPathsNoEscape = _ref.windowsPathsNoEscape, windowsPathsNoEscape = _ref_windowsPathsNoEscape === void 0 ? !1 : _ref_windowsPathsNoEscape;
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/index.js
function _array_like_to_array9(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes8(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes6(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array9(arr);
}
function _assert_this_initialized4(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function _class_call_check5(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class3(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties3(Constructor.prototype, protoProps), staticProps && _defineProperties3(Constructor, staticProps), Constructor;
}
function _define_property8(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _get_prototype_of4(o) {
  return _get_prototype_of4 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of4(o);
}
function _inherits4(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of4(subClass, superClass);
}
function _instanceof4(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array6(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit8(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return4(self, call) {
  return call && (_type_of5(call) === "object" || typeof call == "function") ? call : _assert_this_initialized4(self);
}
function _set_prototype_of4(o, p) {
  return _set_prototype_of4 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of4(o, p);
}
function _sliced_to_array8(arr, i) {
  return _array_with_holes8(arr) || _iterable_to_array_limit8(arr, i) || _unsupported_iterable_to_array9(arr, i) || _non_iterable_rest8();
}
function _to_consumable_array6(arr) {
  return _array_without_holes6(arr) || _iterable_to_array6(arr) || _unsupported_iterable_to_array9(arr) || _non_iterable_spread6();
}
function _type_of5(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array9(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array9(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array9(o, minLen);
  }
}
function _is_native_reflect_construct4() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super4(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct4();
  return function() {
    var Super = _get_prototype_of4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return4(this, result);
  };
}
var minimatch = function(p, pattern) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options).match(p);
}, starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/, starDotExtTest = function(ext2) {
  return function(f) {
    return !f.startsWith(".") && f.endsWith(ext2);
  };
}, starDotExtTestDot = function(ext2) {
  return function(f) {
    return f.endsWith(ext2);
  };
}, starDotExtTestNocase = function(ext2) {
  return ext2 = ext2.toLowerCase(), function(f) {
    return !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
  };
}, starDotExtTestNocaseDot = function(ext2) {
  return ext2 = ext2.toLowerCase(), function(f) {
    return f.toLowerCase().endsWith(ext2);
  };
}, starDotStarRE = /^\*+\.\*+$/, starDotStarTest = function(f) {
  return !f.startsWith(".") && f.includes(".");
}, starDotStarTestDot = function(f) {
  return f !== "." && f !== ".." && f.includes(".");
}, dotStarRE = /^\.\*+$/, dotStarTest = function(f) {
  return f !== "." && f !== ".." && f.startsWith(".");
}, starRE = /^\*+$/, starTest = function(f) {
  return f.length !== 0 && !f.startsWith(".");
}, starTestDot = function(f) {
  return f.length !== 0 && f !== "." && f !== "..";
}, qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/, qmarksTestNocase = function(param) {
  var _param = _sliced_to_array8(param, 2), $0 = _param[0], tmp = _param[1], ext2 = tmp === void 0 ? "" : tmp, noext = qmarksTestNoExt([
    $0
  ]);
  return ext2 ? (ext2 = ext2.toLowerCase(), function(f) {
    return noext(f) && f.toLowerCase().endsWith(ext2);
  }) : noext;
}, qmarksTestNocaseDot = function(param) {
  var _param = _sliced_to_array8(param, 2), $0 = _param[0], tmp = _param[1], ext2 = tmp === void 0 ? "" : tmp, noext = qmarksTestNoExtDot([
    $0
  ]);
  return ext2 ? (ext2 = ext2.toLowerCase(), function(f) {
    return noext(f) && f.toLowerCase().endsWith(ext2);
  }) : noext;
}, qmarksTestDot = function(param) {
  var _param = _sliced_to_array8(param, 2), $0 = _param[0], tmp = _param[1], ext2 = tmp === void 0 ? "" : tmp, noext = qmarksTestNoExtDot([
    $0
  ]);
  return ext2 ? function(f) {
    return noext(f) && f.endsWith(ext2);
  } : noext;
}, qmarksTest = function(param) {
  var _param = _sliced_to_array8(param, 2), $0 = _param[0], tmp = _param[1], ext2 = tmp === void 0 ? "" : tmp, noext = qmarksTestNoExt([
    $0
  ]);
  return ext2 ? function(f) {
    return noext(f) && f.endsWith(ext2);
  } : noext;
}, qmarksTestNoExt = function(param) {
  var _param = _sliced_to_array8(param, 1), $0 = _param[0], len = $0.length;
  return function(f) {
    return f.length === len && !f.startsWith(".");
  };
}, qmarksTestNoExtDot = function(param) {
  var _param = _sliced_to_array8(param, 1), $0 = _param[0], len = $0.length;
  return function(f) {
    return f.length === len && f !== "." && f !== "..";
  };
}, defaultPlatform = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", path2 = {
  win32: {
    sep: "\\"
  },
  posix: {
    sep: "/"
  }
}, sep = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]", star2 = qmark2 + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", filter = function(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function(p) {
    return minimatch(p, pattern, options);
  };
};
minimatch.filter = filter;
var ext = function(a) {
  var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.assign({}, a, b);
}, defaults2 = function(def) {
  if (!def || typeof def != "object" || !Object.keys(def).length)
    return minimatch;
  var orig = minimatch, m = function(p, pattern) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return orig(p, pattern, ext(def, options));
  };
  return Object.assign(m, {
    Minimatch: /* @__PURE__ */ function(_orig_Minimatch) {
      "use strict";
      _inherits4(Minimatch2, _orig_Minimatch);
      var _super = _create_super4(Minimatch2);
      function Minimatch2(pattern) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return _class_call_check5(this, Minimatch2), _super.call(this, pattern, ext(def, options));
      }
      return _create_class3(Minimatch2, null, [
        {
          key: "defaults",
          value: function(options) {
            return orig.defaults(ext(def, options)).Minimatch;
          }
        }
      ]), Minimatch2;
    }(orig.Minimatch),
    AST: /* @__PURE__ */ function(_orig_AST) {
      "use strict";
      _inherits4(AST2, _orig_AST);
      var _super = _create_super4(AST2);
      function AST2(type, parent) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return _class_call_check5(this, AST2), _super.call(this, type, parent, ext(def, options));
      }
      return _create_class3(AST2, null, [
        {
          key: "fromGlob",
          value: (
            /* c8 ignore stop */
            function(pattern) {
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return orig.AST.fromGlob(pattern, ext(def, options));
            }
          )
        }
      ]), AST2;
    }(orig.AST),
    unescape: function(s) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return orig.unescape(s, ext(def, options));
    },
    escape: function(s) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return orig.escape(s, ext(def, options));
    },
    filter: function(pattern) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return orig.filter(pattern, ext(def, options));
    },
    defaults: function(options) {
      return orig.defaults(ext(def, options));
    },
    makeRe: function(pattern) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return orig.makeRe(pattern, ext(def, options));
    },
    braceExpand: function(pattern) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return orig.braceExpand(pattern, ext(def, options));
    },
    match: function(list, pattern) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return orig.match(list, pattern, ext(def, options));
    },
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults2;
var braceExpand = function(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [
    pattern
  ] : (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = function(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Minimatch(pattern, options).makeRe();
};
minimatch.makeRe = makeRe;
var match = function(list, pattern) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, mm = new Minimatch(pattern, options);
  return list = list.filter(function(f) {
    return mm.match(f);
  }), mm.options.nonull && !list.length && list.push(pattern), list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/, regExpEscape2 = function(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}, Minimatch = /* @__PURE__ */ function() {
  "use strict";
  function Minimatch2(pattern) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _class_call_check5(this, Minimatch2), _define_property8(this, "options", void 0), _define_property8(this, "set", void 0), _define_property8(this, "pattern", void 0), _define_property8(this, "windowsPathsNoEscape", void 0), _define_property8(this, "nonegate", void 0), _define_property8(this, "negate", void 0), _define_property8(this, "comment", void 0), _define_property8(this, "empty", void 0), _define_property8(this, "preserveMultipleSlashes", void 0), _define_property8(this, "partial", void 0), _define_property8(this, "globSet", void 0), _define_property8(this, "globParts", void 0), _define_property8(this, "nocase", void 0), _define_property8(this, "isWindows", void 0), _define_property8(this, "platform", void 0), _define_property8(this, "windowsNoMagicRoot", void 0), _define_property8(this, "regexp", void 0), assertValidPattern(pattern), options = options || {}, this.options = options, this.pattern = pattern, this.platform = options.platform || defaultPlatform, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!options.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
  }
  return _create_class3(Minimatch2, [
    {
      key: "hasMagic",
      value: function() {
        if (this.options.magicalBraces && this.set.length > 1)
          return !0;
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = this.set[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var pattern = _step.value, _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
            try {
              for (var _iterator1 = pattern[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                var part = _step1.value;
                if (typeof part != "string")
                  return !0;
              }
            } catch (err) {
              _didIteratorError12 = !0, _iteratorError12 = err;
            } finally {
              try {
                !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return !1;
      }
    },
    {
      key: "debug",
      value: function() {
        for (var _len = arguments.length, _ = new Array(_len), _key = 0; _key < _len; _key++)
          _[_key] = arguments[_key];
      }
    },
    {
      key: "make",
      value: function() {
        var _this = this, pattern = this.pattern, options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = !0;
          return;
        }
        if (!pattern) {
          this.empty = !0;
          return;
        }
        if (this.parseNegate(), this.globSet = _to_consumable_array6(new Set(this.braceExpand())), options.debug) {
          var _console;
          this.debug = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
              args[_key] = arguments[_key];
            return (_console = console).error.apply(_console, _to_consumable_array6(args));
          };
        }
        this.debug(this.pattern, this.globSet);
        var rawGlobParts = this.globSet.map(function(s) {
          return _this.slashSplit(s);
        });
        this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
        var set3 = this.globParts.map(function(s, _, __) {
          if (_this.isWindows && _this.windowsNoMagicRoot) {
            var isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]), isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC)
              return _to_consumable_array6(s.slice(0, 4)).concat(_to_consumable_array6(s.slice(4).map(function(ss) {
                return _this.parse(ss);
              })));
            if (isDrive)
              return [
                s[0]
              ].concat(_to_consumable_array6(s.slice(1).map(function(ss) {
                return _this.parse(ss);
              })));
          }
          return s.map(function(ss) {
            return _this.parse(ss);
          });
        });
        if (this.debug(this.pattern, set3), this.set = set3.filter(function(s) {
          return s.indexOf(!1) === -1;
        }), this.isWindows)
          for (var i = 0; i < this.set.length; i++) {
            var p = this.set[i];
            p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] == "string" && /^[a-z]:$/i.test(p[3]) && (p[2] = "?");
          }
        this.debug(this.pattern, this.set);
      }
    },
    {
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      key: "preprocess",
      value: function(globParts) {
        if (this.options.noglobstar)
          for (var i = 0; i < globParts.length; i++)
            for (var j = 0; j < globParts[i].length; j++)
              globParts[i][j] === "**" && (globParts[i][j] = "*");
        var _this_options = this.options, _this_options_optimizationLevel = _this_options.optimizationLevel, optimizationLevel = _this_options_optimizationLevel === void 0 ? 1 : _this_options_optimizationLevel;
        return optimizationLevel >= 2 ? (globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts)) : optimizationLevel >= 1 ? globParts = this.levelOneOptimize(globParts) : globParts = this.adjascentGlobstarOptimize(globParts), globParts;
      }
    },
    {
      // just get rid of adjascent ** portions
      key: "adjascentGlobstarOptimize",
      value: function(globParts) {
        return globParts.map(function(parts) {
          for (var gs = -1; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
            for (var i = gs; parts[i + 1] === "**"; )
              i++;
            i !== gs && parts.splice(gs, i - gs);
          }
          return parts;
        });
      }
    },
    {
      // get rid of adjascent ** and resolve .. portions
      key: "levelOneOptimize",
      value: function(globParts) {
        return globParts.map(function(parts) {
          return parts = parts.reduce(function(set3, part) {
            var prev = set3[set3.length - 1];
            return part === "**" && prev === "**" ? set3 : part === ".." && prev && prev !== ".." && prev !== "." && prev !== "**" ? (set3.pop(), set3) : (set3.push(part), set3);
          }, []), parts.length === 0 ? [
            ""
          ] : parts;
        });
      }
    },
    {
      key: "levelTwoFileOptimize",
      value: function(parts) {
        Array.isArray(parts) || (parts = this.slashSplit(parts));
        var didSomething = !1;
        do {
          if (didSomething = !1, !this.preserveMultipleSlashes) {
            for (var i = 1; i < parts.length - 1; i++) {
              var p = parts[i];
              i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
            }
            parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
          }
          for (var dd = 0; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
            var p1 = parts[dd - 1];
            p1 && p1 !== "." && p1 !== ".." && p1 !== "**" && (didSomething = !0, parts.splice(dd - 1, 2), dd -= 2);
          }
        } while (didSomething);
        return parts.length === 0 ? [
          ""
        ] : parts;
      }
    },
    {
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      key: "firstPhasePreProcess",
      value: function(globParts) {
        var didSomething = !1;
        do {
          didSomething = !1;
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = globParts[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              for (var parts = _step.value, gs = -1; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
                for (var gss = gs; parts[gss + 1] === "**"; )
                  gss++;
                gss > gs && parts.splice(gs + 1, gss - gs);
                var next = parts[gs + 1], p = parts[gs + 2], p2 = parts[gs + 3];
                if (next === ".." && !(!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..")) {
                  didSomething = !0, parts.splice(gs, 1);
                  var other = parts.slice(0);
                  other[gs] = "**", globParts.push(other), gs--;
                }
              }
              if (!this.preserveMultipleSlashes) {
                for (var i = 1; i < parts.length - 1; i++) {
                  var p1 = parts[i];
                  i === 1 && p1 === "" && parts[0] === "" || (p1 === "." || p1 === "") && (didSomething = !0, parts.splice(i, 1), i--);
                }
                parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
              }
              for (var dd = 0; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
                var p3 = parts[dd - 1];
                if (p3 && p3 !== "." && p3 !== ".." && p3 !== "**") {
                  var _parts2;
                  didSomething = !0;
                  var needDot = dd === 1 && parts[dd + 1] === "**", splin = needDot ? [
                    "."
                  ] : [];
                  (_parts2 = parts).splice.apply(_parts2, [
                    dd - 1,
                    2
                  ].concat(_to_consumable_array6(splin))), parts.length === 0 && parts.push(""), dd -= 2;
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        } while (didSomething);
        return globParts;
      }
    },
    {
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      key: "secondPhasePreProcess",
      value: function(globParts) {
        for (var i = 0; i < globParts.length - 1; i++)
          for (var j = i + 1; j < globParts.length; j++) {
            var matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            matched && (globParts[i] = matched, globParts[j] = []);
          }
        return globParts.filter(function(gs) {
          return gs.length;
        });
      }
    },
    {
      key: "partsMatch",
      value: function(a, b) {
        for (var emptyGSMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, ai = 0, bi = 0, result = [], which2 = ""; ai < a.length && bi < b.length; )
          if (a[ai] === b[bi])
            result.push(which2 === "b" ? b[bi] : a[ai]), ai++, bi++;
          else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1])
            result.push(a[ai]), ai++;
          else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1])
            result.push(b[bi]), bi++;
          else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which2 === "b")
              return !1;
            which2 = "a", result.push(a[ai]), ai++, bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which2 === "a")
              return !1;
            which2 = "b", result.push(b[bi]), ai++, bi++;
          } else
            return !1;
        return a.length === b.length && result;
      }
    },
    {
      key: "parseNegate",
      value: function() {
        if (!this.nonegate) {
          for (var pattern = this.pattern, negate = !1, negateOffset = 0, i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++)
            negate = !negate, negateOffset++;
          negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
        }
      }
    },
    {
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      key: "matchOne",
      value: function(file, pattern) {
        var partial = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, options = this.options;
        if (this.isWindows) {
          var fileDrive = typeof file[0] == "string" && /^[a-z]:$/i.test(file[0]), fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]), patternDrive = typeof pattern[0] == "string" && /^[a-z]:$/i.test(pattern[0]), patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] == "string" && /^[a-z]:$/i.test(pattern[3]), fdi = fileUNC ? 3 : fileDrive ? 0 : void 0, pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi == "number" && typeof pdi == "number") {
            var _ref = [
              file[fdi],
              pattern[pdi]
            ], fd = _ref[0], pd = _ref[1];
            fd.toLowerCase() === pd.toLowerCase() && (pattern[pdi] = fd, pdi > fdi ? pattern = pattern.slice(pdi) : fdi > pdi && (file = file.slice(fdi)));
          }
        }
        var _this_options = this.options, _this_options_optimizationLevel = _this_options.optimizationLevel, optimizationLevel = _this_options_optimizationLevel === void 0 ? 1 : _this_options_optimizationLevel;
        optimizationLevel >= 2 && (file = this.levelTwoFileOptimize(file)), this.debug("matchOne", this, {
          file,
          pattern
        }), this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi], f = file[fi];
          if (this.debug(pattern, p, f), p === !1)
            return !1;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [
              pattern,
              p,
              f
            ]);
            var fr = fi, pr = pi + 1;
            if (pr === pl) {
              for (this.debug("** at the end"); fi < fl; fi++)
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return !1;
              return !0;
            }
            for (; fr < fl; ) {
              var swallowee = file[fr];
              if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
                return this.debug("globstar found match!", fr, fl, swallowee), !0;
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), fr++;
            }
            return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
          }
          var hit = void 0;
          if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = p.test(f), this.debug("pattern match", p, f, hit)), !hit)
            return !1;
        }
        if (fi === fl && pi === pl)
          return !0;
        if (fi === fl)
          return partial;
        if (pi === pl)
          return fi === fl - 1 && file[fi] === "";
        throw new Error("wtf?");
      }
    },
    {
      /* c8 ignore stop */
      key: "braceExpand",
      value: function() {
        return braceExpand(this.pattern, this.options);
      }
    },
    {
      key: "parse",
      value: function(pattern) {
        assertValidPattern(pattern);
        var options = this.options;
        if (pattern === "**")
          return GLOBSTAR;
        if (pattern === "")
          return "";
        var m, fastTest = null;
        (m = pattern.match(starRE)) ? fastTest = options.dot ? starTestDot : starTest : (m = pattern.match(starDotExtRE)) ? fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]) : (m = pattern.match(qmarksRE)) ? fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m) : (m = pattern.match(starDotStarRE)) ? fastTest = options.dot ? starDotStarTestDot : starDotStarTest : (m = pattern.match(dotStarRE)) && (fastTest = dotStarTest);
        var re = AST.fromGlob(pattern, this.options).toMMPattern();
        return fastTest ? Object.assign(re, {
          test: fastTest
        }) : re;
      }
    },
    {
      key: "makeRe",
      value: function() {
        if (this.regexp || this.regexp === !1)
          return this.regexp;
        var set3 = this.set;
        if (!set3.length)
          return this.regexp = !1, this.regexp;
        var options = this.options, twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot, flags = new Set(options.nocase ? [
          "i"
        ] : []), re = set3.map(function(pattern) {
          var pp = pattern.map(function(p) {
            if (_instanceof4(p, RegExp)) {
              var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator = p.flags.split("")[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var f = _step.value;
                  flags.add(f);
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
            }
            return typeof p == "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
          });
          return pp.forEach(function(p, i) {
            var next = pp[i + 1], prev = pp[i - 1];
            p !== GLOBSTAR || prev === GLOBSTAR || (prev === void 0 ? next !== void 0 && next !== GLOBSTAR ? pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next : pp[i] = twoStar : next === void 0 ? pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?" : next !== GLOBSTAR && (pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = GLOBSTAR));
          }), pp.filter(function(p) {
            return p !== GLOBSTAR;
          }).join("/");
        }).join("|"), _ref = _sliced_to_array8(set3.length > 1 ? [
          "(?:",
          ")"
        ] : [
          "",
          ""
        ], 2), open3 = _ref[0], close = _ref[1];
        re = "^" + open3 + re + close + "$", this.negate && (re = "^(?!" + re + ").+$");
        try {
          this.regexp = new RegExp(re, _to_consumable_array6(flags).join(""));
        } catch {
          this.regexp = !1;
        }
        return this.regexp;
      }
    },
    {
      key: "slashSplit",
      value: function(p) {
        return this.preserveMultipleSlashes ? p.split("/") : this.isWindows && /^\/\/[^\/]+/.test(p) ? [
          ""
        ].concat(_to_consumable_array6(p.split(/\/+/))) : p.split(/\/+/);
      }
    },
    {
      key: "match",
      value: function(f) {
        var partial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.partial;
        if (this.debug("match", f, this.pattern), this.comment)
          return !1;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return !0;
        var options = this.options;
        this.isWindows && (f = f.split("\\").join("/"));
        var ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        var set3 = this.set;
        this.debug(this.pattern, "set", set3);
        var filename = ff[ff.length - 1];
        if (!filename)
          for (var i = ff.length - 2; !filename && i >= 0; i--)
            filename = ff[i];
        for (var i1 = 0; i1 < set3.length; i1++) {
          var pattern = set3[i1], file = ff;
          options.matchBase && pattern.length === 1 && (file = [
            filename
          ]);
          var hit = this.matchOne(file, pattern, partial);
          if (hit)
            return options.flipNegate ? !0 : !this.negate;
        }
        return options.flipNegate ? !1 : this.negate;
      }
    }
  ], [
    {
      key: "defaults",
      value: function(def) {
        return minimatch.defaults(def).Minimatch;
      }
    }
  ]), Minimatch2;
}();
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../../node_modules/path-scurry/node_modules/lru-cache/dist/mjs/index.js
function _array_like_to_array10(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes9(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes7(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array10(arr);
}
function _assert_this_initialized5(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function asyncGeneratorStep5(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator5(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep5(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep5(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _check_private_redeclaration2(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _class_apply_descriptor_get2(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _class_apply_descriptor_set2(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _class_apply_descriptor_update(receiver, descriptor) {
  if (descriptor.set) {
    if (!descriptor.get)
      throw new TypeError("attempted to read set only private field");
    return "__destrWrapper" in descriptor || (descriptor.__destrWrapper = {
      set value(v) {
        descriptor.set.call(receiver, v);
      },
      get value() {
        return descriptor.get.call(receiver);
      }
    }), descriptor.__destrWrapper;
  } else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    return descriptor;
  }
}
function _class_call_check6(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _class_check_private_static_field_descriptor(descriptor, action) {
  if (descriptor === void 0)
    throw new TypeError("attempted to " + action + " private static field before its declaration");
}
function _class_extract_field_descriptor2(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}
function _class_private_field_get2(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor2(receiver, privateMap, "get");
  return _class_apply_descriptor_get2(receiver, descriptor);
}
function _class_private_field_init2(obj, privateMap, value) {
  _check_private_redeclaration2(obj, privateMap), privateMap.set(obj, value);
}
function _class_private_field_set2(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor2(receiver, privateMap, "set");
  return _class_apply_descriptor_set2(receiver, descriptor, value), value;
}
function _class_private_field_update(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor2(receiver, privateMap, "update");
  return _class_apply_descriptor_update(receiver, descriptor);
}
function _class_private_method_get2(receiver, privateSet, fn) {
  if (!privateSet.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return fn;
}
function _class_private_method_init2(obj, privateSet) {
  _check_private_redeclaration2(obj, privateSet), privateSet.add(obj);
}
function _class_static_private_field_spec_get(receiver, classConstructor, descriptor) {
  return _class_check_private_static_access2(receiver, classConstructor), _class_check_private_static_field_descriptor(descriptor, "get"), _class_apply_descriptor_get2(receiver, descriptor);
}
function _class_static_private_field_spec_set(receiver, classConstructor, descriptor, value) {
  return _class_check_private_static_access2(receiver, classConstructor), _class_check_private_static_field_descriptor(descriptor, "set"), _class_apply_descriptor_set2(receiver, descriptor, value), value;
}
function _construct3(Parent, args, Class) {
  return _is_native_reflect_construct5() ? _construct3 = Reflect.construct : _construct3 = function(Parent2, args2, Class2) {
    var a = [
      null
    ];
    a.push.apply(a, args2);
    var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
    return Class2 && _set_prototype_of5(instance, Class2.prototype), instance;
  }, _construct3.apply(null, arguments);
}
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class4(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties4(Constructor.prototype, protoProps), staticProps && _defineProperties4(Constructor, staticProps), Constructor;
}
function _define_property9(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _get_prototype_of5(o) {
  return _get_prototype_of5 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of5(o);
}
function _inherits5(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of5(subClass, superClass);
}
function _instanceof5(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _is_native_function3(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array7(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit9(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property9(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props4(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _possible_constructor_return5(self, call) {
  return call && (_type_of6(call) === "object" || typeof call == "function") ? call : _assert_this_initialized5(self);
}
function _set_prototype_of5(o, p) {
  return _set_prototype_of5 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of5(o, p);
}
function _sliced_to_array9(arr, i) {
  return _array_with_holes9(arr) || _iterable_to_array_limit9(arr, i) || _unsupported_iterable_to_array10(arr, i) || _non_iterable_rest9();
}
function _to_consumable_array7(arr) {
  return _array_without_holes7(arr) || _iterable_to_array7(arr) || _unsupported_iterable_to_array10(arr) || _non_iterable_spread7();
}
function _type_of6(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array10(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array10(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array10(o, minLen);
  }
}
function _wrap_native_super3(Class) {
  var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return _wrap_native_super3 = function(Class2) {
    if (Class2 === null || !_is_native_function3(Class2))
      return Class2;
    if (typeof Class2 != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof _cache < "u") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct3(Class2, arguments, _get_prototype_of5(this).constructor);
    }
    return Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), _set_prototype_of5(Wrapper, Class2);
  }, _wrap_native_super3(Class);
}
function _class_check_private_static_access2(receiver, classConstructor) {
  if (receiver !== classConstructor)
    throw new TypeError("Private static access of wrong provenance");
}
function _is_native_reflect_construct5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super5(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct5();
  return function() {
    var Super = _get_prototype_of5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return5(this, result);
  };
}
function _ts_generator5(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v1) {
      return step([
        n,
        v1
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, warned = /* @__PURE__ */ new Set(), PROCESS = typeof process == "object" && process ? process : {}, emitWarning = function(msg, type, code, fn) {
  typeof PROCESS.emitWarning == "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error("[".concat(code, "] ").concat(type, ": ").concat(msg));
}, AC = globalThis.AbortController, AS = globalThis.AbortSignal;
typeof AC > "u" && (AS = /* @__PURE__ */ function() {
  "use strict";
  function AbortSignal() {
    _class_call_check6(this, AbortSignal), _define_property9(this, "onabort", void 0), _define_property9(this, "_onabort", []), _define_property9(this, "reason", void 0), _define_property9(this, "aborted", !1);
  }
  return _create_class4(AbortSignal, [
    {
      key: "addEventListener",
      value: function(_, fn) {
        this._onabort.push(fn);
      }
    }
  ]), AbortSignal;
}(), AC = /* @__PURE__ */ function() {
  "use strict";
  function AbortController() {
    _class_call_check6(this, AbortController), _define_property9(this, "signal", new AS()), warnACPolyfill();
  }
  return _create_class4(AbortController, [
    {
      key: "abort",
      value: function(reason) {
        var _this_signal_onabort, _this_signal;
        if (!this.signal.aborted) {
          this.signal.reason = reason, this.signal.aborted = !0;
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = this.signal._onabort[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var fn = _step.value;
              fn(reason);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          (_this_signal_onabort = (_this_signal = this.signal).onabort) === null || _this_signal_onabort === void 0 || _this_signal_onabort.call(_this_signal, reason);
        }
      }
    }
  ]), AbortController;
}(), printACPolyfillWarning = ((_PROCESS_env = PROCESS.env) === null || _PROCESS_env === void 0 ? void 0 : _PROCESS_env.LRU_CACHE_IGNORE_AC_WARNING) !== "1", warnACPolyfill = function() {
  printACPolyfillWarning && (printACPolyfillWarning = !1, emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill));
});
var _PROCESS_env, printACPolyfillWarning, warnACPolyfill, shouldWarn = function(code) {
  return !warned.has(code);
}, TYPE = Symbol("type"), isPosInt = function(n) {
  return n && n === Math.floor(n) && n > 0 && isFinite(n);
}, getUintArray = function(max) {
  return isPosInt(max) ? max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null;
}, ZeroArray = /* @__PURE__ */ function(Array1) {
  "use strict";
  _inherits5(ZeroArray2, Array1);
  var _super = _create_super5(ZeroArray2);
  function ZeroArray2(size) {
    _class_call_check6(this, ZeroArray2);
    var _this;
    return _this = _super.call(this, size), _this.fill(0), _this;
  }
  return ZeroArray2;
}(_wrap_native_super3(Array)), Stack = /* @__PURE__ */ function() {
  "use strict";
  function Stack2(max, HeapCls) {
    if (_class_call_check6(this, Stack2), _define_property9(this, "heap", void 0), _define_property9(this, "length", void 0), !_class_static_private_field_spec_get(Stack2, Stack2, _constructing))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new HeapCls(max), this.length = 0;
  }
  return _create_class4(Stack2, [
    {
      key: "push",
      value: function(n) {
        this.heap[this.length++] = n;
      }
    },
    {
      key: "pop",
      value: function() {
        return this.heap[--this.length];
      }
    }
  ], [
    {
      key: "create",
      value: function(max) {
        var HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _class_static_private_field_spec_set(Stack2, Stack2, _constructing, !0);
        var s = new Stack2(max, HeapCls);
        return _class_static_private_field_spec_set(Stack2, Stack2, _constructing, !1), s;
      }
    }
  ]), Stack2;
}(), _constructing = {
  writable: !0,
  value: !1
}, _max = /* @__PURE__ */ new WeakMap(), _maxSize = /* @__PURE__ */ new WeakMap(), _dispose = /* @__PURE__ */ new WeakMap(), _disposeAfter = /* @__PURE__ */ new WeakMap(), _fetchMethod = /* @__PURE__ */ new WeakMap(), _size = /* @__PURE__ */ new WeakMap(), _calculatedSize = /* @__PURE__ */ new WeakMap(), _keyMap = /* @__PURE__ */ new WeakMap(), _keyList = /* @__PURE__ */ new WeakMap(), _valList = /* @__PURE__ */ new WeakMap(), _next = /* @__PURE__ */ new WeakMap(), _prev = /* @__PURE__ */ new WeakMap(), _head = /* @__PURE__ */ new WeakMap(), _tail = /* @__PURE__ */ new WeakMap(), _free = /* @__PURE__ */ new WeakMap(), _disposed = /* @__PURE__ */ new WeakMap(), _sizes = /* @__PURE__ */ new WeakMap(), _starts = /* @__PURE__ */ new WeakMap(), _ttls = /* @__PURE__ */ new WeakMap(), _hasDispose = /* @__PURE__ */ new WeakMap(), _hasFetchMethod = /* @__PURE__ */ new WeakMap(), _hasDisposeAfter = /* @__PURE__ */ new WeakMap(), _initializeTTLTracking = /* @__PURE__ */ new WeakSet(), _updateItemAge = /* @__PURE__ */ new WeakMap(), _statusTTL = /* @__PURE__ */ new WeakMap(), _setItemTTL = /* @__PURE__ */ new WeakMap(), _isStale = /* @__PURE__ */ new WeakMap(), _initializeSizeTracking = /* @__PURE__ */ new WeakSet(), _removeItemSize = /* @__PURE__ */ new WeakMap(), _addItemSize = /* @__PURE__ */ new WeakMap(), _requireSize = /* @__PURE__ */ new WeakMap(), _indexes = /* @__PURE__ */ new WeakSet(), _rindexes = /* @__PURE__ */ new WeakSet(), _isValidIndex = /* @__PURE__ */ new WeakSet(), _evict = /* @__PURE__ */ new WeakSet(), _backgroundFetch = /* @__PURE__ */ new WeakSet(), _isBackgroundFetch = /* @__PURE__ */ new WeakSet(), _connect = /* @__PURE__ */ new WeakSet(), _moveToTail = /* @__PURE__ */ new WeakSet(), _Symbol_iterator = Symbol.iterator, LRUCache = /* @__PURE__ */ function() {
  "use strict";
  function LRUCache2(options) {
    _class_call_check6(this, LRUCache2), _class_private_method_init2(this, _initializeTTLTracking), _class_private_method_init2(this, _initializeSizeTracking), _class_private_method_init2(this, _indexes), _class_private_method_init2(this, _rindexes), _class_private_method_init2(this, _isValidIndex), _class_private_method_init2(this, _evict), _class_private_method_init2(this, _backgroundFetch), _class_private_method_init2(this, _isBackgroundFetch), _class_private_method_init2(this, _connect), _class_private_method_init2(this, _moveToTail), _class_private_field_init2(this, _max, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _maxSize, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _dispose, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _disposeAfter, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _fetchMethod, {
      writable: !0,
      value: void 0
    }), _define_property9(this, "ttl", void 0), _define_property9(this, "ttlResolution", void 0), _define_property9(this, "ttlAutopurge", void 0), _define_property9(this, "updateAgeOnGet", void 0), _define_property9(this, "updateAgeOnHas", void 0), _define_property9(this, "allowStale", void 0), _define_property9(this, "noDisposeOnSet", void 0), _define_property9(this, "noUpdateTTL", void 0), _define_property9(this, "maxEntrySize", void 0), _define_property9(this, "sizeCalculation", void 0), _define_property9(this, "noDeleteOnFetchRejection", void 0), _define_property9(this, "noDeleteOnStaleGet", void 0), _define_property9(this, "allowStaleOnFetchAbort", void 0), _define_property9(this, "allowStaleOnFetchRejection", void 0), _define_property9(this, "ignoreFetchAbort", void 0), _class_private_field_init2(this, _size, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _calculatedSize, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _keyMap, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _keyList, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _valList, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _next, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _prev, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _head, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _tail, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _free, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _disposed, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _sizes, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _starts, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _ttls, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _hasDispose, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _hasFetchMethod, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _hasDisposeAfter, {
      writable: !0,
      value: void 0
    }), _class_private_field_init2(this, _updateItemAge, {
      writable: !0,
      value: function() {
      }
    }), _class_private_field_init2(this, _statusTTL, {
      writable: !0,
      value: function() {
      }
    }), _class_private_field_init2(this, _setItemTTL, {
      writable: !0,
      value: function() {
      }
    }), _class_private_field_init2(this, _isStale, {
      writable: !0,
      value: function() {
        return !1;
      }
    }), _class_private_field_init2(this, _removeItemSize, {
      writable: !0,
      value: function(_i) {
      }
    }), _class_private_field_init2(this, _addItemSize, {
      writable: !0,
      value: function(_i, _s, _st) {
      }
    }), _class_private_field_init2(this, _requireSize, {
      writable: !0,
      value: function(_k, _v, size, sizeCalculation2) {
        if (size || sizeCalculation2)
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        return 0;
      }
    });
    var _options_max = options.max, max = _options_max === void 0 ? 0 : _options_max, ttl = options.ttl, _options_ttlResolution = options.ttlResolution, ttlResolution = _options_ttlResolution === void 0 ? 1 : _options_ttlResolution, ttlAutopurge = options.ttlAutopurge, updateAgeOnGet = options.updateAgeOnGet, updateAgeOnHas = options.updateAgeOnHas, allowStale = options.allowStale, dispose = options.dispose, disposeAfter = options.disposeAfter, noDisposeOnSet = options.noDisposeOnSet, noUpdateTTL = options.noUpdateTTL, _options_maxSize = options.maxSize, maxSize = _options_maxSize === void 0 ? 0 : _options_maxSize, _options_maxEntrySize = options.maxEntrySize, maxEntrySize = _options_maxEntrySize === void 0 ? 0 : _options_maxEntrySize, sizeCalculation = options.sizeCalculation, fetchMethod = options.fetchMethod, noDeleteOnFetchRejection = options.noDeleteOnFetchRejection, noDeleteOnStaleGet = options.noDeleteOnStaleGet, allowStaleOnFetchRejection = options.allowStaleOnFetchRejection, allowStaleOnFetchAbort = options.allowStaleOnFetchAbort, ignoreFetchAbort = options.ignoreFetchAbort;
    if (max !== 0 && !isPosInt(max))
      throw new TypeError("max option must be a nonnegative integer");
    var UintArray = max ? getUintArray(max) : Array;
    if (!UintArray)
      throw new Error("invalid max value: " + max);
    if (_class_private_field_set2(this, _max, max), _class_private_field_set2(this, _maxSize, maxSize), this.maxEntrySize = maxEntrySize || _class_private_field_get2(this, _maxSize), this.sizeCalculation = sizeCalculation, this.sizeCalculation) {
      if (!_class_private_field_get2(this, _maxSize) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (fetchMethod !== void 0 && typeof fetchMethod != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (_class_private_field_set2(this, _fetchMethod, fetchMethod), _class_private_field_set2(this, _hasFetchMethod, !!fetchMethod), _class_private_field_set2(this, _keyMap, /* @__PURE__ */ new Map()), _class_private_field_set2(this, _keyList, new Array(max).fill(void 0)), _class_private_field_set2(this, _valList, new Array(max).fill(void 0)), _class_private_field_set2(this, _next, new UintArray(max)), _class_private_field_set2(this, _prev, new UintArray(max)), _class_private_field_set2(this, _head, 0), _class_private_field_set2(this, _tail, 0), _class_private_field_set2(this, _free, Stack.create(max)), _class_private_field_set2(this, _size, 0), _class_private_field_set2(this, _calculatedSize, 0), typeof dispose == "function" && _class_private_field_set2(this, _dispose, dispose), typeof disposeAfter == "function" ? (_class_private_field_set2(this, _disposeAfter, disposeAfter), _class_private_field_set2(this, _disposed, [])) : (_class_private_field_set2(this, _disposeAfter, void 0), _class_private_field_set2(this, _disposed, void 0)), _class_private_field_set2(this, _hasDispose, !!_class_private_field_get2(this, _dispose)), _class_private_field_set2(this, _hasDisposeAfter, !!_class_private_field_get2(this, _disposeAfter)), this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection, this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort, this.ignoreFetchAbort = !!ignoreFetchAbort, this.maxEntrySize !== 0) {
      if (_class_private_field_get2(this, _maxSize) !== 0 && !isPosInt(_class_private_field_get2(this, _maxSize)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!isPosInt(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      _class_private_method_get2(this, _initializeSizeTracking, initializeSizeTracking).call(this);
    }
    if (this.allowStale = !!allowStale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || 0, this.ttl) {
      if (!isPosInt(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      _class_private_method_get2(this, _initializeTTLTracking, initializeTTLTracking).call(this);
    }
    if (_class_private_field_get2(this, _max) === 0 && this.ttl === 0 && _class_private_field_get2(this, _maxSize) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !_class_private_field_get2(this, _max) && !_class_private_field_get2(this, _maxSize)) {
      var code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        var msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache2);
      }
    }
  }
  return _create_class4(LRUCache2, [
    {
      key: "max",
      get: (
        // Protected read-only members
        /**
        * {@link LRUCache.OptionsBase.max} (read-only)
        */
        function() {
          return _class_private_field_get2(this, _max);
        }
      )
    },
    {
      key: "maxSize",
      get: (
        /**
        * {@link LRUCache.OptionsBase.maxSize} (read-only)
        */
        function() {
          return _class_private_field_get2(this, _maxSize);
        }
      )
    },
    {
      key: "calculatedSize",
      get: (
        /**
        * The total computed size of items in the cache (read-only)
        */
        function() {
          return _class_private_field_get2(this, _calculatedSize);
        }
      )
    },
    {
      key: "size",
      get: (
        /**
        * The number of items stored in the cache (read-only)
        */
        function() {
          return _class_private_field_get2(this, _size);
        }
      )
    },
    {
      key: "fetchMethod",
      get: (
        /**
        * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
        */
        function() {
          return _class_private_field_get2(this, _fetchMethod);
        }
      )
    },
    {
      key: "dispose",
      get: (
        /**
        * {@link LRUCache.OptionsBase.dispose} (read-only)
        */
        function() {
          return _class_private_field_get2(this, _dispose);
        }
      )
    },
    {
      key: "disposeAfter",
      get: (
        /**
        * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
        */
        function() {
          return _class_private_field_get2(this, _disposeAfter);
        }
      )
    },
    {
      /**
      * Return the remaining TTL time for a given entry key
      */
      key: "getRemainingTTL",
      value: function(key) {
        return _class_private_field_get2(this, _keyMap).has(key) ? 1 / 0 : 0;
      }
    },
    {
      key: "entries",
      value: (
        /**
        * Return a generator yielding `[key, value]` pairs,
        * in order from most recently used to least recently used.
        */
        function() {
          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, i, err;
          return _ts_generator5(this, function(_state) {
            switch (_state.label) {
              case 0:
                _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  6,
                  7,
                  8
                ]), _iterator = _class_private_method_get2(this, _indexes, indexes).call(this)[Symbol.iterator](), _state.label = 2;
              case 2:
                return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                  3,
                  5
                ] : (i = _step.value, _class_private_field_get2(this, _valList)[i] !== void 0 && _class_private_field_get2(this, _keyList)[i] !== void 0 && !_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get2(this, _valList)[i]) ? [
                  4,
                  [
                    _class_private_field_get2(this, _keyList)[i],
                    _class_private_field_get2(this, _valList)[i]
                  ]
                ] : [
                  3,
                  4
                ]);
              case 3:
                _state.sent(), _state.label = 4;
              case 4:
                return _iteratorNormalCompletion2 = !0, [
                  3,
                  2
                ];
              case 5:
                return [
                  3,
                  8
                ];
              case 6:
                return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                  3,
                  8
                ];
              case 7:
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
                return [
                  7
                ];
              case 8:
                return [
                  2
                ];
            }
          });
        }
      )
    },
    {
      key: "rentries",
      value: (
        /**
        * Inverse order version of {@link LRUCache.entries}
        *
        * Return a generator yielding `[key, value]` pairs,
        * in order from least recently used to most recently used.
        */
        function() {
          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, i, err;
          return _ts_generator5(this, function(_state) {
            switch (_state.label) {
              case 0:
                _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  6,
                  7,
                  8
                ]), _iterator = _class_private_method_get2(this, _rindexes, rindexes).call(this)[Symbol.iterator](), _state.label = 2;
              case 2:
                return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                  3,
                  5
                ] : (i = _step.value, _class_private_field_get2(this, _valList)[i] !== void 0 && _class_private_field_get2(this, _keyList)[i] !== void 0 && !_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get2(this, _valList)[i]) ? [
                  4,
                  [
                    _class_private_field_get2(this, _keyList)[i],
                    _class_private_field_get2(this, _valList)[i]
                  ]
                ] : [
                  3,
                  4
                ]);
              case 3:
                _state.sent(), _state.label = 4;
              case 4:
                return _iteratorNormalCompletion2 = !0, [
                  3,
                  2
                ];
              case 5:
                return [
                  3,
                  8
                ];
              case 6:
                return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                  3,
                  8
                ];
              case 7:
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
                return [
                  7
                ];
              case 8:
                return [
                  2
                ];
            }
          });
        }
      )
    },
    {
      key: "keys",
      value: (
        /**
        * Return a generator yielding the keys in the cache,
        * in order from most recently used to least recently used.
        */
        function() {
          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, i, k, err;
          return _ts_generator5(this, function(_state) {
            switch (_state.label) {
              case 0:
                _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  6,
                  7,
                  8
                ]), _iterator = _class_private_method_get2(this, _indexes, indexes).call(this)[Symbol.iterator](), _state.label = 2;
              case 2:
                return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                  3,
                  5
                ] : (i = _step.value, k = _class_private_field_get2(this, _keyList)[i], k !== void 0 && !_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get2(this, _valList)[i]) ? [
                  4,
                  k
                ] : [
                  3,
                  4
                ]);
              case 3:
                _state.sent(), _state.label = 4;
              case 4:
                return _iteratorNormalCompletion2 = !0, [
                  3,
                  2
                ];
              case 5:
                return [
                  3,
                  8
                ];
              case 6:
                return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                  3,
                  8
                ];
              case 7:
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
                return [
                  7
                ];
              case 8:
                return [
                  2
                ];
            }
          });
        }
      )
    },
    {
      key: "rkeys",
      value: (
        /**
        * Inverse order version of {@link LRUCache.keys}
        *
        * Return a generator yielding the keys in the cache,
        * in order from least recently used to most recently used.
        */
        function() {
          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, i, k, err;
          return _ts_generator5(this, function(_state) {
            switch (_state.label) {
              case 0:
                _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  6,
                  7,
                  8
                ]), _iterator = _class_private_method_get2(this, _rindexes, rindexes).call(this)[Symbol.iterator](), _state.label = 2;
              case 2:
                return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                  3,
                  5
                ] : (i = _step.value, k = _class_private_field_get2(this, _keyList)[i], k !== void 0 && !_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get2(this, _valList)[i]) ? [
                  4,
                  k
                ] : [
                  3,
                  4
                ]);
              case 3:
                _state.sent(), _state.label = 4;
              case 4:
                return _iteratorNormalCompletion2 = !0, [
                  3,
                  2
                ];
              case 5:
                return [
                  3,
                  8
                ];
              case 6:
                return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                  3,
                  8
                ];
              case 7:
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
                return [
                  7
                ];
              case 8:
                return [
                  2
                ];
            }
          });
        }
      )
    },
    {
      key: "values",
      value: (
        /**
        * Return a generator yielding the values in the cache,
        * in order from most recently used to least recently used.
        */
        function() {
          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, i, v1, err;
          return _ts_generator5(this, function(_state) {
            switch (_state.label) {
              case 0:
                _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  6,
                  7,
                  8
                ]), _iterator = _class_private_method_get2(this, _indexes, indexes).call(this)[Symbol.iterator](), _state.label = 2;
              case 2:
                return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                  3,
                  5
                ] : (i = _step.value, v1 = _class_private_field_get2(this, _valList)[i], v1 !== void 0 && !_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get2(this, _valList)[i]) ? [
                  4,
                  _class_private_field_get2(this, _valList)[i]
                ] : [
                  3,
                  4
                ]);
              case 3:
                _state.sent(), _state.label = 4;
              case 4:
                return _iteratorNormalCompletion2 = !0, [
                  3,
                  2
                ];
              case 5:
                return [
                  3,
                  8
                ];
              case 6:
                return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                  3,
                  8
                ];
              case 7:
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
                return [
                  7
                ];
              case 8:
                return [
                  2
                ];
            }
          });
        }
      )
    },
    {
      key: "rvalues",
      value: (
        /**
        * Inverse order version of {@link LRUCache.values}
        *
        * Return a generator yielding the values in the cache,
        * in order from least recently used to most recently used.
        */
        function() {
          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, i, v1, err;
          return _ts_generator5(this, function(_state) {
            switch (_state.label) {
              case 0:
                _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  6,
                  7,
                  8
                ]), _iterator = _class_private_method_get2(this, _rindexes, rindexes).call(this)[Symbol.iterator](), _state.label = 2;
              case 2:
                return (_iteratorNormalCompletion2 = (_step = _iterator.next()).done) ? [
                  3,
                  5
                ] : (i = _step.value, v1 = _class_private_field_get2(this, _valList)[i], v1 !== void 0 && !_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get2(this, _valList)[i]) ? [
                  4,
                  _class_private_field_get2(this, _valList)[i]
                ] : [
                  3,
                  4
                ]);
              case 3:
                _state.sent(), _state.label = 4;
              case 4:
                return _iteratorNormalCompletion2 = !0, [
                  3,
                  2
                ];
              case 5:
                return [
                  3,
                  8
                ];
              case 6:
                return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                  3,
                  8
                ];
              case 7:
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
                return [
                  7
                ];
              case 8:
                return [
                  2
                ];
            }
          });
        }
      )
    },
    {
      /**
      * Iterating over the cache itself yields the same results as
      * {@link LRUCache.entries}
      */
      key: _Symbol_iterator,
      value: function() {
        return this.entries();
      }
    },
    {
      /**
      * Find a value for which the supplied fn method returns a truthy value,
      * similar to Array.find().  fn is called as fn(value, key, cache).
      */
      key: "find",
      value: function(fn) {
        var getOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_method_get2(this, _indexes, indexes).call(this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var i = _step.value, v1 = _class_private_field_get2(this, _valList)[i], value = _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
            if (value !== void 0 && fn(value, _class_private_field_get2(this, _keyList)[i], this))
              return this.get(_class_private_field_get2(this, _keyList)[i], getOptions);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
    },
    {
      /**
      * Call the supplied function on each item in the cache, in order from
      * most recently used to least recently used.  fn is called as
      * fn(value, key, cache).  Does not update age or recenty of use.
      * Does not iterate over stale values.
      */
      key: "forEach",
      value: function(fn) {
        var thisp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_method_get2(this, _indexes, indexes).call(this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var i = _step.value, v1 = _class_private_field_get2(this, _valList)[i], value = _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
            value !== void 0 && fn.call(thisp, value, _class_private_field_get2(this, _keyList)[i], this);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
    },
    {
      /**
      * The same as {@link LRUCache.forEach} but items are iterated over in
      * reverse order.  (ie, less recently used items are iterated over first.)
      */
      key: "rforEach",
      value: function(fn) {
        var thisp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_method_get2(this, _rindexes, rindexes).call(this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var i = _step.value, v1 = _class_private_field_get2(this, _valList)[i], value = _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
            value !== void 0 && fn.call(thisp, value, _class_private_field_get2(this, _keyList)[i], this);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
    },
    {
      /**
      * Delete any stale entries. Returns true if anything was removed,
      * false otherwise.
      */
      key: "purgeStale",
      value: function() {
        var deleted = !1, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_method_get2(this, _rindexes, rindexes).call(this, {
            allowStale: !0
          })[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var i = _step.value;
            _class_private_field_get2(this, _isStale).call(this, i) && (this.delete(_class_private_field_get2(this, _keyList)[i]), deleted = !0);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return deleted;
      }
    },
    {
      /**
      * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
      * passed to cache.load()
      */
      key: "dump",
      value: function() {
        var arr = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_method_get2(this, _indexes, indexes).call(this, {
            allowStale: !0
          })[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var i = _step.value, key = _class_private_field_get2(this, _keyList)[i], v1 = _class_private_field_get2(this, _valList)[i], value = _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
            if (!(value === void 0 || key === void 0)) {
              var entry = {
                value
              };
              if (_class_private_field_get2(this, _ttls) && _class_private_field_get2(this, _starts)) {
                entry.ttl = _class_private_field_get2(this, _ttls)[i];
                var age = perf.now() - _class_private_field_get2(this, _starts)[i];
                entry.start = Math.floor(Date.now() - age);
              }
              _class_private_field_get2(this, _sizes) && (entry.size = _class_private_field_get2(this, _sizes)[i]), arr.unshift([
                key,
                entry
              ]);
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return arr;
      }
    },
    {
      /**
      * Reset the cache and load in the items in entries in the order listed.
      * Note that the shape of the resulting cache may be different if the
      * same options are not used in both caches.
      */
      key: "load",
      value: function(arr) {
        this.clear();
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array9(_step.value, 2), key = _step_value[0], entry = _step_value[1];
            if (entry.start) {
              var age = Date.now() - entry.start;
              entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
      }
    },
    {
      /**
      * Add a value to the cache.
      *
      * Note: if `undefined` is specified as a value, this is an alias for
      * {@link LRUCache#delete}
      */
      key: "set",
      value: function(k, v1) {
        var setOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _this, _this1, _ref, _this2, _this3, _ref1, _this4, _this5, _ref2;
        if (v1 === void 0)
          return this.delete(k), this;
        var _setOptions_ttl = setOptions.ttl, ttl = _setOptions_ttl === void 0 ? this.ttl : _setOptions_ttl, start = setOptions.start, _setOptions_noDisposeOnSet = setOptions.noDisposeOnSet, noDisposeOnSet = _setOptions_noDisposeOnSet === void 0 ? this.noDisposeOnSet : _setOptions_noDisposeOnSet, _setOptions_sizeCalculation = setOptions.sizeCalculation, sizeCalculation = _setOptions_sizeCalculation === void 0 ? this.sizeCalculation : _setOptions_sizeCalculation, status = setOptions.status, _setOptions_noUpdateTTL = setOptions.noUpdateTTL, noUpdateTTL = _setOptions_noUpdateTTL === void 0 ? this.noUpdateTTL : _setOptions_noUpdateTTL, size = _class_private_field_get2(this, _requireSize).call(this, k, v1, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize)
          return status && (status.set = "miss", status.maxEntrySizeExceeded = !0), this.delete(k), this;
        var index = _class_private_field_get2(this, _size) === 0 ? void 0 : _class_private_field_get2(this, _keyMap).get(k);
        if (index === void 0)
          index = _class_private_field_get2(this, _size) === 0 ? _class_private_field_get2(this, _tail) : _class_private_field_get2(this, _free).length !== 0 ? _class_private_field_get2(this, _free).pop() : _class_private_field_get2(this, _size) === _class_private_field_get2(this, _max) ? _class_private_method_get2(this, _evict, evict).call(this, !1) : _class_private_field_get2(this, _size), _class_private_field_get2(this, _keyList)[index] = k, _class_private_field_get2(this, _valList)[index] = v1, _class_private_field_get2(this, _keyMap).set(k, index), _class_private_field_get2(this, _next)[_class_private_field_get2(this, _tail)] = index, _class_private_field_get2(this, _prev)[index] = _class_private_field_get2(this, _tail), _class_private_field_set2(this, _tail, index), _class_private_field_update(this, _size).value++, _class_private_field_get2(this, _addItemSize).call(this, index, size, status), status && (status.set = "add"), noUpdateTTL = !1;
        else {
          _class_private_method_get2(this, _moveToTail, moveToTail).call(this, index);
          var oldVal = _class_private_field_get2(this, _valList)[index];
          if (v1 !== oldVal) {
            if (_class_private_field_get2(this, _hasFetchMethod) && _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              var s = oldVal.__staleWhileFetching;
              if (s !== void 0 && !noDisposeOnSet && (_class_private_field_get2(this, _hasDispose) && ((_this = _class_private_field_get2(_ref = _this1 = this, _dispose)) === null || _this === void 0 || _this.call(_this1, s, k, "set")), _class_private_field_get2(this, _hasDisposeAfter))) {
                var _$_class_private_field_get;
                (_$_class_private_field_get = _class_private_field_get2(this, _disposed)) === null || _$_class_private_field_get === void 0 || _$_class_private_field_get.push([
                  s,
                  k,
                  "set"
                ]);
              }
            } else if (!noDisposeOnSet && (_class_private_field_get2(this, _hasDispose) && ((_this2 = _class_private_field_get2(_ref1 = _this3 = this, _dispose)) === null || _this2 === void 0 || _this2.call(_this3, oldVal, k, "set")), _class_private_field_get2(this, _hasDisposeAfter))) {
              var _$_class_private_field_get1;
              (_$_class_private_field_get1 = _class_private_field_get2(this, _disposed)) === null || _$_class_private_field_get1 === void 0 || _$_class_private_field_get1.push([
                oldVal,
                k,
                "set"
              ]);
            }
            if (_class_private_field_get2(this, _removeItemSize).call(this, index), _class_private_field_get2(this, _addItemSize).call(this, index, size, status), _class_private_field_get2(this, _valList)[index] = v1, status) {
              status.set = "replace";
              var oldValue = oldVal && _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              oldValue !== void 0 && (status.oldValue = oldValue);
            }
          } else
            status && (status.set = "update");
        }
        if (ttl !== 0 && !_class_private_field_get2(this, _ttls) && _class_private_method_get2(this, _initializeTTLTracking, initializeTTLTracking).call(this), _class_private_field_get2(this, _ttls) && (noUpdateTTL || _class_private_field_get2(this, _setItemTTL).call(this, index, ttl, start), status && _class_private_field_get2(this, _statusTTL).call(this, status, index)), !noDisposeOnSet && _class_private_field_get2(this, _hasDisposeAfter) && _class_private_field_get2(this, _disposed))
          for (var dt = _class_private_field_get2(this, _disposed), task; task = dt == null ? void 0 : dt.shift(); ) {
            var _this6;
            (_this4 = _class_private_field_get2(_ref2 = _this5 = this, _disposeAfter)) === null || _this4 === void 0 || (_this6 = _this4).call.apply(_this6, [
              _this5
            ].concat(_to_consumable_array7(task)));
          }
        return this;
      }
    },
    {
      /**
      * Evict the least recently used item, returning its value or
      * `undefined` if cache is empty.
      */
      key: "pop",
      value: function() {
        var _this, _this1, _ref;
        try {
          for (; _class_private_field_get2(this, _size); ) {
            var val = _class_private_field_get2(this, _valList)[_class_private_field_get2(this, _head)];
            if (_class_private_method_get2(this, _evict, evict).call(this, !0), _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, val)) {
              if (val.__staleWhileFetching)
                return val.__staleWhileFetching;
            } else if (val !== void 0)
              return val;
          }
        } finally {
          if (_class_private_field_get2(this, _hasDisposeAfter) && _class_private_field_get2(this, _disposed))
            for (var dt = _class_private_field_get2(this, _disposed), task; task = dt == null ? void 0 : dt.shift(); ) {
              var _this2;
              (_this = _class_private_field_get2(_ref = _this1 = this, _disposeAfter)) === null || _this === void 0 || (_this2 = _this).call.apply(_this2, [
                _this1
              ].concat(_to_consumable_array7(task)));
            }
        }
      }
    },
    {
      /**
      * Check if a key is in the cache, without updating the recency of use.
      * Will return false if the item is stale, even though it is technically
      * in the cache.
      *
      * Will not update item age unless
      * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
      */
      key: "has",
      value: function(k) {
        var hasOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _hasOptions_updateAgeOnHas = hasOptions.updateAgeOnHas, updateAgeOnHas = _hasOptions_updateAgeOnHas === void 0 ? this.updateAgeOnHas : _hasOptions_updateAgeOnHas, status = hasOptions.status, index = _class_private_field_get2(this, _keyMap).get(k);
        if (index !== void 0) {
          var v1 = _class_private_field_get2(this, _valList)[index];
          if (_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) && v1.__staleWhileFetching === void 0)
            return !1;
          if (_class_private_field_get2(this, _isStale).call(this, index))
            status && (status.has = "stale", _class_private_field_get2(this, _statusTTL).call(this, status, index));
          else
            return updateAgeOnHas && _class_private_field_get2(this, _updateItemAge).call(this, index), status && (status.has = "hit", _class_private_field_get2(this, _statusTTL).call(this, status, index)), !0;
        } else
          status && (status.has = "miss");
        return !1;
      }
    },
    {
      /**
      * Like {@link LRUCache#get} but doesn't update recency or delete stale
      * items.
      *
      * Returns `undefined` if the item is stale, unless
      * {@link LRUCache.OptionsBase.allowStale} is set.
      */
      key: "peek",
      value: function(k) {
        var peekOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _peekOptions_allowStale = peekOptions.allowStale, allowStale = _peekOptions_allowStale === void 0 ? this.allowStale : _peekOptions_allowStale, index = _class_private_field_get2(this, _keyMap).get(k);
        if (index !== void 0 && (allowStale || !_class_private_field_get2(this, _isStale).call(this, index))) {
          var v1 = _class_private_field_get2(this, _valList)[index];
          return _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
        }
      }
    },
    {
      key: "fetch",
      value: function(k) {
        var fetchOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _this = this;
        return _async_to_generator5(function() {
          var _fetchOptions_allowStale, allowStale, _fetchOptions_updateAgeOnGet, updateAgeOnGet, _fetchOptions_noDeleteOnStaleGet, noDeleteOnStaleGet, _fetchOptions_ttl, ttl, _fetchOptions_noDisposeOnSet, noDisposeOnSet, _fetchOptions_size, size, _fetchOptions_sizeCalculation, sizeCalculation, _fetchOptions_noUpdateTTL, noUpdateTTL, _fetchOptions_noDeleteOnFetchRejection, noDeleteOnFetchRejection, _fetchOptions_allowStaleOnFetchRejection, allowStaleOnFetchRejection, _fetchOptions_ignoreFetchAbort, ignoreFetchAbort, _fetchOptions_allowStaleOnFetchAbort, allowStaleOnFetchAbort, context, _fetchOptions_forceRefresh, forceRefresh, status, signal, options, index, p, v1, stale, isStale, p1, hasStale, staleVal;
          return _ts_generator5(this, function(_state) {
            return _fetchOptions_allowStale = fetchOptions.allowStale, allowStale = _fetchOptions_allowStale === void 0 ? _this.allowStale : _fetchOptions_allowStale, _fetchOptions_updateAgeOnGet = fetchOptions.updateAgeOnGet, updateAgeOnGet = _fetchOptions_updateAgeOnGet === void 0 ? _this.updateAgeOnGet : _fetchOptions_updateAgeOnGet, _fetchOptions_noDeleteOnStaleGet = fetchOptions.noDeleteOnStaleGet, noDeleteOnStaleGet = _fetchOptions_noDeleteOnStaleGet === void 0 ? _this.noDeleteOnStaleGet : _fetchOptions_noDeleteOnStaleGet, _fetchOptions_ttl = fetchOptions.ttl, ttl = _fetchOptions_ttl === void 0 ? _this.ttl : _fetchOptions_ttl, _fetchOptions_noDisposeOnSet = fetchOptions.noDisposeOnSet, noDisposeOnSet = _fetchOptions_noDisposeOnSet === void 0 ? _this.noDisposeOnSet : _fetchOptions_noDisposeOnSet, _fetchOptions_size = fetchOptions.size, size = _fetchOptions_size === void 0 ? 0 : _fetchOptions_size, _fetchOptions_sizeCalculation = fetchOptions.sizeCalculation, sizeCalculation = _fetchOptions_sizeCalculation === void 0 ? _this.sizeCalculation : _fetchOptions_sizeCalculation, _fetchOptions_noUpdateTTL = fetchOptions.noUpdateTTL, noUpdateTTL = _fetchOptions_noUpdateTTL === void 0 ? _this.noUpdateTTL : _fetchOptions_noUpdateTTL, _fetchOptions_noDeleteOnFetchRejection = fetchOptions.noDeleteOnFetchRejection, noDeleteOnFetchRejection = _fetchOptions_noDeleteOnFetchRejection === void 0 ? _this.noDeleteOnFetchRejection : _fetchOptions_noDeleteOnFetchRejection, _fetchOptions_allowStaleOnFetchRejection = fetchOptions.allowStaleOnFetchRejection, allowStaleOnFetchRejection = _fetchOptions_allowStaleOnFetchRejection === void 0 ? _this.allowStaleOnFetchRejection : _fetchOptions_allowStaleOnFetchRejection, _fetchOptions_ignoreFetchAbort = fetchOptions.ignoreFetchAbort, ignoreFetchAbort = _fetchOptions_ignoreFetchAbort === void 0 ? _this.ignoreFetchAbort : _fetchOptions_ignoreFetchAbort, _fetchOptions_allowStaleOnFetchAbort = fetchOptions.allowStaleOnFetchAbort, allowStaleOnFetchAbort = _fetchOptions_allowStaleOnFetchAbort === void 0 ? _this.allowStaleOnFetchAbort : _fetchOptions_allowStaleOnFetchAbort, context = fetchOptions.context, _fetchOptions_forceRefresh = fetchOptions.forceRefresh, forceRefresh = _fetchOptions_forceRefresh === void 0 ? !1 : _fetchOptions_forceRefresh, status = fetchOptions.status, signal = fetchOptions.signal, _class_private_field_get2(_this, _hasFetchMethod) ? (options = {
              allowStale,
              updateAgeOnGet,
              noDeleteOnStaleGet,
              ttl,
              noDisposeOnSet,
              size,
              sizeCalculation,
              noUpdateTTL,
              noDeleteOnFetchRejection,
              allowStaleOnFetchRejection,
              allowStaleOnFetchAbort,
              ignoreFetchAbort,
              status,
              signal
            }, index = _class_private_field_get2(_this, _keyMap).get(k), index === void 0 ? (status && (status.fetch = "miss"), p = _class_private_method_get2(_this, _backgroundFetch, backgroundFetch).call(_this, k, index, options, context), [
              2,
              p.__returned = p
            ]) : (v1 = _class_private_field_get2(_this, _valList)[index], _class_private_method_get2(_this, _isBackgroundFetch, isBackgroundFetch).call(_this, v1) ? (stale = allowStale && v1.__staleWhileFetching !== void 0, status && (status.fetch = "inflight", stale && (status.returnedStale = !0)), [
              2,
              stale ? v1.__staleWhileFetching : v1.__returned = v1
            ]) : (isStale = _class_private_field_get2(_this, _isStale).call(_this, index), !forceRefresh && !isStale ? (status && (status.fetch = "hit"), _class_private_method_get2(_this, _moveToTail, moveToTail).call(_this, index), updateAgeOnGet && _class_private_field_get2(_this, _updateItemAge).call(_this, index), status && _class_private_field_get2(_this, _statusTTL).call(_this, status, index), [
              2,
              v1
            ]) : (p1 = _class_private_method_get2(_this, _backgroundFetch, backgroundFetch).call(_this, k, index, options, context), hasStale = p1.__staleWhileFetching !== void 0, staleVal = hasStale && allowStale, status && (status.fetch = isStale ? "stale" : "refresh", staleVal && isStale && (status.returnedStale = !0)), [
              2,
              staleVal ? p1.__staleWhileFetching : p1.__returned = p1
            ])))) : (status && (status.fetch = "get"), [
              2,
              _this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status
              })
            ]);
          });
        })();
      }
    },
    {
      /**
      * Return a value from the cache. Will update the recency of the cache
      * entry found.
      *
      * If the key is not found, get() will return `undefined`.
      */
      key: "get",
      value: function(k) {
        var getOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _getOptions_allowStale = getOptions.allowStale, allowStale = _getOptions_allowStale === void 0 ? this.allowStale : _getOptions_allowStale, _getOptions_updateAgeOnGet = getOptions.updateAgeOnGet, updateAgeOnGet = _getOptions_updateAgeOnGet === void 0 ? this.updateAgeOnGet : _getOptions_updateAgeOnGet, _getOptions_noDeleteOnStaleGet = getOptions.noDeleteOnStaleGet, noDeleteOnStaleGet = _getOptions_noDeleteOnStaleGet === void 0 ? this.noDeleteOnStaleGet : _getOptions_noDeleteOnStaleGet, status = getOptions.status, index = _class_private_field_get2(this, _keyMap).get(k);
        if (index !== void 0) {
          var value = _class_private_field_get2(this, _valList)[index], fetching = _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, value);
          return status && _class_private_field_get2(this, _statusTTL).call(this, status, index), _class_private_field_get2(this, _isStale).call(this, index) ? (status && (status.get = "stale"), fetching ? (status && allowStale && value.__staleWhileFetching !== void 0 && (status.returnedStale = !0), allowStale ? value.__staleWhileFetching : void 0) : (noDeleteOnStaleGet || this.delete(k), status && allowStale && (status.returnedStale = !0), allowStale ? value : void 0)) : (status && (status.get = "hit"), fetching ? value.__staleWhileFetching : (_class_private_method_get2(this, _moveToTail, moveToTail).call(this, index), updateAgeOnGet && _class_private_field_get2(this, _updateItemAge).call(this, index), value));
        } else
          status && (status.get = "miss");
      }
    },
    {
      /**
      * Deletes a key out of the cache.
      * Returns true if the key was deleted, false otherwise.
      */
      key: "delete",
      value: function(k) {
        var _$_class_private_field_get, _this, _this1, _ref, _this2, _this3, _ref1, deleted = !1;
        if (_class_private_field_get2(this, _size) !== 0) {
          var index = _class_private_field_get2(this, _keyMap).get(k);
          if (index !== void 0)
            if (deleted = !0, _class_private_field_get2(this, _size) === 1)
              this.clear();
            else {
              _class_private_field_get2(this, _removeItemSize).call(this, index);
              var v1 = _class_private_field_get2(this, _valList)[index];
              if (_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1))
                v1.__abortController.abort(new Error("deleted"));
              else if ((_class_private_field_get2(this, _hasDispose) || _class_private_field_get2(this, _hasDisposeAfter)) && (_class_private_field_get2(this, _hasDispose) && ((_this = _class_private_field_get2(_ref = _this1 = this, _dispose)) === null || _this === void 0 || _this.call(_this1, v1, k, "delete")), _class_private_field_get2(this, _hasDisposeAfter))) {
                var _$_class_private_field_get1;
                (_$_class_private_field_get1 = _class_private_field_get2(this, _disposed)) === null || _$_class_private_field_get1 === void 0 || _$_class_private_field_get1.push([
                  v1,
                  k,
                  "delete"
                ]);
              }
              _class_private_field_get2(this, _keyMap).delete(k), _class_private_field_get2(this, _keyList)[index] = void 0, _class_private_field_get2(this, _valList)[index] = void 0, index === _class_private_field_get2(this, _tail) ? _class_private_field_set2(this, _tail, _class_private_field_get2(this, _prev)[index]) : index === _class_private_field_get2(this, _head) ? _class_private_field_set2(this, _head, _class_private_field_get2(this, _next)[index]) : (_class_private_field_get2(this, _next)[_class_private_field_get2(this, _prev)[index]] = _class_private_field_get2(this, _next)[index], _class_private_field_get2(this, _prev)[_class_private_field_get2(this, _next)[index]] = _class_private_field_get2(this, _prev)[index]), _class_private_field_update(this, _size).value--, _class_private_field_get2(this, _free).push(index);
            }
        }
        if (_class_private_field_get2(this, _hasDisposeAfter) && (!((_$_class_private_field_get = _class_private_field_get2(this, _disposed)) === null || _$_class_private_field_get === void 0) && _$_class_private_field_get.length))
          for (var dt = _class_private_field_get2(this, _disposed), task; task = dt == null ? void 0 : dt.shift(); ) {
            var _this4;
            (_this2 = _class_private_field_get2(_ref1 = _this3 = this, _disposeAfter)) === null || _this2 === void 0 || (_this4 = _this2).call.apply(_this4, [
              _this3
            ].concat(_to_consumable_array7(task)));
          }
        return deleted;
      }
    },
    {
      /**
      * Clear the cache entirely, throwing away all values.
      */
      key: "clear",
      value: function() {
        var _this, _this1, _ref, _this2, _this3, _ref1, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = _class_private_method_get2(this, _rindexes, rindexes).call(this, {
            allowStale: !0
          })[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var index = _step.value, v1 = _class_private_field_get2(this, _valList)[index];
            if (_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1))
              v1.__abortController.abort(new Error("deleted"));
            else {
              var k = _class_private_field_get2(this, _keyList)[index];
              if (_class_private_field_get2(this, _hasDispose) && ((_this = _class_private_field_get2(_ref = _this1 = this, _dispose)) === null || _this === void 0 || _this.call(_this1, v1, k, "delete")), _class_private_field_get2(this, _hasDisposeAfter)) {
                var _$_class_private_field_get;
                (_$_class_private_field_get = _class_private_field_get2(this, _disposed)) === null || _$_class_private_field_get === void 0 || _$_class_private_field_get.push([
                  v1,
                  k,
                  "delete"
                ]);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        if (_class_private_field_get2(this, _keyMap).clear(), _class_private_field_get2(this, _valList).fill(void 0), _class_private_field_get2(this, _keyList).fill(void 0), _class_private_field_get2(this, _ttls) && _class_private_field_get2(this, _starts) && (_class_private_field_get2(this, _ttls).fill(0), _class_private_field_get2(this, _starts).fill(0)), _class_private_field_get2(this, _sizes) && _class_private_field_get2(this, _sizes).fill(0), _class_private_field_set2(this, _head, 0), _class_private_field_set2(this, _tail, 0), _class_private_field_get2(this, _free).length = 0, _class_private_field_set2(this, _calculatedSize, 0), _class_private_field_set2(this, _size, 0), _class_private_field_get2(this, _hasDisposeAfter) && _class_private_field_get2(this, _disposed))
          for (var dt = _class_private_field_get2(this, _disposed), task; task = dt == null ? void 0 : dt.shift(); ) {
            var _this4;
            (_this2 = _class_private_field_get2(_ref1 = _this3 = this, _disposeAfter)) === null || _this2 === void 0 || (_this4 = _this2).call.apply(_this4, [
              _this3
            ].concat(_to_consumable_array7(task)));
          }
      }
    }
  ], [
    {
      key: "unsafeExposeInternals",
      value: (
        /**
        * Do not call this method unless you need to inspect the
        * inner workings of the cache.  If anything returned by this
        * object is modified in any way, strange breakage may occur.
        *
        * These fields are private for a reason!
        *
        * @internal
        */
        function(c) {
          return {
            // properties
            starts: _class_private_field_get2(c, _starts),
            ttls: _class_private_field_get2(c, _ttls),
            sizes: _class_private_field_get2(c, _sizes),
            keyMap: _class_private_field_get2(c, _keyMap),
            keyList: _class_private_field_get2(c, _keyList),
            valList: _class_private_field_get2(c, _valList),
            next: _class_private_field_get2(c, _next),
            prev: _class_private_field_get2(c, _prev),
            get head() {
              return _class_private_field_get2(c, _head);
            },
            get tail() {
              return _class_private_field_get2(c, _tail);
            },
            free: _class_private_field_get2(c, _free),
            // methods
            isBackgroundFetch: function(p) {
              return _class_private_method_get2(c, _isBackgroundFetch, isBackgroundFetch).call(c, p);
            },
            backgroundFetch: function(k, index, options, context) {
              return _class_private_method_get2(c, _backgroundFetch, backgroundFetch).call(c, k, index, options, context);
            },
            moveToTail: function(index) {
              return _class_private_method_get2(c, _moveToTail, moveToTail).call(c, index);
            },
            indexes: function(options) {
              return _class_private_method_get2(c, _indexes, indexes).call(c, options);
            },
            rindexes: function(options) {
              return _class_private_method_get2(c, _rindexes, rindexes).call(c, options);
            },
            isStale: function(index) {
              return _class_private_field_get2(c, _isStale).call(c, index);
            }
          };
        }
      )
    }
  ]), LRUCache2;
}();
function initializeTTLTracking() {
  var _this = this, _this1 = this, ttls = new ZeroArray(_class_private_field_get2(this, _max)), starts = new ZeroArray(_class_private_field_get2(this, _max));
  _class_private_field_set2(this, _ttls, ttls), _class_private_field_set2(this, _starts, starts), _class_private_field_set2(this, _setItemTTL, function(index, ttl) {
    var start = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : perf.now();
    if (starts[index] = ttl !== 0 ? start : 0, ttls[index] = ttl, ttl !== 0 && _this1.ttlAutopurge) {
      var t = setTimeout(function() {
        _class_private_field_get2(_this1, _isStale).call(_this1, index) && _this1.delete(_class_private_field_get2(_this1, _keyList)[index]);
      }, ttl + 1);
      t.unref && t.unref();
    }
  }), _class_private_field_set2(this, _updateItemAge, function(index) {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  }), _class_private_field_set2(this, _statusTTL, function(status, index) {
    if (ttls[index]) {
      var ttl = ttls[index], start = starts[index];
      status.ttl = ttl, status.start = start, status.now = cachedNow || getNow();
      var age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  var cachedNow = 0, getNow = function() {
    var n = perf.now();
    if (_this.ttlResolution > 0) {
      cachedNow = n;
      var t = setTimeout(function() {
        return cachedNow = 0;
      }, _this.ttlResolution);
      t.unref && t.unref();
    }
    return n;
  };
  this.getRemainingTTL = function(key) {
    var index = _class_private_field_get2(_this, _keyMap).get(key);
    if (index === void 0)
      return 0;
    var ttl = ttls[index], start = starts[index];
    if (ttl === 0 || start === 0)
      return 1 / 0;
    var age = (cachedNow || getNow()) - start;
    return ttl - age;
  }, _class_private_field_set2(this, _isStale, function(index) {
    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
  });
}
function initializeSizeTracking() {
  var _this = this, sizes = new ZeroArray(_class_private_field_get2(this, _max));
  _class_private_field_set2(this, _calculatedSize, 0), _class_private_field_set2(this, _sizes, sizes), _class_private_field_set2(this, _removeItemSize, function(index) {
    _class_private_field_set2(_this, _calculatedSize, _class_private_field_get2(_this, _calculatedSize) - sizes[index]), sizes[index] = 0;
  }), _class_private_field_set2(this, _requireSize, function(k, v1, size, sizeCalculation) {
    if (_class_private_method_get2(_this, _isBackgroundFetch, isBackgroundFetch).call(_this, v1))
      return 0;
    if (!isPosInt(size))
      if (sizeCalculation) {
        if (typeof sizeCalculation != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (size = sizeCalculation(v1, k), !isPosInt(size))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return size;
  }), _class_private_field_set2(this, _addItemSize, function(index, size, status) {
    if (sizes[index] = size, _class_private_field_get2(_this, _maxSize))
      for (var maxSize = _class_private_field_get2(_this, _maxSize) - sizes[index]; _class_private_field_get2(_this, _calculatedSize) > maxSize; )
        _class_private_method_get2(_this, _evict, evict).call(_this, !0);
    _class_private_field_set2(_this, _calculatedSize, _class_private_field_get2(_this, _calculatedSize) + sizes[index]), status && (status.entrySize = size, status.totalCalculatedSize = _class_private_field_get2(_this, _calculatedSize));
  });
}
function indexes() {
  var _ref, _ref_allowStale, allowStale, i, _arguments = arguments;
  return _ts_generator5(this, function(_state) {
    switch (_state.label) {
      case 0:
        if (_ref = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : {}, _ref_allowStale = _ref.allowStale, allowStale = _ref_allowStale === void 0 ? this.allowStale : _ref_allowStale, !_class_private_field_get2(this, _size))
          return [
            3,
            5
          ];
        i = _class_private_field_get2(this, _tail), _state.label = 1;
      case 1:
        return _class_private_method_get2(this, _isValidIndex, isValidIndex).call(this, i) ? allowStale || !_class_private_field_get2(this, _isStale).call(this, i) ? [
          4,
          i
        ] : [
          3,
          3
        ] : [
          3,
          5
        ];
      case 2:
        _state.sent(), _state.label = 3;
      case 3:
        if (i === _class_private_field_get2(this, _head))
          return [
            3,
            5
          ];
        i = _class_private_field_get2(this, _prev)[i], _state.label = 4;
      case 4:
        return [
          3,
          1
        ];
      case 5:
        return [
          2
        ];
    }
  });
}
function rindexes() {
  var _ref, _ref_allowStale, allowStale, i, _arguments = arguments;
  return _ts_generator5(this, function(_state) {
    switch (_state.label) {
      case 0:
        if (_ref = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : {}, _ref_allowStale = _ref.allowStale, allowStale = _ref_allowStale === void 0 ? this.allowStale : _ref_allowStale, !_class_private_field_get2(this, _size))
          return [
            3,
            5
          ];
        i = _class_private_field_get2(this, _head), _state.label = 1;
      case 1:
        return _class_private_method_get2(this, _isValidIndex, isValidIndex).call(this, i) ? allowStale || !_class_private_field_get2(this, _isStale).call(this, i) ? [
          4,
          i
        ] : [
          3,
          3
        ] : [
          3,
          5
        ];
      case 2:
        _state.sent(), _state.label = 3;
      case 3:
        if (i === _class_private_field_get2(this, _tail))
          return [
            3,
            5
          ];
        i = _class_private_field_get2(this, _next)[i], _state.label = 4;
      case 4:
        return [
          3,
          1
        ];
      case 5:
        return [
          2
        ];
    }
  });
}
function isValidIndex(index) {
  return index !== void 0 && _class_private_field_get2(this, _keyMap).get(_class_private_field_get2(this, _keyList)[index]) === index;
}
function evict(free) {
  var _this, _this1, _ref, head = _class_private_field_get2(this, _head), k = _class_private_field_get2(this, _keyList)[head], v1 = _class_private_field_get2(this, _valList)[head];
  if (_class_private_field_get2(this, _hasFetchMethod) && _class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1))
    v1.__abortController.abort(new Error("evicted"));
  else if ((_class_private_field_get2(this, _hasDispose) || _class_private_field_get2(this, _hasDisposeAfter)) && (_class_private_field_get2(this, _hasDispose) && ((_this = _class_private_field_get2(_ref = _this1 = this, _dispose)) === null || _this === void 0 || _this.call(_this1, v1, k, "evict")), _class_private_field_get2(this, _hasDisposeAfter))) {
    var _$_class_private_field_get;
    (_$_class_private_field_get = _class_private_field_get2(this, _disposed)) === null || _$_class_private_field_get === void 0 || _$_class_private_field_get.push([
      v1,
      k,
      "evict"
    ]);
  }
  return _class_private_field_get2(this, _removeItemSize).call(this, head), free && (_class_private_field_get2(this, _keyList)[head] = void 0, _class_private_field_get2(this, _valList)[head] = void 0, _class_private_field_get2(this, _free).push(head)), _class_private_field_get2(this, _size) === 1 ? (_class_private_field_set2(this, _head, _class_private_field_set2(this, _tail, 0)), _class_private_field_get2(this, _free).length = 0) : _class_private_field_set2(this, _head, _class_private_field_get2(this, _next)[head]), _class_private_field_get2(this, _keyMap).delete(k), _class_private_field_update(this, _size).value--, head;
}
function backgroundFetch(k, index, options, context) {
  var _this = this, _this1 = this, _this2, _this3, _ref, v1 = index === void 0 ? void 0 : _class_private_field_get2(this, _valList)[index];
  if (_class_private_method_get2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1))
    return v1;
  var ac = new AC(), signal = options.signal;
  signal == null || signal.addEventListener("abort", function() {
    return ac.abort(signal.reason);
  }, {
    signal: ac.signal
  });
  var fetchOpts = {
    signal: ac.signal,
    options,
    context
  }, cb = function(v12) {
    var updateCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, aborted = ac.signal.aborted, ignoreAbort = options.ignoreFetchAbort && v12 !== void 0;
    if (options.status && (aborted && !updateCache ? (options.status.fetchAborted = !0, options.status.fetchError = ac.signal.reason, ignoreAbort && (options.status.fetchAbortIgnored = !0)) : options.status.fetchResolved = !0), aborted && !ignoreAbort && !updateCache)
      return fetchFail(ac.signal.reason);
    var bf2 = p;
    return _class_private_field_get2(_this1, _valList)[index] === p && (v12 === void 0 ? bf2.__staleWhileFetching ? _class_private_field_get2(_this1, _valList)[index] = bf2.__staleWhileFetching : _this1.delete(k) : (options.status && (options.status.fetchUpdated = !0), _this1.set(k, v12, fetchOpts.options))), v12;
  }, eb = function(er) {
    return options.status && (options.status.fetchRejected = !0, options.status.fetchError = er), fetchFail(er);
  }, fetchFail = function(er) {
    var aborted = ac.signal.aborted, allowStaleAborted = aborted && options.allowStaleOnFetchAbort, allowStale = allowStaleAborted || options.allowStaleOnFetchRejection, noDelete = allowStale || options.noDeleteOnFetchRejection, bf2 = p;
    if (_class_private_field_get2(_this, _valList)[index] === p) {
      var del = !noDelete || bf2.__staleWhileFetching === void 0;
      del ? _this.delete(k) : allowStaleAborted || (_class_private_field_get2(_this, _valList)[index] = bf2.__staleWhileFetching);
    }
    if (allowStale)
      return options.status && bf2.__staleWhileFetching !== void 0 && (options.status.returnedStale = !0), bf2.__staleWhileFetching;
    if (bf2.__returned === bf2)
      throw er;
  }, pcall = function(res, rej) {
    var fmp = (_this2 = _class_private_field_get2(_ref = _this3 = _this, _fetchMethod)) === null || _this2 === void 0 ? void 0 : _this2.call(_this3, k, v1, fetchOpts);
    fmp && _instanceof5(fmp, Promise) && fmp.then(function(v12) {
      return res(v12 === void 0 ? void 0 : v12);
    }, rej), ac.signal.addEventListener("abort", function() {
      (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) && (res(void 0), options.allowStaleOnFetchAbort && (res = function(v12) {
        return cb(v12, !0);
      }));
    });
  };
  options.status && (options.status.fetchDispatched = !0);
  var p = new Promise(pcall).then(cb, eb), bf = Object.assign(p, {
    __abortController: ac,
    __staleWhileFetching: v1,
    __returned: void 0
  });
  return index === void 0 ? (this.set(k, bf, _object_spread_props4(_object_spread7({}, fetchOpts.options), {
    status: void 0
  })), index = _class_private_field_get2(this, _keyMap).get(k)) : _class_private_field_get2(this, _valList)[index] = bf, bf;
}
function isBackgroundFetch(p) {
  if (!_class_private_field_get2(this, _hasFetchMethod))
    return !1;
  var b = p;
  return !!b && _instanceof5(b, Promise) && b.hasOwnProperty("__staleWhileFetching") && _instanceof5(b.__abortController, AC);
}
function connect(p, n) {
  _class_private_field_get2(this, _prev)[n] = p, _class_private_field_get2(this, _next)[p] = n;
}
function moveToTail(index) {
  index !== _class_private_field_get2(this, _tail) && (index === _class_private_field_get2(this, _head) ? _class_private_field_set2(this, _head, _class_private_field_get2(this, _next)[index]) : _class_private_method_get2(this, _connect, connect).call(this, _class_private_field_get2(this, _prev)[index], _class_private_field_get2(this, _next)[index]), _class_private_method_get2(this, _connect, connect).call(this, _class_private_field_get2(this, _tail), index), _class_private_field_set2(this, _tail, index));
}

// ../../node_modules/path-scurry/dist/mjs/index.js
var import_path3 = require("path"), import_url = require("url"), actualFS = __toESM(require("fs"), 1), import_fs2 = require("fs"), import_promises = require("fs/promises");

// ../../node_modules/path-scurry/node_modules/minipass/dist/mjs/index.js
var import_events = require("events"), import_stream = __toESM(require("stream"), 1), import_string_decoder = require("string_decoder");
function _array_like_to_array11(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes8(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array11(arr);
}
function _assert_this_initialized6(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function asyncGeneratorStep6(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator6(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep6(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep6(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _class_call_check7(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class5(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties5(Constructor.prototype, protoProps), staticProps && _defineProperties5(Constructor, staticProps), Constructor;
}
function _define_property10(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _get2(target, property, receiver) {
  return typeof Reflect < "u" && Reflect.get ? _get2 = Reflect.get : _get2 = function(target2, property2, receiver2) {
    var base = _super_prop_base2(target2, property2);
    if (base) {
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
    }
  }, _get2(target, property, receiver || target);
}
function _get_prototype_of6(o) {
  return _get_prototype_of6 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of6(o);
}
function _inherits6(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of6(subClass, superClass);
}
function _instanceof6(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array8(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _non_iterable_spread8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return6(self, call) {
  return call && (_type_of7(call) === "object" || typeof call == "function") ? call : _assert_this_initialized6(self);
}
function _set_prototype_of6(o, p) {
  return _set_prototype_of6 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of6(o, p);
}
function _super_prop_base2(object, property) {
  for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of6(object), object !== null); )
    ;
  return object;
}
function _to_consumable_array8(arr) {
  return _array_without_holes8(arr) || _iterable_to_array8(arr) || _unsupported_iterable_to_array11(arr) || _non_iterable_spread8();
}
function _type_of7(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array11(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array11(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array11(o, minLen);
  }
}
function _is_native_reflect_construct6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super6(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct6();
  return function() {
    var Super = _get_prototype_of6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return6(this, result);
  };
}
function _ts_generator6(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var proc = typeof process == "object" && process ? process : {
  stdout: null,
  stderr: null
}, isStream = function(s) {
  return !!s && typeof s == "object" && (_instanceof6(s, Minipass) || _instanceof6(s, import_stream.default) || isReadable(s) || isWritable(s));
}, isReadable = function(s) {
  return !!s && typeof s == "object" && _instanceof6(s, import_events.EventEmitter) && typeof s.pipe == "function" && // node core Writable streams have a pipe() method, but it throws
  s.pipe !== import_stream.default.Writable.prototype.pipe;
}, isWritable = function(s) {
  return !!s && typeof s == "object" && _instanceof6(s, import_events.EventEmitter) && typeof s.write == "function" && typeof s.end == "function";
}, EOF = Symbol("EOF"), MAYBE_EMIT_END = Symbol("maybeEmitEnd"), EMITTED_END = Symbol("emittedEnd"), EMITTING_END = Symbol("emittingEnd"), EMITTED_ERROR = Symbol("emittedError"), CLOSED = Symbol("closed"), READ = Symbol("read"), FLUSH = Symbol("flush"), FLUSHCHUNK = Symbol("flushChunk"), ENCODING = Symbol("encoding"), DECODER = Symbol("decoder"), FLOWING = Symbol("flowing"), PAUSED = Symbol("paused"), RESUME = Symbol("resume"), BUFFER = Symbol("buffer"), PIPES = Symbol("pipes"), BUFFERLENGTH = Symbol("bufferLength"), BUFFERPUSH = Symbol("bufferPush"), BUFFERSHIFT = Symbol("bufferShift"), OBJECTMODE = Symbol("objectMode"), DESTROYED = Symbol("destroyed"), ERROR = Symbol("error"), EMITDATA = Symbol("emitData"), EMITEND = Symbol("emitEnd"), EMITEND2 = Symbol("emitEnd2"), ASYNC = Symbol("async"), ABORT = Symbol("abort"), ABORTED = Symbol("aborted"), SIGNAL = Symbol("signal"), DATALISTENERS = Symbol("dataListeners"), DISCARDED = Symbol("discarded"), defer = function(fn) {
  return Promise.resolve().then(fn);
}, nodefer = function(fn) {
  return fn();
}, isEndish = function(ev) {
  return ev === "end" || ev === "finish" || ev === "prefinish";
}, isArrayBufferLike = function(b) {
  return _instanceof6(b, ArrayBuffer) || !!b && typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
}, isArrayBufferView = function(b) {
  return !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
}, Pipe = /* @__PURE__ */ function() {
  "use strict";
  function Pipe3(src, dest, opts) {
    _class_call_check7(this, Pipe3), _define_property10(this, "src", void 0), _define_property10(this, "dest", void 0), _define_property10(this, "opts", void 0), _define_property10(this, "ondrain", void 0), this.src = src, this.dest = dest, this.opts = opts, this.ondrain = function() {
      return src[RESUME]();
    }, this.dest.on("drain", this.ondrain);
  }
  return _create_class5(Pipe3, [
    {
      key: "unpipe",
      value: function() {
        this.dest.removeListener("drain", this.ondrain);
      }
    },
    {
      // only here for the prototype
      /* c8 ignore start */
      key: "proxyErrors",
      value: function(_er) {
      }
    },
    {
      /* c8 ignore stop */
      key: "end",
      value: function() {
        this.unpipe(), this.opts.end && this.dest.end();
      }
    }
  ]), Pipe3;
}(), PipeProxyErrors = /* @__PURE__ */ function(Pipe3) {
  "use strict";
  _inherits6(PipeProxyErrors3, Pipe3);
  var _super = _create_super6(PipeProxyErrors3);
  function PipeProxyErrors3(src, dest, opts) {
    _class_call_check7(this, PipeProxyErrors3);
    var _this;
    return _this = _super.call(this, src, dest, opts), _this.proxyErrors = function(er) {
      return dest.emit("error", er);
    }, src.on("error", _this.proxyErrors), _this;
  }
  return _create_class5(PipeProxyErrors3, [
    {
      key: "unpipe",
      value: function() {
        this.src.removeListener("error", this.proxyErrors), _get2(_get_prototype_of6(PipeProxyErrors3.prototype), "unpipe", this).call(this);
      }
    }
  ]), PipeProxyErrors3;
}(Pipe), isObjectModeOptions = function(o) {
  return !!o.objectMode;
}, isEncodingOptions = function(o) {
  return !o.objectMode && !!o.encoding && o.encoding !== "buffer";
}, _FLOWING = FLOWING, _PAUSED = PAUSED, _PIPES = PIPES, _BUFFER = BUFFER, _OBJECTMODE = OBJECTMODE, _ENCODING = ENCODING, _ASYNC = ASYNC, _DECODER = DECODER, _EOF = EOF, _EMITTED_END = EMITTED_END, _EMITTING_END = EMITTING_END, _CLOSED = CLOSED, _EMITTED_ERROR = EMITTED_ERROR, _BUFFERLENGTH = BUFFERLENGTH, _DESTROYED = DESTROYED, _SIGNAL = SIGNAL, _ABORTED = ABORTED, _DATALISTENERS = DATALISTENERS, _DISCARDED = DISCARDED, _ABORT = ABORT, _READ = READ, _RESUME = RESUME, _BUFFERPUSH = BUFFERPUSH, _BUFFERSHIFT = BUFFERSHIFT, _FLUSH = FLUSH, _FLUSHCHUNK = FLUSHCHUNK, _MAYBE_EMIT_END = MAYBE_EMIT_END, _EMITDATA = EMITDATA, _EMITEND = EMITEND, _EMITEND2 = EMITEND2, _Symbol_asyncIterator = Symbol.asyncIterator, _Symbol_iterator2 = Symbol.iterator, Minipass = /* @__PURE__ */ function(EventEmitter3) {
  "use strict";
  _inherits6(Minipass3, EventEmitter3);
  var _super = _create_super6(Minipass3);
  function Minipass3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    _class_call_check7(this, Minipass3);
    var _this, options = args[0] || {};
    if (_this = _super.call(this), _define_property10(_assert_this_initialized6(_this), _FLOWING, !1), _define_property10(_assert_this_initialized6(_this), _PAUSED, !1), _define_property10(_assert_this_initialized6(_this), _PIPES, []), _define_property10(_assert_this_initialized6(_this), _BUFFER, []), _define_property10(_assert_this_initialized6(_this), _OBJECTMODE, void 0), _define_property10(_assert_this_initialized6(_this), _ENCODING, void 0), _define_property10(_assert_this_initialized6(_this), _ASYNC, void 0), _define_property10(_assert_this_initialized6(_this), _DECODER, void 0), _define_property10(_assert_this_initialized6(_this), _EOF, !1), _define_property10(_assert_this_initialized6(_this), _EMITTED_END, !1), _define_property10(_assert_this_initialized6(_this), _EMITTING_END, !1), _define_property10(_assert_this_initialized6(_this), _CLOSED, !1), _define_property10(_assert_this_initialized6(_this), _EMITTED_ERROR, null), _define_property10(_assert_this_initialized6(_this), _BUFFERLENGTH, 0), _define_property10(_assert_this_initialized6(_this), _DESTROYED, !1), _define_property10(_assert_this_initialized6(_this), _SIGNAL, void 0), _define_property10(_assert_this_initialized6(_this), _ABORTED, !1), _define_property10(_assert_this_initialized6(_this), _DATALISTENERS, 0), _define_property10(_assert_this_initialized6(_this), _DISCARDED, !1), _define_property10(_assert_this_initialized6(_this), "writable", !0), _define_property10(_assert_this_initialized6(_this), "readable", !0), options.objectMode && typeof options.encoding == "string")
      throw new TypeError("Encoding and objectMode may not be used together");
    isObjectModeOptions(options) ? (_this[OBJECTMODE] = !0, _this[ENCODING] = null) : isEncodingOptions(options) ? (_this[ENCODING] = options.encoding, _this[OBJECTMODE] = !1) : (_this[OBJECTMODE] = !1, _this[ENCODING] = null), _this[ASYNC] = !!options.async, _this[DECODER] = _this[ENCODING] ? new import_string_decoder.StringDecoder(_this[ENCODING]) : null, options && options.debugExposeBuffer === !0 && Object.defineProperty(_assert_this_initialized6(_this), "buffer", {
      get: function() {
        return _this[BUFFER];
      }
    }), options && options.debugExposePipes === !0 && Object.defineProperty(_assert_this_initialized6(_this), "pipes", {
      get: function() {
        return _this[PIPES];
      }
    });
    var signal = options.signal;
    return signal && (_this[SIGNAL] = signal, signal.aborted ? _this[ABORT]() : signal.addEventListener("abort", function() {
      return _this[ABORT]();
    })), _this;
  }
  return _create_class5(Minipass3, [
    {
      key: "bufferLength",
      get: (
        /**
        * The amount of data stored in the buffer waiting to be read.
        *
        * For Buffer strings, this will be the total byte length.
        * For string encoding streams, this will be the string character length,
        * according to JavaScript's `string.length` logic.
        * For objectMode streams, this is a count of the items waiting to be
        * emitted.
        */
        function() {
          return this[BUFFERLENGTH];
        }
      )
    },
    {
      key: "encoding",
      get: (
        /**
        * The `BufferEncoding` currently in use, or `null`
        */
        function() {
          return this[ENCODING];
        }
      ),
      set: (
        /**
        * @deprecated - This is a read only property
        */
        function(_enc) {
          throw new Error("Encoding must be set at instantiation time");
        }
      )
    },
    {
      /**
      * @deprecated - Encoding may only be set at instantiation time
      */
      key: "setEncoding",
      value: function(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
    },
    {
      key: "objectMode",
      get: (
        /**
        * True if this is an objectMode stream
        */
        function() {
          return this[OBJECTMODE];
        }
      ),
      set: (
        /**
        * @deprecated - This is a read-only property
        */
        function(_om) {
          throw new Error("objectMode must be set at instantiation time");
        }
      )
    },
    {
      key: "async",
      get: (
        /**
        * true if this is an async stream
        */
        function() {
          return this[ASYNC];
        }
      )
    },
    {
      key: "async",
      set: (
        /**
        * Set to true to make this stream async.
        *
        * Once set, it cannot be unset, as this would potentially cause incorrect
        * behavior.  Ie, a sync stream can be made async, but an async stream
        * cannot be safely made sync.
        */
        function(a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
      )
    },
    {
      // drop everything and get out of the flow completely
      key: _ABORT,
      value: function() {
        var _this_SIGNAL, _this_SIGNAL1;
        this[ABORTED] = !0, this.emit("abort", (_this_SIGNAL = this[SIGNAL]) === null || _this_SIGNAL === void 0 ? void 0 : _this_SIGNAL.reason), this.destroy((_this_SIGNAL1 = this[SIGNAL]) === null || _this_SIGNAL1 === void 0 ? void 0 : _this_SIGNAL1.reason);
      }
    },
    {
      key: "aborted",
      get: (
        /**
        * True if the stream has been aborted.
        */
        function() {
          return this[ABORTED];
        }
      ),
      set: (
        /**
        * No-op setter. Stream aborted status is set via the AbortSignal provided
        * in the constructor options.
        */
        function(_) {
        }
      )
    },
    {
      key: "write",
      value: function(chunk, encoding, cb) {
        var _this_DECODER;
        if (this[ABORTED])
          return !1;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED])
          return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), {
            code: "ERR_STREAM_DESTROYED"
          })), !0;
        typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
        var fn = this[ASYNC] ? defer : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBufferLike(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk != "string")
            throw new Error("Non-contiguous data written to non-objectMode stream");
        }
        return this[OBJECTMODE] ? (this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !(!((_this_DECODER = this[DECODER]) === null || _this_DECODER === void 0) && _this_DECODER.lastNeed)) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING] && (chunk = this[DECODER].write(chunk)), this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : (this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]);
      }
    },
    {
      /**
      * Low-level explicit read method.
      *
      * In objectMode, the argument is ignored, and one item is returned if
      * available.
      *
      * `n` is the number of bytes (or in the case of encoding streams,
      * characters) to consume. If `n` is not provided, then the entire buffer
      * is returned, or `null` is returned if no data is available.
      *
      * If `n` is greater that the amount of data in the internal buffer,
      * then `null` is returned.
      */
      key: "read",
      value: function(n) {
        if (this[DESTROYED])
          return null;
        if (this[DISCARDED] = !1, this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH])
          return this[MAYBE_EMIT_END](), null;
        this[OBJECTMODE] && (n = null), this[BUFFER].length > 1 && !this[OBJECTMODE] && (this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ]);
        var ret = this[READ](n || null, this[BUFFER][0]);
        return this[MAYBE_EMIT_END](), ret;
      }
    },
    {
      key: _READ,
      value: function(n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          var c = chunk;
          n === c.length || n === null ? this[BUFFERSHIFT]() : typeof c == "string" ? (this[BUFFER][0] = c.slice(n), chunk = c.slice(0, n), this[BUFFERLENGTH] -= n) : (this[BUFFER][0] = c.subarray(n), chunk = c.subarray(0, n), this[BUFFERLENGTH] -= n);
        }
        return this.emit("data", chunk), !this[BUFFER].length && !this[EOF] && this.emit("drain"), chunk;
      }
    },
    {
      key: "end",
      value: function(chunk, encoding, cb) {
        return typeof chunk == "function" && (cb = chunk, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk !== void 0 && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF] = !0, this.writable = !1, (this[FLOWING] || !this[PAUSED]) && this[MAYBE_EMIT_END](), this;
      }
    },
    {
      // don't let the internal resume be overwritten
      key: _RESUME,
      value: function() {
        this[DESTROYED] || (!this[DATALISTENERS] && !this[PIPES].length && (this[DISCARDED] = !0), this[PAUSED] = !1, this[FLOWING] = !0, this.emit("resume"), this[BUFFER].length ? this[FLUSH]() : this[EOF] ? this[MAYBE_EMIT_END]() : this.emit("drain"));
      }
    },
    {
      /**
      * Resume the stream if it is currently in a paused state
      *
      * If called when there are no pipe destinations or `data` event listeners,
      * this will place the stream in a "discarded" state, where all data will
      * be thrown away. The discarded state is removed if a pipe destination or
      * data handler is added, if pause() is called, or if any synchronous or
      * asynchronous iteration is started.
      */
      key: "resume",
      value: function() {
        return this[RESUME]();
      }
    },
    {
      /**
      * Pause the stream
      */
      key: "pause",
      value: function() {
        this[FLOWING] = !1, this[PAUSED] = !0, this[DISCARDED] = !1;
      }
    },
    {
      key: "destroyed",
      get: (
        /**
        * true if the stream has been forcibly destroyed
        */
        function() {
          return this[DESTROYED];
        }
      )
    },
    {
      key: "flowing",
      get: (
        /**
        * true if the stream is currently in a flowing state, meaning that
        * any writes will be immediately emitted.
        */
        function() {
          return this[FLOWING];
        }
      )
    },
    {
      key: "paused",
      get: (
        /**
        * true if the stream is currently in a paused state
        */
        function() {
          return this[PAUSED];
        }
      )
    },
    {
      key: _BUFFERPUSH,
      value: function(chunk) {
        this[OBJECTMODE] ? this[BUFFERLENGTH] += 1 : this[BUFFERLENGTH] += chunk.length, this[BUFFER].push(chunk);
      }
    },
    {
      key: _BUFFERSHIFT,
      value: function() {
        return this[OBJECTMODE] ? this[BUFFERLENGTH] -= 1 : this[BUFFERLENGTH] -= this[BUFFER][0].length, this[BUFFER].shift();
      }
    },
    {
      key: _FLUSH,
      value: function() {
        var noDrain = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        do
          ;
        while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        !noDrain && !this[BUFFER].length && !this[EOF] && this.emit("drain");
      }
    },
    {
      key: _FLUSHCHUNK,
      value: function(chunk) {
        return this.emit("data", chunk), this[FLOWING];
      }
    },
    {
      /**
      * Pipe all data emitted by this stream into the destination provided.
      *
      * Triggers the flow of data.
      */
      key: "pipe",
      value: function(dest, opts) {
        var _this = this;
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = !1;
        var ended = this[EMITTED_END];
        return opts = opts || {}, dest === proc.stdout || dest === proc.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES].push(opts.proxyErrors ? new PipeProxyErrors(this, dest, opts) : new Pipe(this, dest, opts)), this[ASYNC] ? defer(function() {
          return _this[RESUME]();
        }) : this[RESUME]()), dest;
      }
    },
    {
      /**
      * Fully unhook a piped destination stream.
      *
      * If the destination stream was the only consumer of this stream (ie,
      * there are no other piped destinations or `'data'` event listeners)
      * then the flow of data will stop until there is another consumer or
      * {@link Minipass#resume} is explicitly called.
      */
      key: "unpipe",
      value: function(dest) {
        var p = this[PIPES].find(function(p2) {
          return p2.dest === dest;
        });
        p && (this[PIPES].length === 1 ? (this[FLOWING] && this[DATALISTENERS] === 0 && (this[FLOWING] = !1), this[PIPES] = []) : this[PIPES].splice(this[PIPES].indexOf(p), 1), p.unpipe());
      }
    },
    {
      /**
      * Alias for {@link Minipass#on}
      */
      key: "addListener",
      value: function(ev, handler) {
        return this.on(ev, handler);
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.on`, with the following
      * behavior differences to prevent data loss and unnecessary hangs:
      *
      * - Adding a 'data' event handler will trigger the flow of data
      *
      * - Adding a 'readable' event handler when there is data waiting to be read
      *   will cause 'readable' to be emitted immediately.
      *
      * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
      *   already passed will cause the event to be emitted immediately and all
      *   handlers removed.
      *
      * - Adding an 'error' event handler after an error has been emitted will
      *   cause the event to be re-emitted immediately with the error previously
      *   raised.
      */
      key: "on",
      value: function(ev, handler) {
        var _this = this, ret = _get2(_get_prototype_of6(Minipass3.prototype), "on", this).call(this, ev, handler);
        if (ev === "data")
          this[DISCARDED] = !1, this[DATALISTENERS]++, !this[PIPES].length && !this[FLOWING] && this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, "readable");
        else if (isEndish(ev) && this[EMITTED_END])
          _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, ev), this.removeAllListeners(ev);
        else if (ev === "error" && this[EMITTED_ERROR]) {
          var h = handler;
          this[ASYNC] ? defer(function() {
            return h.call(_this, _this[EMITTED_ERROR]);
          }) : h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
    },
    {
      /**
      * Alias for {@link Minipass#off}
      */
      key: "removeListener",
      value: function(ev, handler) {
        return this.off(ev, handler);
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.off`
      *
      * If a 'data' event handler is removed, and it was the last consumer
      * (ie, there are no pipe destinations or other 'data' event listeners),
      * then the flow of data will stop until there is another consumer or
      * {@link Minipass#resume} is explicitly called.
      */
      key: "off",
      value: function(ev, handler) {
        var ret = _get2(_get_prototype_of6(Minipass3.prototype), "off", this).call(this, ev, handler);
        return ev === "data" && (this[DATALISTENERS] = this.listeners("data").length, this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.removeAllListeners`
      *
      * If all 'data' event handlers are removed, and they were the last consumer
      * (ie, there are no pipe destinations), then the flow of data will stop
      * until there is another consumer or {@link Minipass#resume} is explicitly
      * called.
      */
      key: "removeAllListeners",
      value: function(ev) {
        var ret = _get2(_get_prototype_of6(Minipass3.prototype), "removeAllListeners", this).call(this, ev);
        return (ev === "data" || ev === void 0) && (this[DATALISTENERS] = 0, !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
      }
    },
    {
      key: "emittedEnd",
      get: (
        /**
        * true if the 'end' event has been emitted
        */
        function() {
          return this[EMITTED_END];
        }
      )
    },
    {
      key: _MAYBE_EMIT_END,
      value: function() {
        !this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF] && (this[EMITTING_END] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED] && this.emit("close"), this[EMITTING_END] = !1);
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.emit`, with the following
      * behavior differences to prevent data loss and unnecessary hangs:
      *
      * If the stream has been destroyed, and the event is something other
      * than 'close' or 'error', then `false` is returned and no handlers
      * are called.
      *
      * If the event is 'end', and has already been emitted, then the event
      * is ignored. If the stream is in a paused or non-flowing state, then
      * the event will be deferred until data flow resumes. If the stream is
      * async, then handlers will be called on the next tick rather than
      * immediately.
      *
      * If the event is 'close', and 'end' has not yet been emitted, then
      * the event will be deferred until after 'end' is emitted.
      *
      * If the event is 'error', and an AbortSignal was provided for the stream,
      * and there are no listeners, then the event is ignored, matching the
      * behavior of node core streams in the presense of an AbortSignal.
      *
      * If the event is 'finish' or 'prefinish', then all listeners will be
      * removed after emitting the event, to prevent double-firing.
      */
      key: "emit",
      value: function(ev) {
        for (var _this = this, _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          args[_key - 1] = arguments[_key];
        var _$_get, data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return !1;
        if (ev === "data")
          return !this[OBJECTMODE] && !data ? !1 : this[ASYNC] ? (defer(function() {
            return _this[EMITDATA](data);
          }), !0) : this[EMITDATA](data);
        if (ev === "end")
          return this[EMITEND]();
        if (ev === "close") {
          if (this[CLOSED] = !0, !this[EMITTED_END] && !this[DESTROYED])
            return !1;
          var ret = _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, "close");
          return this.removeAllListeners("close"), ret;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data, _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, ERROR, data);
          var ret1 = !this[SIGNAL] || this.listeners("error").length ? _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, "error", data) : !1;
          return this[MAYBE_EMIT_END](), ret1;
        } else if (ev === "resume") {
          var ret2 = _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, "resume");
          return this[MAYBE_EMIT_END](), ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          var ret3 = _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, ev);
          return this.removeAllListeners(ev), ret3;
        }
        var ret4 = (_$_get = _get2(_get_prototype_of6(Minipass3.prototype), "emit", this)).call.apply(_$_get, [
          this,
          ev
        ].concat(_to_consumable_array8(args)));
        return this[MAYBE_EMIT_END](), ret4;
      }
    },
    {
      key: _EMITDATA,
      value: function(data) {
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = this[PIPES][Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var p = _step.value;
            p.dest.write(data) === !1 && this.pause();
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var ret = this[DISCARDED] ? !1 : _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, "data", data);
        return this[MAYBE_EMIT_END](), ret;
      }
    },
    {
      key: _EMITEND,
      value: function() {
        var _this = this;
        return this[EMITTED_END] ? !1 : (this[EMITTED_END] = !0, this.readable = !1, this[ASYNC] ? (defer(function() {
          return _this[EMITEND2]();
        }), !0) : this[EMITEND2]());
      }
    },
    {
      key: _EMITEND2,
      value: function() {
        if (this[DECODER]) {
          var data = this[DECODER].end();
          if (data) {
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this[PIPES][Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var p = _step.value;
                p.dest.write(data);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            this[DISCARDED] || _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, "data", data);
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = this[PIPES][Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var p1 = _step1.value;
            p1.end();
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        var ret = _get2(_get_prototype_of6(Minipass3.prototype), "emit", this).call(this, "end");
        return this.removeAllListeners("end"), ret;
      }
    },
    {
      key: "collect",
      value: (
        /**
        * Return a Promise that resolves to an array of all emitted data once
        * the stream ends.
        */
        function() {
          var _this = this;
          return _async_to_generator6(function() {
            var buf, p;
            return _ts_generator6(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return buf = Object.assign([], {
                    dataLength: 0
                  }), _this[OBJECTMODE] || (buf.dataLength = 0), p = _this.promise(), _this.on("data", function(c) {
                    buf.push(c), _this[OBJECTMODE] || (buf.dataLength += c.length);
                  }), [
                    4,
                    p
                  ];
                case 1:
                  return _state.sent(), [
                    2,
                    buf
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "concat",
      value: (
        /**
        * Return a Promise that resolves to the concatenation of all emitted data
        * once the stream ends.
        *
        * Not allowed on objectMode streams.
        */
        function() {
          var _this = this;
          return _async_to_generator6(function() {
            var buf;
            return _ts_generator6(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (_this[OBJECTMODE])
                    throw new Error("cannot concat in objectMode");
                  return [
                    4,
                    _this.collect()
                  ];
                case 1:
                  return buf = _state.sent(), [
                    2,
                    _this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "promise",
      value: (
        /**
        * Return a void Promise that resolves once the stream ends.
        */
        function() {
          var _this = this;
          return _async_to_generator6(function() {
            return _ts_generator6(this, function(_state) {
              return [
                2,
                new Promise(function(resolve7, reject) {
                  _this.on(DESTROYED, function() {
                    return reject(new Error("stream destroyed"));
                  }), _this.on("error", function(er) {
                    return reject(er);
                  }), _this.on("end", function() {
                    return resolve7();
                  });
                })
              ];
            });
          })();
        }
      )
    },
    {
      /**
      * Asynchronous `for await of` iteration.
      *
      * This will continue emitting all chunks until the stream terminates.
      */
      key: _Symbol_asyncIterator,
      value: function() {
        var _this = this;
        this[DISCARDED] = !1;
        var stopped = !1, _this1 = this, stop = function() {
          var _ref = _async_to_generator6(function() {
            return _ts_generator6(this, function(_state) {
              return _this1.pause(), stopped = !0, [
                2,
                {
                  value: void 0,
                  done: !0
                }
              ];
            });
          });
          return function() {
            return _ref.apply(this, arguments);
          };
        }(), next = function() {
          if (stopped)
            return stop();
          var res = _this.read();
          if (res !== null)
            return Promise.resolve({
              done: !1,
              value: res
            });
          if (_this[EOF])
            return stop();
          var resolve7, reject, onerr = function(er) {
            _this.off("data", ondata), _this.off("end", onend), _this.off(DESTROYED, ondestroy), stop(), reject(er);
          }, ondata = function(value2) {
            _this.off("error", onerr), _this.off("end", onend), _this.off(DESTROYED, ondestroy), _this.pause(), resolve7({
              value: value2,
              done: !!_this[EOF]
            });
          }, onend = function() {
            _this.off("error", onerr), _this.off("data", ondata), _this.off(DESTROYED, ondestroy), stop(), resolve7({
              done: !0,
              value: void 0
            });
          }, ondestroy = function() {
            return onerr(new Error("stream destroyed"));
          };
          return new Promise(function(res2, rej) {
            reject = rej, resolve7 = res2, _this.once(DESTROYED, ondestroy), _this.once("error", onerr), _this.once("end", onend), _this.once("data", ondata);
          });
        };
        return _define_property10({
          next,
          throw: stop,
          return: stop
        }, Symbol.asyncIterator, function() {
          return this;
        });
      }
    },
    {
      /**
      * Synchronous `for of` iteration.
      *
      * The iteration will terminate when the internal buffer runs out, even
      * if the stream has not yet terminated.
      */
      key: _Symbol_iterator2,
      value: function() {
        var _this = this;
        this[DISCARDED] = !1;
        var stopped = !1, stop = function() {
          return _this.pause(), _this.off(ERROR, stop), _this.off(DESTROYED, stop), _this.off("end", stop), stopped = !0, {
            done: !0,
            value: void 0
          };
        }, next = function() {
          if (stopped)
            return stop();
          var value2 = _this.read();
          return value2 === null ? stop() : {
            done: !1,
            value: value2
          };
        };
        return this.once("end", stop), this.once(ERROR, stop), this.once(DESTROYED, stop), _define_property10({
          next,
          throw: stop,
          return: stop
        }, Symbol.iterator, function() {
          return this;
        });
      }
    },
    {
      /**
      * Destroy a stream, preventing it from being used for any further purpose.
      *
      * If the stream has a `close()` method, then it will be called on
      * destruction.
      *
      * After destruction, any attempt to write data, read data, or emit most
      * events will be ignored.
      *
      * If an error argument is provided, then it will be emitted in an
      * 'error' event.
      */
      key: "destroy",
      value: function(er) {
        if (this[DESTROYED])
          return er ? this.emit("error", er) : this.emit(DESTROYED), this;
        this[DESTROYED] = !0, this[DISCARDED] = !0, this[BUFFER].length = 0, this[BUFFERLENGTH] = 0;
        var wc = this;
        return typeof wc.close == "function" && !this[CLOSED] && wc.close(), er ? this.emit("error", er) : this.emit(DESTROYED), this;
      }
    }
  ], [
    {
      key: "isStream",
      get: (
        /**
        * Alias for {@link isStream}
        *
        * Former export location, maintained for backwards compatibility.
        *
        * @deprecated
        */
        function() {
          return isStream;
        }
      )
    }
  ]), Minipass3;
}(import_events.EventEmitter);

// ../../node_modules/path-scurry/dist/mjs/index.js
function _array_like_to_array12(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes10(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _assert_this_initialized7(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function asyncGeneratorStep7(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator7(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep7(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep7(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _check_private_redeclaration3(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _class_apply_descriptor_get3(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _class_apply_descriptor_set3(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _class_call_check8(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _class_extract_field_descriptor3(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}
function _class_private_field_get3(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor3(receiver, privateMap, "get");
  return _class_apply_descriptor_get3(receiver, descriptor);
}
function _class_private_field_init3(obj, privateMap, value) {
  _check_private_redeclaration3(obj, privateMap), privateMap.set(obj, value);
}
function _class_private_field_set3(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor3(receiver, privateMap, "set");
  return _class_apply_descriptor_set3(receiver, descriptor, value), value;
}
function _class_private_method_get3(receiver, privateSet, fn) {
  if (!privateSet.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return fn;
}
function _class_private_method_init3(obj, privateSet) {
  _check_private_redeclaration3(obj, privateSet), privateSet.add(obj);
}
function _defineProperties6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class6(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties6(Constructor.prototype, protoProps), staticProps && _defineProperties6(Constructor, staticProps), Constructor;
}
function _define_property11(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _get_prototype_of7(o) {
  return _get_prototype_of7 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of7(o);
}
function _inherits7(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of7(subClass, superClass);
}
function _instanceof7(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array_limit10(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest10() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property11(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props5(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _possible_constructor_return7(self, call) {
  return call && (_type_of8(call) === "object" || typeof call == "function") ? call : _assert_this_initialized7(self);
}
function _set_prototype_of7(o, p) {
  return _set_prototype_of7 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of7(o, p);
}
function _sliced_to_array10(arr, i) {
  return _array_with_holes10(arr) || _iterable_to_array_limit10(arr, i) || _unsupported_iterable_to_array12(arr, i) || _non_iterable_rest10();
}
function _type_of8(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array12(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array12(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array12(o, minLen);
  }
}
function _is_native_reflect_construct7() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super7(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct7();
  return function() {
    var Super = _get_prototype_of7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return7(this, result);
  };
}
function _ts_generator7(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var realpathSync = import_fs2.realpathSync.native, defaultFS = {
  lstatSync: import_fs2.lstatSync,
  readdir: import_fs2.readdir,
  readdirSync: import_fs2.readdirSync,
  readlinkSync: import_fs2.readlinkSync,
  realpathSync,
  promises: {
    lstat: import_promises.lstat,
    readdir: import_promises.readdir,
    readlink: import_promises.readlink,
    realpath: import_promises.realpath
  }
}, fsFromOption = function(fsOption) {
  return !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : _object_spread_props5(_object_spread8({}, defaultFS, fsOption), {
    promises: _object_spread8({}, defaultFS.promises, fsOption.promises || {})
  });
}, uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i, uncToDrive = function(rootPath) {
  return rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
}, eitherSep = /[\\\/]/, UNKNOWN = 0, IFIFO = 1, IFCHR = 2, IFDIR = 4, IFBLK = 6, IFREG = 8, IFLNK = 10, IFSOCK = 12, IFMT = 15, IFMT_UNKNOWN = ~IFMT, READDIR_CALLED = 16, LSTAT_CALLED = 32, ENOTDIR = 64, ENOENT = 128, ENOREADLINK = 256, ENOREALPATH = 512, ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH, TYPEMASK = 1023, entToType = function(s) {
  return s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
}, normalizeCache = /* @__PURE__ */ new Map(), normalize = function(s) {
  var c = normalizeCache.get(s);
  if (c)
    return c;
  var n = s.normalize("NFKD");
  return normalizeCache.set(s, n), n;
}, normalizeNocaseCache = /* @__PURE__ */ new Map(), normalizeNocase = function(s) {
  var c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  var n = normalize(s.toLowerCase());
  return normalizeNocaseCache.set(s, n), n;
}, ResolveCache = /* @__PURE__ */ function(LRUCache2) {
  "use strict";
  _inherits7(ResolveCache2, LRUCache2);
  var _super = _create_super7(ResolveCache2);
  function ResolveCache2() {
    return _class_call_check8(this, ResolveCache2), _super.call(this, {
      max: 256
    });
  }
  return ResolveCache2;
}(LRUCache), ChildrenCache = /* @__PURE__ */ function(LRUCache2) {
  "use strict";
  _inherits7(ChildrenCache2, LRUCache2);
  var _super = _create_super7(ChildrenCache2);
  function ChildrenCache2() {
    var maxSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16384;
    return _class_call_check8(this, ChildrenCache2), _super.call(this, {
      maxSize,
      // parent + children
      sizeCalculation: function(a) {
        return a.length + 1;
      }
    });
  }
  return ChildrenCache2;
}(LRUCache), setAsCwd = Symbol("PathScurry setAsCwd"), _fs = /* @__PURE__ */ new WeakMap(), _dev = /* @__PURE__ */ new WeakMap(), _mode = /* @__PURE__ */ new WeakMap(), _nlink = /* @__PURE__ */ new WeakMap(), _uid = /* @__PURE__ */ new WeakMap(), _gid = /* @__PURE__ */ new WeakMap(), _rdev = /* @__PURE__ */ new WeakMap(), _blksize = /* @__PURE__ */ new WeakMap(), _ino = /* @__PURE__ */ new WeakMap(), _size2 = /* @__PURE__ */ new WeakMap(), _blocks = /* @__PURE__ */ new WeakMap(), _atimeMs = /* @__PURE__ */ new WeakMap(), _mtimeMs = /* @__PURE__ */ new WeakMap(), _ctimeMs = /* @__PURE__ */ new WeakMap(), _birthtimeMs = /* @__PURE__ */ new WeakMap(), _atime = /* @__PURE__ */ new WeakMap(), _mtime = /* @__PURE__ */ new WeakMap(), _ctime = /* @__PURE__ */ new WeakMap(), _birthtime = /* @__PURE__ */ new WeakMap(), _matchName = /* @__PURE__ */ new WeakMap(), _depth = /* @__PURE__ */ new WeakMap(), _fullpath = /* @__PURE__ */ new WeakMap(), _fullpathPosix = /* @__PURE__ */ new WeakMap(), _relative = /* @__PURE__ */ new WeakMap(), _relativePosix = /* @__PURE__ */ new WeakMap(), _type = /* @__PURE__ */ new WeakMap(), _children = /* @__PURE__ */ new WeakMap(), _linkTarget = /* @__PURE__ */ new WeakMap(), _realpath = /* @__PURE__ */ new WeakMap(), _resolveParts = /* @__PURE__ */ new WeakSet(), _readdirSuccess = /* @__PURE__ */ new WeakSet(), _markENOENT = /* @__PURE__ */ new WeakSet(), _markChildrenENOENT = /* @__PURE__ */ new WeakSet(), _markENOREALPATH = /* @__PURE__ */ new WeakSet(), _markENOTDIR = /* @__PURE__ */ new WeakSet(), _readdirFail = /* @__PURE__ */ new WeakSet(), _lstatFail = /* @__PURE__ */ new WeakSet(), _readlinkFail = /* @__PURE__ */ new WeakSet(), _readdirAddChild = /* @__PURE__ */ new WeakSet(), _readdirAddNewChild = /* @__PURE__ */ new WeakSet(), _readdirMaybePromoteChild = /* @__PURE__ */ new WeakSet(), _readdirPromoteChild = /* @__PURE__ */ new WeakSet(), _applyStat = /* @__PURE__ */ new WeakSet(), _onReaddirCB = /* @__PURE__ */ new WeakMap(), _readdirCBInFlight = /* @__PURE__ */ new WeakMap(), _callOnReaddirCB = /* @__PURE__ */ new WeakSet(), _asyncReaddirInFlight = /* @__PURE__ */ new WeakMap(), _setAsCwd = setAsCwd, PathBase = /* @__PURE__ */ function() {
  "use strict";
  function PathBase2(name) {
    var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UNKNOWN, root = arguments.length > 2 ? arguments[2] : void 0, roots = arguments.length > 3 ? arguments[3] : void 0, nocase = arguments.length > 4 ? arguments[4] : void 0, children = arguments.length > 5 ? arguments[5] : void 0, opts = arguments.length > 6 ? arguments[6] : void 0;
    _class_call_check8(this, PathBase2);
    var _this_parent;
    _class_private_method_init3(this, _resolveParts), _class_private_method_init3(this, _readdirSuccess), _class_private_method_init3(this, _markENOENT), _class_private_method_init3(this, _markChildrenENOENT), _class_private_method_init3(this, _markENOREALPATH), _class_private_method_init3(this, _markENOTDIR), _class_private_method_init3(this, _readdirFail), _class_private_method_init3(this, _lstatFail), _class_private_method_init3(this, _readlinkFail), _class_private_method_init3(this, _readdirAddChild), _class_private_method_init3(this, _readdirAddNewChild), _class_private_method_init3(this, _readdirMaybePromoteChild), _class_private_method_init3(this, _readdirPromoteChild), _class_private_method_init3(this, _applyStat), _class_private_method_init3(this, _callOnReaddirCB), _define_property11(this, "name", void 0), _define_property11(this, "root", void 0), _define_property11(this, "roots", void 0), _define_property11(this, "parent", void 0), _define_property11(this, "nocase", void 0), _class_private_field_init3(this, _fs, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _dev, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _mode, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _nlink, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _uid, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _gid, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _rdev, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _blksize, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _ino, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _size2, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _blocks, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _atimeMs, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _mtimeMs, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _ctimeMs, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _birthtimeMs, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _atime, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _mtime, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _ctime, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _birthtime, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _matchName, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _depth, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _fullpath, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _fullpathPosix, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _relative, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _relativePosix, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _type, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _children, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _linkTarget, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _realpath, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _onReaddirCB, {
      writable: !0,
      value: []
    }), _class_private_field_init3(this, _readdirCBInFlight, {
      writable: !0,
      value: !1
    }), _class_private_field_init3(this, _asyncReaddirInFlight, {
      writable: !0,
      value: void 0
    }), this.name = name, _class_private_field_set3(this, _matchName, nocase ? normalizeNocase(name) : normalize(name)), _class_private_field_set3(this, _type, type & TYPEMASK), this.nocase = nocase, this.roots = roots, this.root = root || this, _class_private_field_set3(this, _children, children), _class_private_field_set3(this, _fullpath, opts.fullpath), _class_private_field_set3(this, _relative, opts.relative), _class_private_field_set3(this, _relativePosix, opts.relativePosix), this.parent = opts.parent, this.parent ? _class_private_field_set3(this, _fs, _class_private_field_get3(_this_parent = this.parent, _fs)) : _class_private_field_set3(this, _fs, fsFromOption(opts.fs));
  }
  return _create_class6(PathBase2, [
    {
      key: "dev",
      get: function() {
        return _class_private_field_get3(this, _dev);
      }
    },
    {
      key: "mode",
      get: function() {
        return _class_private_field_get3(this, _mode);
      }
    },
    {
      key: "nlink",
      get: function() {
        return _class_private_field_get3(this, _nlink);
      }
    },
    {
      key: "uid",
      get: function() {
        return _class_private_field_get3(this, _uid);
      }
    },
    {
      key: "gid",
      get: function() {
        return _class_private_field_get3(this, _gid);
      }
    },
    {
      key: "rdev",
      get: function() {
        return _class_private_field_get3(this, _rdev);
      }
    },
    {
      key: "blksize",
      get: function() {
        return _class_private_field_get3(this, _blksize);
      }
    },
    {
      key: "ino",
      get: function() {
        return _class_private_field_get3(this, _ino);
      }
    },
    {
      key: "size",
      get: function() {
        return _class_private_field_get3(this, _size2);
      }
    },
    {
      key: "blocks",
      get: function() {
        return _class_private_field_get3(this, _blocks);
      }
    },
    {
      key: "atimeMs",
      get: function() {
        return _class_private_field_get3(this, _atimeMs);
      }
    },
    {
      key: "mtimeMs",
      get: function() {
        return _class_private_field_get3(this, _mtimeMs);
      }
    },
    {
      key: "ctimeMs",
      get: function() {
        return _class_private_field_get3(this, _ctimeMs);
      }
    },
    {
      key: "birthtimeMs",
      get: function() {
        return _class_private_field_get3(this, _birthtimeMs);
      }
    },
    {
      key: "atime",
      get: function() {
        return _class_private_field_get3(this, _atime);
      }
    },
    {
      key: "mtime",
      get: function() {
        return _class_private_field_get3(this, _mtime);
      }
    },
    {
      key: "ctime",
      get: function() {
        return _class_private_field_get3(this, _ctime);
      }
    },
    {
      key: "birthtime",
      get: function() {
        return _class_private_field_get3(this, _birthtime);
      }
    },
    {
      key: "path",
      get: (
        /**
        * This property is for compatibility with the Dirent class as of
        * Node v20, where Dirent['path'] refers to the path of the directory
        * that was passed to readdir.  So, somewhat counterintuitively, this
        * property refers to the *parent* path, not the path object itself.
        * For root entries, it's the path to the entry itself.
        */
        function() {
          return (this.parent || this).fullpath();
        }
      )
    },
    {
      /**
      * Returns the depth of the Path object from its root.
      *
      * For example, a path at `/foo/bar` would have a depth of 2.
      */
      key: "depth",
      value: function() {
        return _class_private_field_get3(this, _depth) !== void 0 ? _class_private_field_get3(this, _depth) : this.parent ? _class_private_field_set3(this, _depth, this.parent.depth() + 1) : _class_private_field_set3(this, _depth, 0);
      }
    },
    {
      /**
      * @internal
      */
      key: "childrenCache",
      value: function() {
        return _class_private_field_get3(this, _children);
      }
    },
    {
      /**
      * Get the Path object referenced by the string path, resolved from this Path
      */
      key: "resolve",
      value: function(path6) {
        var _this_getRoot;
        if (!path6)
          return this;
        var rootPath = this.getRootString(path6), dir = path6.substring(rootPath.length), dirParts = dir.split(this.splitSep), result = rootPath ? _class_private_method_get3(_this_getRoot = this.getRoot(rootPath), _resolveParts, resolveParts).call(_this_getRoot, dirParts) : _class_private_method_get3(this, _resolveParts, resolveParts).call(this, dirParts);
        return result;
      }
    },
    {
      /**
      * Returns the cached children Path objects, if still available.  If they
      * have fallen out of the cache, then returns an empty array, and resets the
      * READDIR_CALLED bit, so that future calls to readdir() will require an fs
      * lookup.
      *
      * @internal
      */
      key: "children",
      value: function() {
        var cached = _class_private_field_get3(this, _children).get(this);
        if (cached)
          return cached;
        var children2 = Object.assign([], {
          provisional: 0
        });
        return _class_private_field_get3(this, _children).set(this, children2), _class_private_field_set3(this, _type, _class_private_field_get3(this, _type) & ~READDIR_CALLED), children2;
      }
    },
    {
      /**
      * Resolves a path portion and returns or creates the child Path.
      *
      * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
      * `'..'`.
      *
      * This should not be called directly.  If `pathPart` contains any path
      * separators, it will lead to unsafe undefined behavior.
      *
      * Use `Path.resolve()` instead.
      *
      * @internal
      */
      key: "child",
      value: function(pathPart, opts) {
        var _pchild;
        if (pathPart === "" || pathPart === ".")
          return this;
        if (pathPart === "..")
          return this.parent || this;
        var children = this.children(), name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var p = _step.value;
            if (_class_private_field_get3(p, _matchName) === name)
              return p;
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var s = this.parent ? this.sep : "", fullpath = _class_private_field_get3(this, _fullpath) ? _class_private_field_get3(this, _fullpath) + s + pathPart : void 0, pchild = this.newChild(pathPart, UNKNOWN, _object_spread_props5(_object_spread8({}, opts), {
          parent: this,
          fullpath
        }));
        return this.canReaddir() || _class_private_field_set3(_pchild = pchild, _type, _class_private_field_get3(_pchild, _type) | ENOENT), children.push(pchild), pchild;
      }
    },
    {
      /**
      * The relative path from the cwd. If it does not share an ancestor with
      * the cwd, then this ends up being equivalent to the fullpath()
      */
      key: "relative",
      value: function() {
        if (_class_private_field_get3(this, _relative) !== void 0)
          return _class_private_field_get3(this, _relative);
        var name = this.name, p = this.parent;
        if (!p)
          return _class_private_field_set3(this, _relative, this.name);
        var pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name;
      }
    },
    {
      /**
      * The relative path from the cwd, using / as the path separator.
      * If it does not share an ancestor with
      * the cwd, then this ends up being equivalent to the fullpathPosix()
      * On posix systems, this is identical to relative().
      */
      key: "relativePosix",
      value: function() {
        if (this.sep === "/")
          return this.relative();
        if (_class_private_field_get3(this, _relativePosix) !== void 0)
          return _class_private_field_get3(this, _relativePosix);
        var name = this.name, p = this.parent;
        if (!p)
          return _class_private_field_set3(this, _relativePosix, this.fullpathPosix());
        var pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name;
      }
    },
    {
      /**
      * The fully resolved path string for this Path entry
      */
      key: "fullpath",
      value: function() {
        if (_class_private_field_get3(this, _fullpath) !== void 0)
          return _class_private_field_get3(this, _fullpath);
        var name = this.name, p = this.parent;
        if (!p)
          return _class_private_field_set3(this, _fullpath, this.name);
        var pv = p.fullpath(), fp = pv + (p.parent ? this.sep : "") + name;
        return _class_private_field_set3(this, _fullpath, fp);
      }
    },
    {
      /**
      * On platforms other than windows, this is identical to fullpath.
      *
      * On windows, this is overridden to return the forward-slash form of the
      * full UNC path.
      */
      key: "fullpathPosix",
      value: function() {
        if (_class_private_field_get3(this, _fullpathPosix) !== void 0)
          return _class_private_field_get3(this, _fullpathPosix);
        if (this.sep === "/")
          return _class_private_field_set3(this, _fullpathPosix, this.fullpath());
        if (!this.parent) {
          var p = this.fullpath().replace(/\\/g, "/");
          return /^[a-z]:\//i.test(p) ? _class_private_field_set3(this, _fullpathPosix, "//?/".concat(p)) : _class_private_field_set3(this, _fullpathPosix, p);
        }
        var p1 = this.parent, pfpp = p1.fullpathPosix(), fpp = pfpp + (!pfpp || !p1.parent ? "" : "/") + this.name;
        return _class_private_field_set3(this, _fullpathPosix, fpp);
      }
    },
    {
      /**
      * Is the Path of an unknown type?
      *
      * Note that we might know *something* about it if there has been a previous
      * filesystem operation, for example that it does not exist, or is not a
      * link, or whether it has child entries.
      */
      key: "isUnknown",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFMT) === UNKNOWN;
      }
    },
    {
      key: "isType",
      value: function(type) {
        return this["is".concat(type)]();
      }
    },
    {
      key: "getType",
      value: function() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
    },
    {
      /* c8 ignore stop */
      /**
      * Is the Path a regular file?
      */
      key: "isFile",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFMT) === IFREG;
      }
    },
    {
      /**
      * Is the Path a directory?
      */
      key: "isDirectory",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFMT) === IFDIR;
      }
    },
    {
      /**
      * Is the path a character device?
      */
      key: "isCharacterDevice",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFMT) === IFCHR;
      }
    },
    {
      /**
      * Is the path a block device?
      */
      key: "isBlockDevice",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFMT) === IFBLK;
      }
    },
    {
      /**
      * Is the path a FIFO pipe?
      */
      key: "isFIFO",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFMT) === IFIFO;
      }
    },
    {
      /**
      * Is the path a socket?
      */
      key: "isSocket",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFMT) === IFSOCK;
      }
    },
    {
      /**
      * Is the path a symbolic link?
      */
      key: "isSymbolicLink",
      value: function() {
        return (_class_private_field_get3(this, _type) & IFLNK) === IFLNK;
      }
    },
    {
      /**
      * Return the entry if it has been subject of a successful lstat, or
      * undefined otherwise.
      *
      * Does not read the filesystem, so an undefined result *could* simply
      * mean that we haven't called lstat on it.
      */
      key: "lstatCached",
      value: function() {
        return _class_private_field_get3(this, _type) & LSTAT_CALLED ? this : void 0;
      }
    },
    {
      /**
      * Return the cached link target if the entry has been the subject of a
      * successful readlink, or undefined otherwise.
      *
      * Does not read the filesystem, so an undefined result *could* just mean we
      * don't have any cached data. Only use it if you are very sure that a
      * readlink() has been called at some point.
      */
      key: "readlinkCached",
      value: function() {
        return _class_private_field_get3(this, _linkTarget);
      }
    },
    {
      /**
      * Returns the cached realpath target if the entry has been the subject
      * of a successful realpath, or undefined otherwise.
      *
      * Does not read the filesystem, so an undefined result *could* just mean we
      * don't have any cached data. Only use it if you are very sure that a
      * realpath() has been called at some point.
      */
      key: "realpathCached",
      value: function() {
        return _class_private_field_get3(this, _realpath);
      }
    },
    {
      /**
      * Returns the cached child Path entries array if the entry has been the
      * subject of a successful readdir(), or [] otherwise.
      *
      * Does not read the filesystem, so an empty array *could* just mean we
      * don't have any cached data. Only use it if you are very sure that a
      * readdir() has been called recently enough to still be valid.
      */
      key: "readdirCached",
      value: function() {
        var children = this.children();
        return children.slice(0, children.provisional);
      }
    },
    {
      /**
      * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
      * any indication that readlink will definitely fail.
      *
      * Returns false if the path is known to not be a symlink, if a previous
      * readlink failed, or if the entry does not exist.
      */
      key: "canReadlink",
      value: function() {
        if (_class_private_field_get3(this, _linkTarget))
          return !0;
        if (!this.parent)
          return !1;
        var ifmt = _class_private_field_get3(this, _type) & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || _class_private_field_get3(this, _type) & ENOREADLINK || _class_private_field_get3(this, _type) & ENOENT);
      }
    },
    {
      /**
      * Return true if readdir has previously been successfully called on this
      * path, indicating that cachedReaddir() is likely valid.
      */
      key: "calledReaddir",
      value: function() {
        return !!(_class_private_field_get3(this, _type) & READDIR_CALLED);
      }
    },
    {
      /**
      * Returns true if the path is known to not exist. That is, a previous lstat
      * or readdir failed to verify its existence when that would have been
      * expected, or a parent entry was marked either enoent or enotdir.
      */
      key: "isENOENT",
      value: function() {
        return !!(_class_private_field_get3(this, _type) & ENOENT);
      }
    },
    {
      /**
      * Return true if the path is a match for the given path name.  This handles
      * case sensitivity and unicode normalization.
      *
      * Note: even on case-sensitive systems, it is **not** safe to test the
      * equality of the `.name` property to determine whether a given pathname
      * matches, due to unicode normalization mismatches.
      *
      * Always use this method instead of testing the `path.name` property
      * directly.
      */
      key: "isNamed",
      value: function(n) {
        return this.nocase ? _class_private_field_get3(this, _matchName) === normalizeNocase(n) : _class_private_field_get3(this, _matchName) === normalize(n);
      }
    },
    {
      key: "readlink",
      value: (
        /**
        * Return the Path object corresponding to the target of a symbolic link.
        *
        * If the Path is not a symbolic link, or if the readlink call fails for any
        * reason, `undefined` is returned.
        *
        * Result is cached, and thus may be outdated if the filesystem is mutated.
        */
        function() {
          var _this = this;
          return _async_to_generator7(function() {
            var target, read, linkTarget, er;
            return _ts_generator7(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (target = _class_private_field_get3(_this, _linkTarget), target)
                    return [
                      2,
                      target
                    ];
                  if (!_this.canReadlink())
                    return [
                      2,
                      void 0
                    ];
                  if (!_this.parent)
                    return [
                      2,
                      void 0
                    ];
                  _state.label = 1;
                case 1:
                  return _state.trys.push([
                    1,
                    3,
                    ,
                    4
                  ]), [
                    4,
                    _class_private_field_get3(_this, _fs).promises.readlink(_this.fullpath())
                  ];
                case 2:
                  return read = _state.sent(), linkTarget = _this.parent.resolve(read), linkTarget ? [
                    2,
                    _class_private_field_set3(_this, _linkTarget, linkTarget)
                  ] : [
                    3,
                    4
                  ];
                case 3:
                  return er = _state.sent(), _class_private_method_get3(_this, _readlinkFail, readlinkFail).call(_this, er.code), [
                    2,
                    void 0
                  ];
                case 4:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      /**
      * Synchronous {@link PathBase.readlink}
      */
      key: "readlinkSync",
      value: function() {
        var target = _class_private_field_get3(this, _linkTarget);
        if (target)
          return target;
        if (this.canReadlink() && this.parent)
          try {
            var read = _class_private_field_get3(this, _fs).readlinkSync(this.fullpath()), linkTarget = this.parent.resolve(read);
            if (linkTarget)
              return _class_private_field_set3(this, _linkTarget, linkTarget);
          } catch (er) {
            _class_private_method_get3(this, _readlinkFail, readlinkFail).call(this, er.code);
            return;
          }
      }
    },
    {
      key: "lstat",
      value: (
        /**
        * Call lstat() on this Path, and update all known information that can be
        * determined.
        *
        * Note that unlike `fs.lstat()`, the returned value does not contain some
        * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
        * information is required, you will need to call `fs.lstat` yourself.
        *
        * If the Path refers to a nonexistent file, or if the lstat call fails for
        * any reason, `undefined` is returned.  Otherwise the updated Path object is
        * returned.
        *
        * Results are cached, and thus may be out of date if the filesystem is
        * mutated.
        */
        function() {
          var _this = this;
          return _async_to_generator7(function() {
            var _, _1, _tmp, er;
            return _ts_generator7(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (_class_private_field_get3(_this, _type) & ENOENT)
                    return [
                      3,
                      4
                    ];
                  _state.label = 1;
                case 1:
                  return _state.trys.push([
                    1,
                    3,
                    ,
                    4
                  ]), _1 = (_ = _class_private_method_get3(_this, _applyStat, applyStat)).call, _tmp = [
                    _this
                  ], [
                    4,
                    _class_private_field_get3(_this, _fs).promises.lstat(_this.fullpath())
                  ];
                case 2:
                  return _1.apply(_, _tmp.concat([
                    _state.sent()
                  ])), [
                    2,
                    _this
                  ];
                case 3:
                  return er = _state.sent(), _class_private_method_get3(_this, _lstatFail, lstatFail).call(_this, er.code), [
                    3,
                    4
                  ];
                case 4:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      /**
      * synchronous {@link PathBase.lstat}
      */
      key: "lstatSync",
      value: function() {
        if (!(_class_private_field_get3(this, _type) & ENOENT))
          try {
            return _class_private_method_get3(this, _applyStat, applyStat).call(this, _class_private_field_get3(this, _fs).lstatSync(this.fullpath())), this;
          } catch (er) {
            _class_private_method_get3(this, _lstatFail, lstatFail).call(this, er.code);
          }
      }
    },
    {
      /**
      * Standard node-style callback interface to get list of directory entries.
      *
      * If the Path cannot or does not contain any children, then an empty array
      * is returned.
      *
      * Results are cached, and thus may be out of date if the filesystem is
      * mutated.
      *
      * @param cb The callback called with (er, entries).  Note that the `er`
      * param is somewhat extraneous, as all readdir() errors are handled and
      * simply result in an empty set of entries being returned.
      * @param allowZalgo Boolean indicating that immediately known results should
      * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
      * zalgo at your peril, the dark pony lord is devious and unforgiving.
      */
      key: "readdirCB",
      value: function(cb) {
        var _this = this, allowZalgo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        if (!this.canReaddir()) {
          allowZalgo ? cb(null, []) : queueMicrotask(function() {
            return cb(null, []);
          });
          return;
        }
        var children = this.children();
        if (this.calledReaddir()) {
          var c = children.slice(0, children.provisional);
          allowZalgo ? cb(null, c) : queueMicrotask(function() {
            return cb(null, c);
          });
          return;
        }
        if (_class_private_field_get3(this, _onReaddirCB).push(cb), !_class_private_field_get3(this, _readdirCBInFlight)) {
          _class_private_field_set3(this, _readdirCBInFlight, !0);
          var fullpath = this.fullpath();
          _class_private_field_get3(this, _fs).readdir(fullpath, {
            withFileTypes: !0
          }, function(er, entries) {
            if (er)
              _class_private_method_get3(_this, _readdirFail, readdirFail).call(_this, er.code), children.provisional = 0;
            else {
              var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                  var e = _step.value;
                  _class_private_method_get3(_this, _readdirAddChild, readdirAddChild).call(_this, e, children);
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
              _class_private_method_get3(_this, _readdirSuccess, readdirSuccess).call(_this, children);
            }
            _class_private_method_get3(_this, _callOnReaddirCB, callOnReaddirCB).call(_this, children.slice(0, children.provisional));
          });
        }
      }
    },
    {
      key: "readdir",
      value: (
        /**
        * Return an array of known child entries.
        *
        * If the Path cannot or does not contain any children, then an empty array
        * is returned.
        *
        * Results are cached, and thus may be out of date if the filesystem is
        * mutated.
        */
        function() {
          var _this = this;
          return _async_to_generator7(function() {
            var children, fullpath, resolve7, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, e, err, er;
            return _ts_generator7(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return _this.canReaddir() ? (children = _this.children(), _this.calledReaddir() ? [
                    2,
                    children.slice(0, children.provisional)
                  ] : (fullpath = _this.fullpath(), _class_private_field_get3(_this, _asyncReaddirInFlight) ? [
                    4,
                    _class_private_field_get3(_this, _asyncReaddirInFlight)
                  ] : [
                    3,
                    2
                  ])) : [
                    2,
                    []
                  ];
                case 1:
                  return _state.sent(), [
                    3,
                    14
                  ];
                case 2:
                  resolve7 = function() {
                  }, _class_private_field_set3(_this, _asyncReaddirInFlight, new Promise(function(res) {
                    return resolve7 = res;
                  })), _state.label = 3;
                case 3:
                  _state.trys.push([
                    3,
                    12,
                    ,
                    13
                  ]), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 4;
                case 4:
                  return _state.trys.push([
                    4,
                    9,
                    10,
                    11
                  ]), [
                    4,
                    _class_private_field_get3(_this, _fs).promises.readdir(fullpath, {
                      withFileTypes: !0
                    })
                  ];
                case 5:
                  _iterator = _state.sent()[Symbol.iterator](), _state.label = 6;
                case 6:
                  if (_iteratorNormalCompletion2 = (_step = _iterator.next()).done)
                    return [
                      3,
                      8
                    ];
                  e = _step.value, _class_private_method_get3(_this, _readdirAddChild, readdirAddChild).call(_this, e, children), _state.label = 7;
                case 7:
                  return _iteratorNormalCompletion2 = !0, [
                    3,
                    6
                  ];
                case 8:
                  return [
                    3,
                    11
                  ];
                case 9:
                  return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                    3,
                    11
                  ];
                case 10:
                  try {
                    !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                  return [
                    7
                  ];
                case 11:
                  return _class_private_method_get3(_this, _readdirSuccess, readdirSuccess).call(_this, children), [
                    3,
                    13
                  ];
                case 12:
                  return er = _state.sent(), _class_private_method_get3(_this, _readdirFail, readdirFail).call(_this, er.code), children.provisional = 0, [
                    3,
                    13
                  ];
                case 13:
                  _class_private_field_set3(_this, _asyncReaddirInFlight, void 0), resolve7(), _state.label = 14;
                case 14:
                  return [
                    2,
                    children.slice(0, children.provisional)
                  ];
              }
            });
          })();
        }
      )
    },
    {
      /**
      * synchronous {@link PathBase.readdir}
      */
      key: "readdirSync",
      value: function() {
        if (!this.canReaddir())
          return [];
        var children = this.children();
        if (this.calledReaddir())
          return children.slice(0, children.provisional);
        var fullpath = this.fullpath();
        try {
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator = _class_private_field_get3(this, _fs).readdirSync(fullpath, {
              withFileTypes: !0
            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
              var e = _step.value;
              _class_private_method_get3(this, _readdirAddChild, readdirAddChild).call(this, e, children);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          _class_private_method_get3(this, _readdirSuccess, readdirSuccess).call(this, children);
        } catch (er) {
          _class_private_method_get3(this, _readdirFail, readdirFail).call(this, er.code), children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
    },
    {
      key: "canReaddir",
      value: function() {
        if (_class_private_field_get3(this, _type) & ENOCHILD)
          return !1;
        var ifmt = IFMT & _class_private_field_get3(this, _type);
        return ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK;
      }
    },
    {
      key: "shouldWalk",
      value: function(dirs, walkFilter) {
        return (_class_private_field_get3(this, _type) & IFDIR) === IFDIR && !(_class_private_field_get3(this, _type) & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
    },
    {
      key: "realpath",
      value: (
        /**
        * Return the Path object corresponding to path as resolved
        * by realpath(3).
        *
        * If the realpath call fails for any reason, `undefined` is returned.
        *
        * Result is cached, and thus may be outdated if the filesystem is mutated.
        * On success, returns a Path object.
        */
        function() {
          var _this = this;
          return _async_to_generator7(function() {
            var rp, _;
            return _ts_generator7(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (_class_private_field_get3(_this, _realpath))
                    return [
                      2,
                      _class_private_field_get3(_this, _realpath)
                    ];
                  if ((ENOREALPATH | ENOREADLINK | ENOENT) & _class_private_field_get3(_this, _type))
                    return [
                      2,
                      void 0
                    ];
                  _state.label = 1;
                case 1:
                  return _state.trys.push([
                    1,
                    3,
                    ,
                    4
                  ]), [
                    4,
                    _class_private_field_get3(_this, _fs).promises.realpath(_this.fullpath())
                  ];
                case 2:
                  return rp = _state.sent(), [
                    2,
                    _class_private_field_set3(_this, _realpath, _this.resolve(rp))
                  ];
                case 3:
                  return _ = _state.sent(), _class_private_method_get3(_this, _markENOREALPATH, markENOREALPATH).call(_this), [
                    3,
                    4
                  ];
                case 4:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      /**
      * Synchronous {@link realpath}
      */
      key: "realpathSync",
      value: function() {
        if (_class_private_field_get3(this, _realpath))
          return _class_private_field_get3(this, _realpath);
        if (!((ENOREALPATH | ENOREADLINK | ENOENT) & _class_private_field_get3(this, _type)))
          try {
            var rp = _class_private_field_get3(this, _fs).realpathSync(this.fullpath());
            return _class_private_field_set3(this, _realpath, this.resolve(rp));
          } catch {
            _class_private_method_get3(this, _markENOREALPATH, markENOREALPATH).call(this);
          }
      }
    },
    {
      /**
      * Internal method to mark this Path object as the scurry cwd,
      * called by {@link PathScurry#chdir}
      *
      * @internal
      */
      key: _setAsCwd,
      value: function(oldCwd) {
        if (oldCwd !== this) {
          for (var changed = /* @__PURE__ */ new Set([]), rp = [], p = this; p && p.parent; )
            changed.add(p), _class_private_field_set3(p, _relative, rp.join(this.sep)), _class_private_field_set3(p, _relativePosix, rp.join("/")), p = p.parent, rp.push("..");
          for (p = oldCwd; p && p.parent && !changed.has(p); )
            _class_private_field_set3(p, _relative, void 0), _class_private_field_set3(p, _relativePosix, void 0), p = p.parent;
        }
      }
    }
  ]), PathBase2;
}();
function resolveParts(dirParts) {
  var p = this, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _iterator = dirParts[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
      var part = _step.value;
      p = p.child(part);
    }
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
  return p;
}
function readdirSuccess(children) {
  var _children_p;
  _class_private_field_set3(this, _type, _class_private_field_get3(this, _type) | READDIR_CALLED);
  for (var p = children.provisional; p < children.length; p++)
    _class_private_method_get3(_children_p = children[p], _markENOENT, markENOENT).call(_children_p);
}
function markENOENT() {
  _class_private_field_get3(this, _type) & ENOENT || (_class_private_field_set3(this, _type, (_class_private_field_get3(this, _type) | ENOENT) & IFMT_UNKNOWN), _class_private_method_get3(this, _markChildrenENOENT, markChildrenENOENT).call(this));
}
function markChildrenENOENT() {
  var children = this.children();
  children.provisional = 0;
  var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
      var p = _step.value;
      _class_private_method_get3(p, _markENOENT, markENOENT).call(p);
    }
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
}
function markENOREALPATH() {
  _class_private_field_set3(this, _type, _class_private_field_get3(this, _type) | ENOREALPATH), _class_private_method_get3(this, _markENOTDIR, markENOTDIR).call(this);
}
function markENOTDIR() {
  if (!(_class_private_field_get3(this, _type) & ENOTDIR)) {
    var t = _class_private_field_get3(this, _type);
    (t & IFMT) === IFDIR && (t &= IFMT_UNKNOWN), _class_private_field_set3(this, _type, t | ENOTDIR), _class_private_method_get3(this, _markChildrenENOENT, markChildrenENOENT).call(this);
  }
}
function readdirFail() {
  var code = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  code === "ENOTDIR" || code === "EPERM" ? _class_private_method_get3(this, _markENOTDIR, markENOTDIR).call(this) : code === "ENOENT" ? _class_private_method_get3(this, _markENOENT, markENOENT).call(this) : this.children().provisional = 0;
}
function lstatFail() {
  var code = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (code === "ENOTDIR") {
    var p = this.parent;
    _class_private_method_get3(p, _markENOTDIR, markENOTDIR).call(p);
  } else
    code === "ENOENT" && _class_private_method_get3(this, _markENOENT, markENOENT).call(this);
}
function readlinkFail() {
  var code = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", _this_parent, ter = _class_private_field_get3(this, _type);
  ter |= ENOREADLINK, code === "ENOENT" && (ter |= ENOENT), (code === "EINVAL" || code === "UNKNOWN") && (ter &= IFMT_UNKNOWN), _class_private_field_set3(this, _type, ter), code === "ENOTDIR" && this.parent && _class_private_method_get3(_this_parent = this.parent, _markENOTDIR, markENOTDIR).call(_this_parent);
}
function readdirAddChild(e, c) {
  return _class_private_method_get3(this, _readdirMaybePromoteChild, readdirMaybePromoteChild).call(this, e, c) || _class_private_method_get3(this, _readdirAddNewChild, readdirAddNewChild).call(this, e, c);
}
function readdirAddNewChild(e, c) {
  var _child, type = entToType(e), child = this.newChild(e.name, type, {
    parent: this
  }), ifmt = _class_private_field_get3(child, _type) & IFMT;
  return ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN && _class_private_field_set3(_child = child, _type, _class_private_field_get3(_child, _type) | ENOTDIR), c.unshift(child), c.provisional++, child;
}
function readdirMaybePromoteChild(e, c) {
  for (var p = c.provisional; p < c.length; p++) {
    var pchild = c[p], name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
    if (name === _class_private_field_get3(pchild, _matchName))
      return _class_private_method_get3(this, _readdirPromoteChild, readdirPromoteChild).call(this, e, pchild, p, c);
  }
}
function readdirPromoteChild(e, p, index, c) {
  var v = p.name;
  return _class_private_field_set3(p, _type, _class_private_field_get3(p, _type) & IFMT_UNKNOWN | entToType(e)), v !== e.name && (p.name = e.name), index !== c.provisional && (index === c.length - 1 ? c.pop() : c.splice(index, 1), c.unshift(p)), c.provisional++, p;
}
function applyStat(st) {
  var atime = st.atime, atimeMs = st.atimeMs, birthtime = st.birthtime, birthtimeMs = st.birthtimeMs, blksize = st.blksize, blocks = st.blocks, ctime = st.ctime, ctimeMs = st.ctimeMs, dev = st.dev, gid = st.gid, ino = st.ino, mode = st.mode, mtime = st.mtime, mtimeMs = st.mtimeMs, nlink = st.nlink, rdev = st.rdev, size = st.size, uid = st.uid;
  _class_private_field_set3(this, _atime, atime), _class_private_field_set3(this, _atimeMs, atimeMs), _class_private_field_set3(this, _birthtime, birthtime), _class_private_field_set3(this, _birthtimeMs, birthtimeMs), _class_private_field_set3(this, _blksize, blksize), _class_private_field_set3(this, _blocks, blocks), _class_private_field_set3(this, _ctime, ctime), _class_private_field_set3(this, _ctimeMs, ctimeMs), _class_private_field_set3(this, _dev, dev), _class_private_field_set3(this, _gid, gid), _class_private_field_set3(this, _ino, ino), _class_private_field_set3(this, _mode, mode), _class_private_field_set3(this, _mtime, mtime), _class_private_field_set3(this, _mtimeMs, mtimeMs), _class_private_field_set3(this, _nlink, nlink), _class_private_field_set3(this, _rdev, rdev), _class_private_field_set3(this, _size2, size), _class_private_field_set3(this, _uid, uid);
  var ifmt = entToType(st);
  _class_private_field_set3(this, _type, _class_private_field_get3(this, _type) & IFMT_UNKNOWN | ifmt | LSTAT_CALLED), ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK && _class_private_field_set3(this, _type, _class_private_field_get3(this, _type) | ENOTDIR);
}
function callOnReaddirCB(children) {
  _class_private_field_set3(this, _readdirCBInFlight, !1);
  var cbs = _class_private_field_get3(this, _onReaddirCB).slice();
  _class_private_field_get3(this, _onReaddirCB).length = 0, cbs.forEach(function(cb) {
    return cb(null, children);
  });
}
var PathWin32 = /* @__PURE__ */ function(PathBase2) {
  "use strict";
  _inherits7(PathWin322, PathBase2);
  var _super = _create_super7(PathWin322);
  function PathWin322(name) {
    var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UNKNOWN, root = arguments.length > 2 ? arguments[2] : void 0, roots = arguments.length > 3 ? arguments[3] : void 0, nocase = arguments.length > 4 ? arguments[4] : void 0, children = arguments.length > 5 ? arguments[5] : void 0, opts = arguments.length > 6 ? arguments[6] : void 0;
    _class_call_check8(this, PathWin322);
    var _this;
    return _this = _super.call(this, name, type, root, roots, nocase, children, opts), _define_property11(_assert_this_initialized7(_this), "sep", "\\"), _define_property11(_assert_this_initialized7(_this), "splitSep", eitherSep), _this;
  }
  return _create_class6(PathWin322, [
    {
      /**
      * @internal
      */
      key: "newChild",
      value: function(name) {
        var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UNKNOWN, opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return new PathWin322(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    },
    {
      /**
      * @internal
      */
      key: "getRootString",
      value: function(path6) {
        return import_path3.win32.parse(path6).root;
      }
    },
    {
      /**
      * @internal
      */
      key: "getRoot",
      value: function(rootPath) {
        if (rootPath = uncToDrive(rootPath.toUpperCase()), rootPath === this.root.name)
          return this.root;
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = Object.entries(this.roots)[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array10(_step.value, 2), compare = _step_value[0], root = _step_value[1];
            if (this.sameRoot(rootPath, compare))
              return this.roots[rootPath] = root;
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
    },
    {
      /**
      * @internal
      */
      key: "sameRoot",
      value: function(rootPath) {
        var compare = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.root.name;
        return rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\"), rootPath === compare;
      }
    }
  ]), PathWin322;
}(PathBase), PathPosix = /* @__PURE__ */ function(PathBase2) {
  "use strict";
  _inherits7(PathPosix2, PathBase2);
  var _super = _create_super7(PathPosix2);
  function PathPosix2(name) {
    var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UNKNOWN, root = arguments.length > 2 ? arguments[2] : void 0, roots = arguments.length > 3 ? arguments[3] : void 0, nocase = arguments.length > 4 ? arguments[4] : void 0, children = arguments.length > 5 ? arguments[5] : void 0, opts = arguments.length > 6 ? arguments[6] : void 0;
    _class_call_check8(this, PathPosix2);
    var _this;
    return _this = _super.call(this, name, type, root, roots, nocase, children, opts), _define_property11(_assert_this_initialized7(_this), "splitSep", "/"), _define_property11(_assert_this_initialized7(_this), "sep", "/"), _this;
  }
  return _create_class6(PathPosix2, [
    {
      /**
      * @internal
      */
      key: "getRootString",
      value: function(path6) {
        return path6.startsWith("/") ? "/" : "";
      }
    },
    {
      /**
      * @internal
      */
      key: "getRoot",
      value: function(_rootPath) {
        return this.root;
      }
    },
    {
      /**
      * @internal
      */
      key: "newChild",
      value: function(name) {
        var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UNKNOWN, opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return new PathPosix2(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    }
  ]), PathPosix2;
}(PathBase), _resolveCache = /* @__PURE__ */ new WeakMap(), _resolvePosixCache = /* @__PURE__ */ new WeakMap(), _children1 = /* @__PURE__ */ new WeakMap(), _fs1 = /* @__PURE__ */ new WeakMap(), _Symbol_asyncIterator2 = Symbol.asyncIterator, _Symbol_iterator3 = Symbol.iterator, PathScurryBase = /* @__PURE__ */ function() {
  "use strict";
  function PathScurryBase2() {
    var cwd2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : process.cwd(), pathImpl = arguments.length > 1 ? arguments[1] : void 0, sep2 = arguments.length > 2 ? arguments[2] : void 0, _ref = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, nocase = _ref.nocase, _ref_childrenCacheSize = _ref.childrenCacheSize, childrenCacheSize = _ref_childrenCacheSize === void 0 ? 16 * 1024 : _ref_childrenCacheSize, _ref_fs = _ref.fs, fs7 = _ref_fs === void 0 ? defaultFS : _ref_fs;
    _class_call_check8(this, PathScurryBase2), _define_property11(this, "root", void 0), _define_property11(this, "rootPath", void 0), _define_property11(this, "roots", void 0), _define_property11(this, "cwd", void 0), _class_private_field_init3(this, _resolveCache, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _resolvePosixCache, {
      writable: !0,
      value: void 0
    }), _class_private_field_init3(this, _children1, {
      writable: !0,
      value: void 0
    }), _define_property11(this, "nocase", void 0), _class_private_field_init3(this, _fs1, {
      writable: !0,
      value: void 0
    }), _class_private_field_set3(this, _fs1, fsFromOption(fs7)), (_instanceof7(cwd2, URL) || cwd2.startsWith("file://")) && (cwd2 = (0, import_url.fileURLToPath)(cwd2));
    var cwdPath = pathImpl.resolve(cwd2);
    this.roots = /* @__PURE__ */ Object.create(null), this.rootPath = this.parseRootPath(cwdPath), _class_private_field_set3(this, _resolveCache, new ResolveCache()), _class_private_field_set3(this, _resolvePosixCache, new ResolveCache()), _class_private_field_set3(this, _children1, new ChildrenCache(childrenCacheSize));
    var split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0] && split.pop(), nocase === void 0)
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    this.nocase = nocase, this.root = this.newRoot(_class_private_field_get3(this, _fs1)), this.roots[this.rootPath] = this.root;
    var prev = this.root, len = split.length - 1, joinSep = pathImpl.sep, abs = this.rootPath, sawFirst = !1, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
    try {
      for (var _iterator = split[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
        var part = _step.value, l = len--;
        prev = prev.child(part, {
          relative: new Array(l).fill("..").join(joinSep),
          relativePosix: new Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        }), sawFirst = !0;
      }
    } catch (err) {
      _didIteratorError2 = !0, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError2)
          throw _iteratorError2;
      }
    }
    this.cwd = prev;
  }
  return _create_class6(PathScurryBase2, [
    {
      /**
      * Get the depth of a provided path, string, or the cwd
      */
      key: "depth",
      value: function() {
        var path6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd;
        return typeof path6 == "string" && (path6 = this.cwd.resolve(path6)), path6.depth();
      }
    },
    {
      /**
      * Return the cache of child entries.  Exposed so subclasses can create
      * child Path objects in a platform-specific way.
      *
      * @internal
      */
      key: "childrenCache",
      value: function() {
        return _class_private_field_get3(this, _children1);
      }
    },
    {
      /**
      * Resolve one or more path strings to a resolved string
      *
      * Same interface as require('path').resolve.
      *
      * Much faster than path.resolve() when called multiple times for the same
      * path, because the resolved Path objects are cached.  Much slower
      * otherwise.
      */
      key: "resolve",
      value: function() {
        for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++)
          paths[_key] = arguments[_key];
        for (var r = "", i = paths.length - 1; i >= 0; i--) {
          var p = paths[i];
          if (!(!p || p === ".") && (r = r ? "".concat(p, "/").concat(r) : p, this.isAbsolute(p)))
            break;
        }
        var cached = _class_private_field_get3(this, _resolveCache).get(r);
        if (cached !== void 0)
          return cached;
        var result = this.cwd.resolve(r).fullpath();
        return _class_private_field_get3(this, _resolveCache).set(r, result), result;
      }
    },
    {
      /**
      * Resolve one or more path strings to a resolved string, returning
      * the posix path.  Identical to .resolve() on posix systems, but on
      * windows will return a forward-slash separated UNC path.
      *
      * Same interface as require('path').resolve.
      *
      * Much faster than path.resolve() when called multiple times for the same
      * path, because the resolved Path objects are cached.  Much slower
      * otherwise.
      */
      key: "resolvePosix",
      value: function() {
        for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++)
          paths[_key] = arguments[_key];
        for (var r = "", i = paths.length - 1; i >= 0; i--) {
          var p = paths[i];
          if (!(!p || p === ".") && (r = r ? "".concat(p, "/").concat(r) : p, this.isAbsolute(p)))
            break;
        }
        var cached = _class_private_field_get3(this, _resolvePosixCache).get(r);
        if (cached !== void 0)
          return cached;
        var result = this.cwd.resolve(r).fullpathPosix();
        return _class_private_field_get3(this, _resolvePosixCache).set(r, result), result;
      }
    },
    {
      /**
      * find the relative path from the cwd to the supplied path string or entry
      */
      key: "relative",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd;
        return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.relative();
      }
    },
    {
      /**
      * find the relative path from the cwd to the supplied path string or
      * entry, using / as the path delimiter, even on Windows.
      */
      key: "relativePosix",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd;
        return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.relativePosix();
      }
    },
    {
      /**
      * Return the basename for the provided string or Path object
      */
      key: "basename",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd;
        return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.name;
      }
    },
    {
      /**
      * Return the dirname for the provided string or Path object
      */
      key: "dirname",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd;
        return typeof entry == "string" && (entry = this.cwd.resolve(entry)), (entry.parent || entry).fullpath();
      }
    },
    {
      key: "readdir",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          withFileTypes: !0
        }, _this = this;
        return _async_to_generator7(function() {
          var withFileTypes, p;
          return _ts_generator7(this, function(_state) {
            switch (_state.label) {
              case 0:
                return typeof entry == "string" ? entry = _this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (opts = entry, entry = _this.cwd), withFileTypes = opts.withFileTypes, entry.canReaddir() ? [
                  3,
                  1
                ] : [
                  2,
                  []
                ];
              case 1:
                return [
                  4,
                  entry.readdir()
                ];
              case 2:
                return p = _state.sent(), [
                  2,
                  withFileTypes ? p : p.map(function(e) {
                    return e.name;
                  })
                ];
              case 3:
                return [
                  2
                ];
            }
          });
        })();
      }
    },
    {
      key: "readdirSync",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          withFileTypes: !0
        };
        typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (opts = entry, entry = this.cwd);
        var _opts_withFileTypes = opts.withFileTypes, withFileTypes = _opts_withFileTypes === void 0 ? !0 : _opts_withFileTypes;
        return entry.canReaddir() ? withFileTypes ? entry.readdirSync() : entry.readdirSync().map(function(e) {
          return e.name;
        }) : [];
      }
    },
    {
      key: "lstat",
      value: (
        /**
        * Call lstat() on the string or Path object, and update all known
        * information that can be determined.
        *
        * Note that unlike `fs.lstat()`, the returned value does not contain some
        * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
        * information is required, you will need to call `fs.lstat` yourself.
        *
        * If the Path refers to a nonexistent file, or if the lstat call fails for
        * any reason, `undefined` is returned.  Otherwise the updated Path object is
        * returned.
        *
        * Results are cached, and thus may be out of date if the filesystem is
        * mutated.
        */
        function() {
          var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, _this = this;
          return _async_to_generator7(function() {
            return _ts_generator7(this, function(_state) {
              return typeof entry == "string" && (entry = _this.cwd.resolve(entry)), [
                2,
                entry.lstat()
              ];
            });
          })();
        }
      )
    },
    {
      /**
      * synchronous {@link PathScurryBase.lstat}
      */
      key: "lstatSync",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd;
        return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.lstatSync();
      }
    },
    {
      key: "readlink",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, withFileTypes = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          withFileTypes: !1
        }).withFileTypes, _this = this;
        return _async_to_generator7(function() {
          var e;
          return _ts_generator7(this, function(_state) {
            switch (_state.label) {
              case 0:
                return typeof entry == "string" ? entry = _this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (withFileTypes = entry.withFileTypes, entry = _this.cwd), [
                  4,
                  entry.readlink()
                ];
              case 1:
                return e = _state.sent(), [
                  2,
                  withFileTypes ? e : e == null ? void 0 : e.fullpath()
                ];
            }
          });
        })();
      }
    },
    {
      key: "readlinkSync",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, withFileTypes = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          withFileTypes: !1
        }).withFileTypes;
        typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (withFileTypes = entry.withFileTypes, entry = this.cwd);
        var e = entry.readlinkSync();
        return withFileTypes ? e : e == null ? void 0 : e.fullpath();
      }
    },
    {
      key: "realpath",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, withFileTypes = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          withFileTypes: !1
        }).withFileTypes, _this = this;
        return _async_to_generator7(function() {
          var e;
          return _ts_generator7(this, function(_state) {
            switch (_state.label) {
              case 0:
                return typeof entry == "string" ? entry = _this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (withFileTypes = entry.withFileTypes, entry = _this.cwd), [
                  4,
                  entry.realpath()
                ];
              case 1:
                return e = _state.sent(), [
                  2,
                  withFileTypes ? e : e == null ? void 0 : e.fullpath()
                ];
            }
          });
        })();
      }
    },
    {
      key: "realpathSync",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, withFileTypes = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          withFileTypes: !1
        }).withFileTypes;
        typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (withFileTypes = entry.withFileTypes, entry = this.cwd);
        var e = entry.realpathSync();
        return withFileTypes ? e : e == null ? void 0 : e.fullpath();
      }
    },
    {
      key: "walk",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _this = this;
        return _async_to_generator7(function() {
          var _opts_withFileTypes, withFileTypes, _opts_follow, follow, filter2, walkFilter, results, dirs, walk2, start;
          return _ts_generator7(this, function(_state) {
            return typeof entry == "string" ? entry = _this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (opts = entry, entry = _this.cwd), _opts_withFileTypes = opts.withFileTypes, withFileTypes = _opts_withFileTypes === void 0 ? !0 : _opts_withFileTypes, _opts_follow = opts.follow, follow = _opts_follow === void 0 ? !1 : _opts_follow, filter2 = opts.filter, walkFilter = opts.walkFilter, results = [], (!filter2 || filter2(entry)) && results.push(withFileTypes ? entry : entry.fullpath()), dirs = /* @__PURE__ */ new Set(), walk2 = function(dir, cb) {
              dirs.add(dir), dir.readdirCB(function(er, entries) {
                if (er)
                  return cb(er);
                var len = entries.length;
                if (!len)
                  return cb();
                var next = function() {
                  --len === 0 && cb();
                }, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                try {
                  for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                    var e = _step.value;
                    (!filter2 || filter2(e)) && results.push(withFileTypes ? e : e.fullpath()), follow && e.isSymbolicLink() ? e.realpath().then(function(r) {
                      return r != null && r.isUnknown() ? r.lstat() : r;
                    }).then(function(r) {
                      return r != null && r.shouldWalk(dirs, walkFilter) ? walk2(r, next) : next();
                    }) : e.shouldWalk(dirs, walkFilter) ? walk2(e, next) : next();
                  }
                } catch (err) {
                  _didIteratorError2 = !0, _iteratorError2 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                }
              }, !0);
            }, start = entry, [
              2,
              new Promise(function(res, rej) {
                walk2(start, function(er) {
                  if (er)
                    return rej(er);
                  res(results);
                });
              })
            ];
          });
        })();
      }
    },
    {
      key: "walkSync",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (opts = entry, entry = this.cwd);
        var _opts_withFileTypes = opts.withFileTypes, withFileTypes = _opts_withFileTypes === void 0 ? !0 : _opts_withFileTypes, _opts_follow = opts.follow, follow = _opts_follow === void 0 ? !1 : _opts_follow, filter2 = opts.filter, walkFilter = opts.walkFilter, results = [];
        (!filter2 || filter2(entry)) && results.push(withFileTypes ? entry : entry.fullpath());
        var dirs = /* @__PURE__ */ new Set([
          entry
        ]), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = dirs[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var dir = _step.value, entries = dir.readdirSync(), _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
            try {
              for (var _iterator1 = entries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                var e = _step1.value;
                (!filter2 || filter2(e)) && results.push(withFileTypes ? e : e.fullpath());
                var r = e;
                if (e.isSymbolicLink()) {
                  if (!(follow && (r = e.realpathSync())))
                    continue;
                  r.isUnknown() && r.lstatSync();
                }
                r.shouldWalk(dirs, walkFilter) && dirs.add(r);
              }
            } catch (err) {
              _didIteratorError12 = !0, _iteratorError12 = err;
            } finally {
              try {
                !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return results;
      }
    },
    {
      /**
      * Support for `for await`
      *
      * Alias for {@link PathScurryBase.iterate}
      *
      * Note: As of Node 19, this is very slow, compared to other methods of
      * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
      * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
      */
      key: _Symbol_asyncIterator2,
      value: function() {
        return this.iterate();
      }
    },
    {
      key: "iterate",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (options = entry, entry = this.cwd), this.stream(entry, options)[Symbol.asyncIterator]();
      }
    },
    {
      /**
      * Iterating over a PathScurry performs a synchronous walk.
      *
      * Alias for {@link PathScurryBase.iterateSync}
      */
      key: _Symbol_iterator3,
      value: function() {
        return this.iterateSync();
      }
    },
    {
      key: "iterateSync",
      value: function() {
        var entry, opts, _opts_withFileTypes, withFileTypes, _opts_follow, follow, filter2, walkFilter, dirs, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator, _step, dir, entries, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator1, _step1, e, r, err, err, _arguments = arguments;
        return _ts_generator7(this, function(_state) {
          switch (_state.label) {
            case 0:
              return entry = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : this.cwd, opts = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (opts = entry, entry = this.cwd), _opts_withFileTypes = opts.withFileTypes, withFileTypes = _opts_withFileTypes === void 0 ? !0 : _opts_withFileTypes, _opts_follow = opts.follow, follow = _opts_follow === void 0 ? !1 : _opts_follow, filter2 = opts.filter, walkFilter = opts.walkFilter, !filter2 || filter2(entry) ? [
                4,
                withFileTypes ? entry : entry.fullpath()
              ] : [
                3,
                2
              ];
            case 1:
              _state.sent(), _state.label = 2;
            case 2:
              dirs = /* @__PURE__ */ new Set([
                entry
              ]), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0, _state.label = 3;
            case 3:
              _state.trys.push([
                3,
                15,
                16,
                17
              ]), _iterator = dirs[Symbol.iterator](), _state.label = 4;
            case 4:
              if (_iteratorNormalCompletion2 = (_step = _iterator.next()).done)
                return [
                  3,
                  14
                ];
              dir = _step.value, entries = dir.readdirSync(), _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0, _state.label = 5;
            case 5:
              _state.trys.push([
                5,
                11,
                12,
                13
              ]), _iterator1 = entries[Symbol.iterator](), _state.label = 6;
            case 6:
              return (_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done) ? [
                3,
                10
              ] : (e = _step1.value, !filter2 || filter2(e) ? [
                4,
                withFileTypes ? e : e.fullpath()
              ] : [
                3,
                8
              ]);
            case 7:
              _state.sent(), _state.label = 8;
            case 8:
              if (r = e, e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  return [
                    3,
                    9
                  ];
                r.isUnknown() && r.lstatSync();
              }
              r.shouldWalk(dirs, walkFilter) && dirs.add(r), _state.label = 9;
            case 9:
              return _iteratorNormalCompletion12 = !0, [
                3,
                6
              ];
            case 10:
              return [
                3,
                13
              ];
            case 11:
              return err = _state.sent(), _didIteratorError12 = !0, _iteratorError12 = err, [
                3,
                13
              ];
            case 12:
              try {
                !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
              return [
                7
              ];
            case 13:
              return _iteratorNormalCompletion2 = !0, [
                3,
                4
              ];
            case 14:
              return [
                3,
                17
              ];
            case 15:
              return err = _state.sent(), _didIteratorError2 = !0, _iteratorError2 = err, [
                3,
                17
              ];
            case 16:
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
              return [
                7
              ];
            case 17:
              return [
                2
              ];
          }
        });
      }
    },
    {
      key: "stream",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (opts = entry, entry = this.cwd);
        var _opts_withFileTypes = opts.withFileTypes, withFileTypes = _opts_withFileTypes === void 0 ? !0 : _opts_withFileTypes, _opts_follow = opts.follow, follow = _opts_follow === void 0 ? !1 : _opts_follow, filter2 = opts.filter, walkFilter = opts.walkFilter, results = new Minipass({
          objectMode: !0
        });
        (!filter2 || filter2(entry)) && results.write(withFileTypes ? entry : entry.fullpath());
        var dirs = /* @__PURE__ */ new Set(), queue = [
          entry
        ], processing = 0, _$process = function() {
          for (var _loop = function() {
            var dir = queue.shift();
            if (!dir)
              return processing === 0 && results.end(), {
                v: void 0
              };
            processing++, dirs.add(dir);
            var onReaddir = function(er, entries) {
              var didRealpaths = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                var promises2 = [], _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                try {
                  for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                    var e = _step.value;
                    e.isSymbolicLink() && promises2.push(e.realpath().then(function(r2) {
                      return r2 != null && r2.isUnknown() ? r2.lstat() : r2;
                    }));
                  }
                } catch (err) {
                  _didIteratorError2 = !0, _iteratorError2 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                }
                if (promises2.length) {
                  Promise.all(promises2).then(function() {
                    return onReaddir(null, entries, !0);
                  });
                  return;
                }
              }
              var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
              try {
                for (var _iterator1 = entries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                  var e1 = _step1.value;
                  e1 && (!filter2 || filter2(e1)) && (results.write(withFileTypes ? e1 : e1.fullpath()) || (paused = !0));
                }
              } catch (err) {
                _didIteratorError12 = !0, _iteratorError12 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
                } finally {
                  if (_didIteratorError12)
                    throw _iteratorError12;
                }
              }
              processing--;
              var _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
              try {
                for (var _iterator2 = entries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion22 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion22 = !0) {
                  var e2 = _step2.value, r = e2.realpathCached() || e2;
                  r.shouldWalk(dirs, walkFilter) && queue.push(r);
                }
              } catch (err) {
                _didIteratorError22 = !0, _iteratorError22 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion22 && _iterator2.return != null && _iterator2.return();
                } finally {
                  if (_didIteratorError22)
                    throw _iteratorError22;
                }
              }
              paused && !results.flowing ? results.once("drain", _$process) : sync2 || _$process();
            }, sync2 = !0;
            dir.readdirCB(onReaddir, !0), sync2 = !1;
          }, paused = !1; !paused; ) {
            var _ret = _loop();
            if (_type_of8(_ret) === "object")
              return _ret.v;
          }
        };
        return _$process(), results;
      }
    },
    {
      key: "streamSync",
      value: function() {
        var entry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        typeof entry == "string" ? entry = this.cwd.resolve(entry) : _instanceof7(entry, PathBase) || (opts = entry, entry = this.cwd);
        var _opts_withFileTypes = opts.withFileTypes, withFileTypes = _opts_withFileTypes === void 0 ? !0 : _opts_withFileTypes, _opts_follow = opts.follow, follow = _opts_follow === void 0 ? !1 : _opts_follow, filter2 = opts.filter, walkFilter = opts.walkFilter, results = new Minipass({
          objectMode: !0
        }), dirs = /* @__PURE__ */ new Set();
        (!filter2 || filter2(entry)) && results.write(withFileTypes ? entry : entry.fullpath());
        var queue = [
          entry
        ], processing = 0, _$process = function() {
          for (var paused = !1; !paused; ) {
            var dir = queue.shift();
            if (!dir) {
              processing === 0 && results.end();
              return;
            }
            processing++, dirs.add(dir);
            var entries = dir.readdirSync(), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var e = _step.value;
                (!filter2 || filter2(e)) && (results.write(withFileTypes ? e : e.fullpath()) || (paused = !0));
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            processing--;
            var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
            try {
              for (var _iterator1 = entries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                var e1 = _step1.value, r = e1;
                if (e1.isSymbolicLink()) {
                  if (!(follow && (r = e1.realpathSync())))
                    continue;
                  r.isUnknown() && r.lstatSync();
                }
                r.shouldWalk(dirs, walkFilter) && queue.push(r);
              }
            } catch (err) {
              _didIteratorError12 = !0, _iteratorError12 = err;
            } finally {
              try {
                !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
            }
          }
          paused && !results.flowing && results.once("drain", _$process);
        };
        return _$process(), results;
      }
    },
    {
      key: "chdir",
      value: function() {
        var path6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.cwd, oldCwd = this.cwd;
        this.cwd = typeof path6 == "string" ? this.cwd.resolve(path6) : path6, this.cwd[setAsCwd](oldCwd);
      }
    }
  ]), PathScurryBase2;
}(), PathScurryWin32 = /* @__PURE__ */ function(PathScurryBase2) {
  "use strict";
  _inherits7(PathScurryWin322, PathScurryBase2);
  var _super = _create_super7(PathScurryWin322);
  function PathScurryWin322() {
    var cwd2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : process.cwd(), opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _class_call_check8(this, PathScurryWin322);
    var _this, _opts_nocase = opts.nocase, nocase = _opts_nocase === void 0 ? !0 : _opts_nocase;
    _this = _super.call(this, cwd2, import_path3.win32, "\\", _object_spread_props5(_object_spread8({}, opts), {
      nocase
    })), _define_property11(_assert_this_initialized7(_this), "sep", "\\"), _this.nocase = nocase;
    for (var p = _this.cwd; p; p = p.parent)
      p.nocase = _this.nocase;
    return _this;
  }
  return _create_class6(PathScurryWin322, [
    {
      /**
      * @internal
      */
      key: "parseRootPath",
      value: function(dir) {
        return import_path3.win32.parse(dir).root.toUpperCase();
      }
    },
    {
      /**
      * @internal
      */
      key: "newRoot",
      value: function(fs7) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), {
          fs: fs7
        });
      }
    },
    {
      /**
      * Return true if the provided path string is an absolute path
      */
      key: "isAbsolute",
      value: function(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    }
  ]), PathScurryWin322;
}(PathScurryBase), PathScurryPosix = /* @__PURE__ */ function(PathScurryBase2) {
  "use strict";
  _inherits7(PathScurryPosix2, PathScurryBase2);
  var _super = _create_super7(PathScurryPosix2);
  function PathScurryPosix2() {
    var cwd2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : process.cwd(), opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _class_call_check8(this, PathScurryPosix2);
    var _this, _opts_nocase = opts.nocase, nocase = _opts_nocase === void 0 ? !1 : _opts_nocase;
    return _this = _super.call(this, cwd2, import_path3.posix, "/", _object_spread_props5(_object_spread8({}, opts), {
      nocase
    })), _define_property11(_assert_this_initialized7(_this), "sep", "/"), _this.nocase = nocase, _this;
  }
  return _create_class6(PathScurryPosix2, [
    {
      /**
      * @internal
      */
      key: "parseRootPath",
      value: function(_dir) {
        return "/";
      }
    },
    {
      /**
      * @internal
      */
      key: "newRoot",
      value: function(fs7) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), {
          fs: fs7
        });
      }
    },
    {
      /**
      * Return true if the provided path string is an absolute path
      */
      key: "isAbsolute",
      value: function(p) {
        return p.startsWith("/");
      }
    }
  ]), PathScurryPosix2;
}(PathScurryBase), PathScurryDarwin = /* @__PURE__ */ function(PathScurryPosix2) {
  "use strict";
  _inherits7(PathScurryDarwin2, PathScurryPosix2);
  var _super = _create_super7(PathScurryDarwin2);
  function PathScurryDarwin2() {
    var cwd2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : process.cwd(), opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _class_call_check8(this, PathScurryDarwin2);
    var _opts_nocase = opts.nocase, nocase = _opts_nocase === void 0 ? !0 : _opts_nocase;
    return _super.call(this, cwd2, _object_spread_props5(_object_spread8({}, opts), {
      nocase
    }));
  }
  return PathScurryDarwin2;
}(PathScurryPosix), Path = process.platform === "win32" ? PathWin32 : PathPosix, PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/glob.js
var import_url2 = require("url");

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/pattern.js
function _array_like_to_array13(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes11(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes9(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array13(arr);
}
function _check_private_redeclaration4(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _class_apply_descriptor_get4(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _class_apply_descriptor_set4(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _class_call_check9(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _class_extract_field_descriptor4(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}
function _class_private_field_get4(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor4(receiver, privateMap, "get");
  return _class_apply_descriptor_get4(receiver, descriptor);
}
function _class_private_field_init4(obj, privateMap, value) {
  _check_private_redeclaration4(obj, privateMap), privateMap.set(obj, value);
}
function _class_private_field_set4(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor4(receiver, privateMap, "set");
  return _class_apply_descriptor_set4(receiver, descriptor, value), value;
}
function _defineProperties7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class7(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties7(Constructor.prototype, protoProps), staticProps && _defineProperties7(Constructor, staticProps), Constructor;
}
function _define_property12(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _instanceof8(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array9(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _non_iterable_rest11() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_array(arr) {
  return _array_with_holes11(arr) || _iterable_to_array9(arr) || _unsupported_iterable_to_array13(arr) || _non_iterable_rest11();
}
function _to_consumable_array9(arr) {
  return _array_without_holes9(arr) || _iterable_to_array9(arr) || _unsupported_iterable_to_array13(arr) || _non_iterable_spread9();
}
function _unsupported_iterable_to_array13(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array13(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array13(o, minLen);
  }
}
var isPatternList = function(pl) {
  return pl.length >= 1;
}, isGlobList = function(gl) {
  return gl.length >= 1;
}, _patternList = /* @__PURE__ */ new WeakMap(), _globList = /* @__PURE__ */ new WeakMap(), _index = /* @__PURE__ */ new WeakMap(), _platform = /* @__PURE__ */ new WeakMap(), _rest = /* @__PURE__ */ new WeakMap(), _globString = /* @__PURE__ */ new WeakMap(), _isDrive = /* @__PURE__ */ new WeakMap(), _isUNC = /* @__PURE__ */ new WeakMap(), _isAbsolute = /* @__PURE__ */ new WeakMap(), _followGlobstar = /* @__PURE__ */ new WeakMap(), Pattern = /* @__PURE__ */ function() {
  "use strict";
  function Pattern2(patternList, globList, index, platform) {
    if (_class_call_check9(this, Pattern2), _class_private_field_init4(this, _patternList, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _globList, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _index, {
      writable: !0,
      value: void 0
    }), _define_property12(this, "length", void 0), _class_private_field_init4(this, _platform, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _rest, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _globString, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _isDrive, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _isUNC, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _isAbsolute, {
      writable: !0,
      value: void 0
    }), _class_private_field_init4(this, _followGlobstar, {
      writable: !0,
      value: !0
    }), !isPatternList(patternList))
      throw new TypeError("empty pattern list");
    if (!isGlobList(globList))
      throw new TypeError("empty glob list");
    if (globList.length !== patternList.length)
      throw new TypeError("mismatched pattern list and glob list lengths");
    if (this.length = patternList.length, index < 0 || index >= this.length)
      throw new TypeError("index out of range");
    if (_class_private_field_set4(this, _patternList, patternList), _class_private_field_set4(this, _globList, globList), _class_private_field_set4(this, _index, index), _class_private_field_set4(this, _platform, platform), _class_private_field_get4(this, _index) === 0) {
      if (this.isUNC()) {
        var _$_class_private_field_get = _to_array(_class_private_field_get4(this, _patternList)), p0 = _$_class_private_field_get[0], p1 = _$_class_private_field_get[1], p2 = _$_class_private_field_get[2], p3 = _$_class_private_field_get[3], prest = _$_class_private_field_get.slice(4), _$_class_private_field_get1 = _to_array(_class_private_field_get4(this, _globList)), g0 = _$_class_private_field_get1[0], g1 = _$_class_private_field_get1[1], g2 = _$_class_private_field_get1[2], g3 = _$_class_private_field_get1[3], grest = _$_class_private_field_get1.slice(4);
        prest[0] === "" && (prest.shift(), grest.shift());
        var p = [
          p0,
          p1,
          p2,
          p3,
          ""
        ].join("/"), g = [
          g0,
          g1,
          g2,
          g3,
          ""
        ].join("/");
        _class_private_field_set4(this, _patternList, [
          p
        ].concat(_to_consumable_array9(prest))), _class_private_field_set4(this, _globList, [
          g
        ].concat(_to_consumable_array9(grest))), this.length = _class_private_field_get4(this, _patternList).length;
      } else if (this.isDrive() || this.isAbsolute()) {
        var _$_class_private_field_get2 = _to_array(_class_private_field_get4(this, _patternList)), p11 = _$_class_private_field_get2[0], prest1 = _$_class_private_field_get2.slice(1), _$_class_private_field_get3 = _to_array(_class_private_field_get4(this, _globList)), g11 = _$_class_private_field_get3[0], grest1 = _$_class_private_field_get3.slice(1);
        prest1[0] === "" && (prest1.shift(), grest1.shift());
        var p4 = p11 + "/", g4 = g11 + "/";
        _class_private_field_set4(this, _patternList, [
          p4
        ].concat(_to_consumable_array9(prest1))), _class_private_field_set4(this, _globList, [
          g4
        ].concat(_to_consumable_array9(grest1))), this.length = _class_private_field_get4(this, _patternList).length;
      }
    }
  }
  return _create_class7(Pattern2, [
    {
      /**
      * The first entry in the parsed list of patterns
      */
      key: "pattern",
      value: function() {
        return _class_private_field_get4(this, _patternList)[_class_private_field_get4(this, _index)];
      }
    },
    {
      /**
      * true of if pattern() returns a string
      */
      key: "isString",
      value: function() {
        return typeof _class_private_field_get4(this, _patternList)[_class_private_field_get4(this, _index)] == "string";
      }
    },
    {
      /**
      * true of if pattern() returns GLOBSTAR
      */
      key: "isGlobstar",
      value: function() {
        return _class_private_field_get4(this, _patternList)[_class_private_field_get4(this, _index)] === GLOBSTAR;
      }
    },
    {
      /**
      * true if pattern() returns a regexp
      */
      key: "isRegExp",
      value: function() {
        return _instanceof8(_class_private_field_get4(this, _patternList)[_class_private_field_get4(this, _index)], RegExp);
      }
    },
    {
      /**
      * The /-joined set of glob parts that make up this pattern
      */
      key: "globString",
      value: function() {
        return _class_private_field_set4(this, _globString, _class_private_field_get4(this, _globString) || (_class_private_field_get4(this, _index) === 0 ? this.isAbsolute() ? _class_private_field_get4(this, _globList)[0] + _class_private_field_get4(this, _globList).slice(1).join("/") : _class_private_field_get4(this, _globList).join("/") : _class_private_field_get4(this, _globList).slice(_class_private_field_get4(this, _index)).join("/")));
      }
    },
    {
      /**
      * true if there are more pattern parts after this one
      */
      key: "hasMore",
      value: function() {
        return this.length > _class_private_field_get4(this, _index) + 1;
      }
    },
    {
      /**
      * The rest of the pattern after this part, or null if this is the end
      */
      key: "rest",
      value: function() {
        return _class_private_field_get4(this, _rest) !== void 0 ? _class_private_field_get4(this, _rest) : this.hasMore() ? (_class_private_field_set4(this, _rest, new Pattern2(_class_private_field_get4(this, _patternList), _class_private_field_get4(this, _globList), _class_private_field_get4(this, _index) + 1, _class_private_field_get4(this, _platform))), _class_private_field_set4(_class_private_field_get4(this, _rest), _isAbsolute, _class_private_field_get4(this, _isAbsolute)), _class_private_field_set4(_class_private_field_get4(this, _rest), _isUNC, _class_private_field_get4(this, _isUNC)), _class_private_field_set4(_class_private_field_get4(this, _rest), _isDrive, _class_private_field_get4(this, _isDrive)), _class_private_field_get4(this, _rest)) : _class_private_field_set4(this, _rest, null);
      }
    },
    {
      /**
      * true if the pattern represents a //unc/path/ on windows
      */
      key: "isUNC",
      value: function() {
        var pl = _class_private_field_get4(this, _patternList);
        return _class_private_field_get4(this, _isUNC) !== void 0 ? _class_private_field_get4(this, _isUNC) : _class_private_field_set4(this, _isUNC, _class_private_field_get4(this, _platform) === "win32" && _class_private_field_get4(this, _index) === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] == "string" && !!pl[2] && typeof pl[3] == "string" && !!pl[3]);
      }
    },
    {
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
      * True if the pattern starts with a drive letter on Windows
      */
      key: "isDrive",
      value: function() {
        var pl = _class_private_field_get4(this, _patternList);
        return _class_private_field_get4(this, _isDrive) !== void 0 ? _class_private_field_get4(this, _isDrive) : _class_private_field_set4(this, _isDrive, _class_private_field_get4(this, _platform) === "win32" && _class_private_field_get4(this, _index) === 0 && this.length > 1 && typeof pl[0] == "string" && /^[a-z]:$/i.test(pl[0]));
      }
    },
    {
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
      * True if the pattern is rooted on an absolute path
      */
      key: "isAbsolute",
      value: function() {
        var pl = _class_private_field_get4(this, _patternList);
        return _class_private_field_get4(this, _isAbsolute) !== void 0 ? _class_private_field_get4(this, _isAbsolute) : _class_private_field_set4(this, _isAbsolute, pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC());
      }
    },
    {
      /**
      * consume the root of the pattern, and return it
      */
      key: "root",
      value: function() {
        var p = _class_private_field_get4(this, _patternList)[0];
        return typeof p == "string" && this.isAbsolute() && _class_private_field_get4(this, _index) === 0 ? p : "";
      }
    },
    {
      /**
      * Check to see if the current globstar pattern is allowed to follow
      * a symbolic link.
      */
      key: "checkFollowGlobstar",
      value: function() {
        return !(_class_private_field_get4(this, _index) === 0 || !this.isGlobstar() || !_class_private_field_get4(this, _followGlobstar));
      }
    },
    {
      /**
      * Mark that the current globstar pattern is following a symbolic link
      */
      key: "markFollowGlobstar",
      value: function() {
        return _class_private_field_get4(this, _index) === 0 || !this.isGlobstar() || !_class_private_field_get4(this, _followGlobstar) ? !1 : (_class_private_field_set4(this, _followGlobstar, !1), !0);
      }
    }
  ]), Pattern2;
}();

// ../../node_modules/rimraf/node_modules/minipass/dist/mjs/index.js
var import_events2 = require("events"), import_stream2 = __toESM(require("stream"), 1), import_string_decoder2 = require("string_decoder");
function _array_like_to_array14(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes10(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array14(arr);
}
function _assert_this_initialized8(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function asyncGeneratorStep8(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator8(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep8(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep8(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _class_call_check10(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class8(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties8(Constructor.prototype, protoProps), staticProps && _defineProperties8(Constructor, staticProps), Constructor;
}
function _define_property13(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _get3(target, property, receiver) {
  return typeof Reflect < "u" && Reflect.get ? _get3 = Reflect.get : _get3 = function(target2, property2, receiver2) {
    var base = _super_prop_base3(target2, property2);
    if (base) {
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
    }
  }, _get3(target, property, receiver || target);
}
function _get_prototype_of8(o) {
  return _get_prototype_of8 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of8(o);
}
function _inherits8(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of8(subClass, superClass);
}
function _instanceof9(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array10(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _non_iterable_spread10() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return8(self, call) {
  return call && (_type_of9(call) === "object" || typeof call == "function") ? call : _assert_this_initialized8(self);
}
function _set_prototype_of8(o, p) {
  return _set_prototype_of8 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of8(o, p);
}
function _super_prop_base3(object, property) {
  for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of8(object), object !== null); )
    ;
  return object;
}
function _to_consumable_array10(arr) {
  return _array_without_holes10(arr) || _iterable_to_array10(arr) || _unsupported_iterable_to_array14(arr) || _non_iterable_spread10();
}
function _type_of9(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array14(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array14(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array14(o, minLen);
  }
}
function _is_native_reflect_construct8() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super8(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct8();
  return function() {
    var Super = _get_prototype_of8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return8(this, result);
  };
}
function _ts_generator8(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var proc2 = typeof process == "object" && process ? process : {
  stdout: null,
  stderr: null
}, isStream2 = function(s) {
  return !!s && typeof s == "object" && (_instanceof9(s, Minipass2) || _instanceof9(s, import_stream2.default) || isReadable2(s) || isWritable2(s));
}, isReadable2 = function(s) {
  return !!s && typeof s == "object" && _instanceof9(s, import_events2.EventEmitter) && typeof s.pipe == "function" && // node core Writable streams have a pipe() method, but it throws
  s.pipe !== import_stream2.default.Writable.prototype.pipe;
}, isWritable2 = function(s) {
  return !!s && typeof s == "object" && _instanceof9(s, import_events2.EventEmitter) && typeof s.write == "function" && typeof s.end == "function";
}, EOF2 = Symbol("EOF"), MAYBE_EMIT_END2 = Symbol("maybeEmitEnd"), EMITTED_END2 = Symbol("emittedEnd"), EMITTING_END2 = Symbol("emittingEnd"), EMITTED_ERROR2 = Symbol("emittedError"), CLOSED2 = Symbol("closed"), READ2 = Symbol("read"), FLUSH2 = Symbol("flush"), FLUSHCHUNK2 = Symbol("flushChunk"), ENCODING2 = Symbol("encoding"), DECODER2 = Symbol("decoder"), FLOWING2 = Symbol("flowing"), PAUSED2 = Symbol("paused"), RESUME2 = Symbol("resume"), BUFFER2 = Symbol("buffer"), PIPES2 = Symbol("pipes"), BUFFERLENGTH2 = Symbol("bufferLength"), BUFFERPUSH2 = Symbol("bufferPush"), BUFFERSHIFT2 = Symbol("bufferShift"), OBJECTMODE2 = Symbol("objectMode"), DESTROYED2 = Symbol("destroyed"), ERROR2 = Symbol("error"), EMITDATA2 = Symbol("emitData"), EMITEND3 = Symbol("emitEnd"), EMITEND22 = Symbol("emitEnd2"), ASYNC2 = Symbol("async"), ABORT2 = Symbol("abort"), ABORTED2 = Symbol("aborted"), SIGNAL2 = Symbol("signal"), DATALISTENERS2 = Symbol("dataListeners"), DISCARDED2 = Symbol("discarded"), defer2 = function(fn) {
  return Promise.resolve().then(fn);
}, nodefer2 = function(fn) {
  return fn();
}, isEndish2 = function(ev) {
  return ev === "end" || ev === "finish" || ev === "prefinish";
}, isArrayBufferLike2 = function(b) {
  return _instanceof9(b, ArrayBuffer) || !!b && typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
}, isArrayBufferView2 = function(b) {
  return !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
}, Pipe2 = /* @__PURE__ */ function() {
  "use strict";
  function Pipe3(src, dest, opts) {
    _class_call_check10(this, Pipe3), _define_property13(this, "src", void 0), _define_property13(this, "dest", void 0), _define_property13(this, "opts", void 0), _define_property13(this, "ondrain", void 0), this.src = src, this.dest = dest, this.opts = opts, this.ondrain = function() {
      return src[RESUME2]();
    }, this.dest.on("drain", this.ondrain);
  }
  return _create_class8(Pipe3, [
    {
      key: "unpipe",
      value: function() {
        this.dest.removeListener("drain", this.ondrain);
      }
    },
    {
      // only here for the prototype
      /* c8 ignore start */
      key: "proxyErrors",
      value: function(_er) {
      }
    },
    {
      /* c8 ignore stop */
      key: "end",
      value: function() {
        this.unpipe(), this.opts.end && this.dest.end();
      }
    }
  ]), Pipe3;
}(), PipeProxyErrors2 = /* @__PURE__ */ function(Pipe3) {
  "use strict";
  _inherits8(PipeProxyErrors3, Pipe3);
  var _super = _create_super8(PipeProxyErrors3);
  function PipeProxyErrors3(src, dest, opts) {
    _class_call_check10(this, PipeProxyErrors3);
    var _this;
    return _this = _super.call(this, src, dest, opts), _this.proxyErrors = function(er) {
      return dest.emit("error", er);
    }, src.on("error", _this.proxyErrors), _this;
  }
  return _create_class8(PipeProxyErrors3, [
    {
      key: "unpipe",
      value: function() {
        this.src.removeListener("error", this.proxyErrors), _get3(_get_prototype_of8(PipeProxyErrors3.prototype), "unpipe", this).call(this);
      }
    }
  ]), PipeProxyErrors3;
}(Pipe2), isObjectModeOptions2 = function(o) {
  return !!o.objectMode;
}, isEncodingOptions2 = function(o) {
  return !o.objectMode && !!o.encoding && o.encoding !== "buffer";
}, _FLOWING2 = FLOWING2, _PAUSED2 = PAUSED2, _PIPES2 = PIPES2, _BUFFER2 = BUFFER2, _OBJECTMODE2 = OBJECTMODE2, _ENCODING2 = ENCODING2, _ASYNC2 = ASYNC2, _DECODER2 = DECODER2, _EOF2 = EOF2, _EMITTED_END2 = EMITTED_END2, _EMITTING_END2 = EMITTING_END2, _CLOSED2 = CLOSED2, _EMITTED_ERROR2 = EMITTED_ERROR2, _BUFFERLENGTH2 = BUFFERLENGTH2, _DESTROYED2 = DESTROYED2, _SIGNAL2 = SIGNAL2, _ABORTED2 = ABORTED2, _DATALISTENERS2 = DATALISTENERS2, _DISCARDED2 = DISCARDED2, _ABORT2 = ABORT2, _READ2 = READ2, _RESUME2 = RESUME2, _BUFFERPUSH2 = BUFFERPUSH2, _BUFFERSHIFT2 = BUFFERSHIFT2, _FLUSH2 = FLUSH2, _FLUSHCHUNK2 = FLUSHCHUNK2, _MAYBE_EMIT_END2 = MAYBE_EMIT_END2, _EMITDATA2 = EMITDATA2, _EMITEND3 = EMITEND3, _EMITEND22 = EMITEND22, _Symbol_asyncIterator3 = Symbol.asyncIterator, _Symbol_iterator4 = Symbol.iterator, Minipass2 = /* @__PURE__ */ function(EventEmitter3) {
  "use strict";
  _inherits8(Minipass3, EventEmitter3);
  var _super = _create_super8(Minipass3);
  function Minipass3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    _class_call_check10(this, Minipass3);
    var _this, options = args[0] || {};
    if (_this = _super.call(this), _define_property13(_assert_this_initialized8(_this), _FLOWING2, !1), _define_property13(_assert_this_initialized8(_this), _PAUSED2, !1), _define_property13(_assert_this_initialized8(_this), _PIPES2, []), _define_property13(_assert_this_initialized8(_this), _BUFFER2, []), _define_property13(_assert_this_initialized8(_this), _OBJECTMODE2, void 0), _define_property13(_assert_this_initialized8(_this), _ENCODING2, void 0), _define_property13(_assert_this_initialized8(_this), _ASYNC2, void 0), _define_property13(_assert_this_initialized8(_this), _DECODER2, void 0), _define_property13(_assert_this_initialized8(_this), _EOF2, !1), _define_property13(_assert_this_initialized8(_this), _EMITTED_END2, !1), _define_property13(_assert_this_initialized8(_this), _EMITTING_END2, !1), _define_property13(_assert_this_initialized8(_this), _CLOSED2, !1), _define_property13(_assert_this_initialized8(_this), _EMITTED_ERROR2, null), _define_property13(_assert_this_initialized8(_this), _BUFFERLENGTH2, 0), _define_property13(_assert_this_initialized8(_this), _DESTROYED2, !1), _define_property13(_assert_this_initialized8(_this), _SIGNAL2, void 0), _define_property13(_assert_this_initialized8(_this), _ABORTED2, !1), _define_property13(_assert_this_initialized8(_this), _DATALISTENERS2, 0), _define_property13(_assert_this_initialized8(_this), _DISCARDED2, !1), _define_property13(_assert_this_initialized8(_this), "writable", !0), _define_property13(_assert_this_initialized8(_this), "readable", !0), options.objectMode && typeof options.encoding == "string")
      throw new TypeError("Encoding and objectMode may not be used together");
    isObjectModeOptions2(options) ? (_this[OBJECTMODE2] = !0, _this[ENCODING2] = null) : isEncodingOptions2(options) ? (_this[ENCODING2] = options.encoding, _this[OBJECTMODE2] = !1) : (_this[OBJECTMODE2] = !1, _this[ENCODING2] = null), _this[ASYNC2] = !!options.async, _this[DECODER2] = _this[ENCODING2] ? new import_string_decoder2.StringDecoder(_this[ENCODING2]) : null, options && options.debugExposeBuffer === !0 && Object.defineProperty(_assert_this_initialized8(_this), "buffer", {
      get: function() {
        return _this[BUFFER2];
      }
    }), options && options.debugExposePipes === !0 && Object.defineProperty(_assert_this_initialized8(_this), "pipes", {
      get: function() {
        return _this[PIPES2];
      }
    });
    var signal = options.signal;
    return signal && (_this[SIGNAL2] = signal, signal.aborted ? _this[ABORT2]() : signal.addEventListener("abort", function() {
      return _this[ABORT2]();
    })), _this;
  }
  return _create_class8(Minipass3, [
    {
      key: "bufferLength",
      get: (
        /**
        * The amount of data stored in the buffer waiting to be read.
        *
        * For Buffer strings, this will be the total byte length.
        * For string encoding streams, this will be the string character length,
        * according to JavaScript's `string.length` logic.
        * For objectMode streams, this is a count of the items waiting to be
        * emitted.
        */
        function() {
          return this[BUFFERLENGTH2];
        }
      )
    },
    {
      key: "encoding",
      get: (
        /**
        * The `BufferEncoding` currently in use, or `null`
        */
        function() {
          return this[ENCODING2];
        }
      ),
      set: (
        /**
        * @deprecated - This is a read only property
        */
        function(_enc) {
          throw new Error("Encoding must be set at instantiation time");
        }
      )
    },
    {
      /**
      * @deprecated - Encoding may only be set at instantiation time
      */
      key: "setEncoding",
      value: function(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
    },
    {
      key: "objectMode",
      get: (
        /**
        * True if this is an objectMode stream
        */
        function() {
          return this[OBJECTMODE2];
        }
      ),
      set: (
        /**
        * @deprecated - This is a read-only property
        */
        function(_om) {
          throw new Error("objectMode must be set at instantiation time");
        }
      )
    },
    {
      key: "async",
      get: (
        /**
        * true if this is an async stream
        */
        function() {
          return this[ASYNC2];
        }
      )
    },
    {
      key: "async",
      set: (
        /**
        * Set to true to make this stream async.
        *
        * Once set, it cannot be unset, as this would potentially cause incorrect
        * behavior.  Ie, a sync stream can be made async, but an async stream
        * cannot be safely made sync.
        */
        function(a) {
          this[ASYNC2] = this[ASYNC2] || !!a;
        }
      )
    },
    {
      // drop everything and get out of the flow completely
      key: _ABORT2,
      value: function() {
        var _this_SIGNAL, _this_SIGNAL1;
        this[ABORTED2] = !0, this.emit("abort", (_this_SIGNAL = this[SIGNAL2]) === null || _this_SIGNAL === void 0 ? void 0 : _this_SIGNAL.reason), this.destroy((_this_SIGNAL1 = this[SIGNAL2]) === null || _this_SIGNAL1 === void 0 ? void 0 : _this_SIGNAL1.reason);
      }
    },
    {
      key: "aborted",
      get: (
        /**
        * True if the stream has been aborted.
        */
        function() {
          return this[ABORTED2];
        }
      ),
      set: (
        /**
        * No-op setter. Stream aborted status is set via the AbortSignal provided
        * in the constructor options.
        */
        function(_) {
        }
      )
    },
    {
      key: "write",
      value: function(chunk, encoding, cb) {
        var _this_DECODER;
        if (this[ABORTED2])
          return !1;
        if (this[EOF2])
          throw new Error("write after end");
        if (this[DESTROYED2])
          return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), {
            code: "ERR_STREAM_DESTROYED"
          })), !0;
        typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
        var fn = this[ASYNC2] ? defer2 : nodefer2;
        if (!this[OBJECTMODE2] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView2(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBufferLike2(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk != "string")
            throw new Error("Non-contiguous data written to non-objectMode stream");
        }
        return this[OBJECTMODE2] ? (this[FLOWING2] && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this[FLOWING2] ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING2]) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING2] && !(!((_this_DECODER = this[DECODER2]) === null || _this_DECODER === void 0) && _this_DECODER.lastNeed)) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING2] && (chunk = this[DECODER2].write(chunk)), this[FLOWING2] && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this[FLOWING2] ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING2]) : (this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING2]);
      }
    },
    {
      /**
      * Low-level explicit read method.
      *
      * In objectMode, the argument is ignored, and one item is returned if
      * available.
      *
      * `n` is the number of bytes (or in the case of encoding streams,
      * characters) to consume. If `n` is not provided, then the entire buffer
      * is returned, or `null` is returned if no data is available.
      *
      * If `n` is greater that the amount of data in the internal buffer,
      * then `null` is returned.
      */
      key: "read",
      value: function(n) {
        if (this[DESTROYED2])
          return null;
        if (this[DISCARDED2] = !1, this[BUFFERLENGTH2] === 0 || n === 0 || n && n > this[BUFFERLENGTH2])
          return this[MAYBE_EMIT_END2](), null;
        this[OBJECTMODE2] && (n = null), this[BUFFER2].length > 1 && !this[OBJECTMODE2] && (this[BUFFER2] = [
          this[ENCODING2] ? this[BUFFER2].join("") : Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])
        ]);
        var ret = this[READ2](n || null, this[BUFFER2][0]);
        return this[MAYBE_EMIT_END2](), ret;
      }
    },
    {
      key: _READ2,
      value: function(n, chunk) {
        if (this[OBJECTMODE2])
          this[BUFFERSHIFT2]();
        else {
          var c = chunk;
          n === c.length || n === null ? this[BUFFERSHIFT2]() : typeof c == "string" ? (this[BUFFER2][0] = c.slice(n), chunk = c.slice(0, n), this[BUFFERLENGTH2] -= n) : (this[BUFFER2][0] = c.subarray(n), chunk = c.subarray(0, n), this[BUFFERLENGTH2] -= n);
        }
        return this.emit("data", chunk), !this[BUFFER2].length && !this[EOF2] && this.emit("drain"), chunk;
      }
    },
    {
      key: "end",
      value: function(chunk, encoding, cb) {
        return typeof chunk == "function" && (cb = chunk, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk !== void 0 && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF2] = !0, this.writable = !1, (this[FLOWING2] || !this[PAUSED2]) && this[MAYBE_EMIT_END2](), this;
      }
    },
    {
      // don't let the internal resume be overwritten
      key: _RESUME2,
      value: function() {
        this[DESTROYED2] || (!this[DATALISTENERS2] && !this[PIPES2].length && (this[DISCARDED2] = !0), this[PAUSED2] = !1, this[FLOWING2] = !0, this.emit("resume"), this[BUFFER2].length ? this[FLUSH2]() : this[EOF2] ? this[MAYBE_EMIT_END2]() : this.emit("drain"));
      }
    },
    {
      /**
      * Resume the stream if it is currently in a paused state
      *
      * If called when there are no pipe destinations or `data` event listeners,
      * this will place the stream in a "discarded" state, where all data will
      * be thrown away. The discarded state is removed if a pipe destination or
      * data handler is added, if pause() is called, or if any synchronous or
      * asynchronous iteration is started.
      */
      key: "resume",
      value: function() {
        return this[RESUME2]();
      }
    },
    {
      /**
      * Pause the stream
      */
      key: "pause",
      value: function() {
        this[FLOWING2] = !1, this[PAUSED2] = !0, this[DISCARDED2] = !1;
      }
    },
    {
      key: "destroyed",
      get: (
        /**
        * true if the stream has been forcibly destroyed
        */
        function() {
          return this[DESTROYED2];
        }
      )
    },
    {
      key: "flowing",
      get: (
        /**
        * true if the stream is currently in a flowing state, meaning that
        * any writes will be immediately emitted.
        */
        function() {
          return this[FLOWING2];
        }
      )
    },
    {
      key: "paused",
      get: (
        /**
        * true if the stream is currently in a paused state
        */
        function() {
          return this[PAUSED2];
        }
      )
    },
    {
      key: _BUFFERPUSH2,
      value: function(chunk) {
        this[OBJECTMODE2] ? this[BUFFERLENGTH2] += 1 : this[BUFFERLENGTH2] += chunk.length, this[BUFFER2].push(chunk);
      }
    },
    {
      key: _BUFFERSHIFT2,
      value: function() {
        return this[OBJECTMODE2] ? this[BUFFERLENGTH2] -= 1 : this[BUFFERLENGTH2] -= this[BUFFER2][0].length, this[BUFFER2].shift();
      }
    },
    {
      key: _FLUSH2,
      value: function() {
        var noDrain = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        do
          ;
        while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
        !noDrain && !this[BUFFER2].length && !this[EOF2] && this.emit("drain");
      }
    },
    {
      key: _FLUSHCHUNK2,
      value: function(chunk) {
        return this.emit("data", chunk), this[FLOWING2];
      }
    },
    {
      /**
      * Pipe all data emitted by this stream into the destination provided.
      *
      * Triggers the flow of data.
      */
      key: "pipe",
      value: function(dest, opts) {
        var _this = this;
        if (this[DESTROYED2])
          return dest;
        this[DISCARDED2] = !1;
        var ended = this[EMITTED_END2];
        return opts = opts || {}, dest === proc2.stdout || dest === proc2.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES2].push(opts.proxyErrors ? new PipeProxyErrors2(this, dest, opts) : new Pipe2(this, dest, opts)), this[ASYNC2] ? defer2(function() {
          return _this[RESUME2]();
        }) : this[RESUME2]()), dest;
      }
    },
    {
      /**
      * Fully unhook a piped destination stream.
      *
      * If the destination stream was the only consumer of this stream (ie,
      * there are no other piped destinations or `'data'` event listeners)
      * then the flow of data will stop until there is another consumer or
      * {@link Minipass#resume} is explicitly called.
      */
      key: "unpipe",
      value: function(dest) {
        var p = this[PIPES2].find(function(p2) {
          return p2.dest === dest;
        });
        p && (this[PIPES2].length === 1 ? (this[FLOWING2] && this[DATALISTENERS2] === 0 && (this[FLOWING2] = !1), this[PIPES2] = []) : this[PIPES2].splice(this[PIPES2].indexOf(p), 1), p.unpipe());
      }
    },
    {
      /**
      * Alias for {@link Minipass#on}
      */
      key: "addListener",
      value: function(ev, handler) {
        return this.on(ev, handler);
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.on`, with the following
      * behavior differences to prevent data loss and unnecessary hangs:
      *
      * - Adding a 'data' event handler will trigger the flow of data
      *
      * - Adding a 'readable' event handler when there is data waiting to be read
      *   will cause 'readable' to be emitted immediately.
      *
      * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
      *   already passed will cause the event to be emitted immediately and all
      *   handlers removed.
      *
      * - Adding an 'error' event handler after an error has been emitted will
      *   cause the event to be re-emitted immediately with the error previously
      *   raised.
      */
      key: "on",
      value: function(ev, handler) {
        var _this = this, ret = _get3(_get_prototype_of8(Minipass3.prototype), "on", this).call(this, ev, handler);
        if (ev === "data")
          this[DISCARDED2] = !1, this[DATALISTENERS2]++, !this[PIPES2].length && !this[FLOWING2] && this[RESUME2]();
        else if (ev === "readable" && this[BUFFERLENGTH2] !== 0)
          _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, "readable");
        else if (isEndish2(ev) && this[EMITTED_END2])
          _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, ev), this.removeAllListeners(ev);
        else if (ev === "error" && this[EMITTED_ERROR2]) {
          var h = handler;
          this[ASYNC2] ? defer2(function() {
            return h.call(_this, _this[EMITTED_ERROR2]);
          }) : h.call(this, this[EMITTED_ERROR2]);
        }
        return ret;
      }
    },
    {
      /**
      * Alias for {@link Minipass#off}
      */
      key: "removeListener",
      value: function(ev, handler) {
        return this.off(ev, handler);
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.off`
      *
      * If a 'data' event handler is removed, and it was the last consumer
      * (ie, there are no pipe destinations or other 'data' event listeners),
      * then the flow of data will stop until there is another consumer or
      * {@link Minipass#resume} is explicitly called.
      */
      key: "off",
      value: function(ev, handler) {
        var ret = _get3(_get_prototype_of8(Minipass3.prototype), "off", this).call(this, ev, handler);
        return ev === "data" && (this[DATALISTENERS2] = this.listeners("data").length, this[DATALISTENERS2] === 0 && !this[DISCARDED2] && !this[PIPES2].length && (this[FLOWING2] = !1)), ret;
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.removeAllListeners`
      *
      * If all 'data' event handlers are removed, and they were the last consumer
      * (ie, there are no pipe destinations), then the flow of data will stop
      * until there is another consumer or {@link Minipass#resume} is explicitly
      * called.
      */
      key: "removeAllListeners",
      value: function(ev) {
        var ret = _get3(_get_prototype_of8(Minipass3.prototype), "removeAllListeners", this).call(this, ev);
        return (ev === "data" || ev === void 0) && (this[DATALISTENERS2] = 0, !this[DISCARDED2] && !this[PIPES2].length && (this[FLOWING2] = !1)), ret;
      }
    },
    {
      key: "emittedEnd",
      get: (
        /**
        * true if the 'end' event has been emitted
        */
        function() {
          return this[EMITTED_END2];
        }
      )
    },
    {
      key: _MAYBE_EMIT_END2,
      value: function() {
        !this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2] && (this[EMITTING_END2] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED2] && this.emit("close"), this[EMITTING_END2] = !1);
      }
    },
    {
      /**
      * Mostly identical to `EventEmitter.emit`, with the following
      * behavior differences to prevent data loss and unnecessary hangs:
      *
      * If the stream has been destroyed, and the event is something other
      * than 'close' or 'error', then `false` is returned and no handlers
      * are called.
      *
      * If the event is 'end', and has already been emitted, then the event
      * is ignored. If the stream is in a paused or non-flowing state, then
      * the event will be deferred until data flow resumes. If the stream is
      * async, then handlers will be called on the next tick rather than
      * immediately.
      *
      * If the event is 'close', and 'end' has not yet been emitted, then
      * the event will be deferred until after 'end' is emitted.
      *
      * If the event is 'error', and an AbortSignal was provided for the stream,
      * and there are no listeners, then the event is ignored, matching the
      * behavior of node core streams in the presense of an AbortSignal.
      *
      * If the event is 'finish' or 'prefinish', then all listeners will be
      * removed after emitting the event, to prevent double-firing.
      */
      key: "emit",
      value: function(ev) {
        for (var _this = this, _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          args[_key - 1] = arguments[_key];
        var _$_get, data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2])
          return !1;
        if (ev === "data")
          return !this[OBJECTMODE2] && !data ? !1 : this[ASYNC2] ? (defer2(function() {
            return _this[EMITDATA2](data);
          }), !0) : this[EMITDATA2](data);
        if (ev === "end")
          return this[EMITEND3]();
        if (ev === "close") {
          if (this[CLOSED2] = !0, !this[EMITTED_END2] && !this[DESTROYED2])
            return !1;
          var ret = _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, "close");
          return this.removeAllListeners("close"), ret;
        } else if (ev === "error") {
          this[EMITTED_ERROR2] = data, _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, ERROR2, data);
          var ret1 = !this[SIGNAL2] || this.listeners("error").length ? _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, "error", data) : !1;
          return this[MAYBE_EMIT_END2](), ret1;
        } else if (ev === "resume") {
          var ret2 = _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, "resume");
          return this[MAYBE_EMIT_END2](), ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          var ret3 = _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, ev);
          return this.removeAllListeners(ev), ret3;
        }
        var ret4 = (_$_get = _get3(_get_prototype_of8(Minipass3.prototype), "emit", this)).call.apply(_$_get, [
          this,
          ev
        ].concat(_to_consumable_array10(args)));
        return this[MAYBE_EMIT_END2](), ret4;
      }
    },
    {
      key: _EMITDATA2,
      value: function(data) {
        var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = this[PIPES2][Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var p = _step.value;
            p.dest.write(data) === !1 && this.pause();
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var ret = this[DISCARDED2] ? !1 : _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, "data", data);
        return this[MAYBE_EMIT_END2](), ret;
      }
    },
    {
      key: _EMITEND3,
      value: function() {
        var _this = this;
        return this[EMITTED_END2] ? !1 : (this[EMITTED_END2] = !0, this.readable = !1, this[ASYNC2] ? (defer2(function() {
          return _this[EMITEND22]();
        }), !0) : this[EMITEND22]());
      }
    },
    {
      key: _EMITEND22,
      value: function() {
        if (this[DECODER2]) {
          var data = this[DECODER2].end();
          if (data) {
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator = this[PIPES2][Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
                var p = _step.value;
                p.dest.write(data);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            this[DISCARDED2] || _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, "data", data);
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = this[PIPES2][Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var p1 = _step1.value;
            p1.end();
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        var ret = _get3(_get_prototype_of8(Minipass3.prototype), "emit", this).call(this, "end");
        return this.removeAllListeners("end"), ret;
      }
    },
    {
      key: "collect",
      value: (
        /**
        * Return a Promise that resolves to an array of all emitted data once
        * the stream ends.
        */
        function() {
          var _this = this;
          return _async_to_generator8(function() {
            var buf, p;
            return _ts_generator8(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return buf = Object.assign([], {
                    dataLength: 0
                  }), _this[OBJECTMODE2] || (buf.dataLength = 0), p = _this.promise(), _this.on("data", function(c) {
                    buf.push(c), _this[OBJECTMODE2] || (buf.dataLength += c.length);
                  }), [
                    4,
                    p
                  ];
                case 1:
                  return _state.sent(), [
                    2,
                    buf
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "concat",
      value: (
        /**
        * Return a Promise that resolves to the concatenation of all emitted data
        * once the stream ends.
        *
        * Not allowed on objectMode streams.
        */
        function() {
          var _this = this;
          return _async_to_generator8(function() {
            var buf;
            return _ts_generator8(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (_this[OBJECTMODE2])
                    throw new Error("cannot concat in objectMode");
                  return [
                    4,
                    _this.collect()
                  ];
                case 1:
                  return buf = _state.sent(), [
                    2,
                    _this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "promise",
      value: (
        /**
        * Return a void Promise that resolves once the stream ends.
        */
        function() {
          var _this = this;
          return _async_to_generator8(function() {
            return _ts_generator8(this, function(_state) {
              return [
                2,
                new Promise(function(resolve7, reject) {
                  _this.on(DESTROYED2, function() {
                    return reject(new Error("stream destroyed"));
                  }), _this.on("error", function(er) {
                    return reject(er);
                  }), _this.on("end", function() {
                    return resolve7();
                  });
                })
              ];
            });
          })();
        }
      )
    },
    {
      /**
      * Asynchronous `for await of` iteration.
      *
      * This will continue emitting all chunks until the stream terminates.
      */
      key: _Symbol_asyncIterator3,
      value: function() {
        var _this = this;
        this[DISCARDED2] = !1;
        var stopped = !1, _this1 = this, stop = function() {
          var _ref = _async_to_generator8(function() {
            return _ts_generator8(this, function(_state) {
              return _this1.pause(), stopped = !0, [
                2,
                {
                  value: void 0,
                  done: !0
                }
              ];
            });
          });
          return function() {
            return _ref.apply(this, arguments);
          };
        }(), next = function() {
          if (stopped)
            return stop();
          var res = _this.read();
          if (res !== null)
            return Promise.resolve({
              done: !1,
              value: res
            });
          if (_this[EOF2])
            return stop();
          var resolve7, reject, onerr = function(er) {
            _this.off("data", ondata), _this.off("end", onend), _this.off(DESTROYED2, ondestroy), stop(), reject(er);
          }, ondata = function(value2) {
            _this.off("error", onerr), _this.off("end", onend), _this.off(DESTROYED2, ondestroy), _this.pause(), resolve7({
              value: value2,
              done: !!_this[EOF2]
            });
          }, onend = function() {
            _this.off("error", onerr), _this.off("data", ondata), _this.off(DESTROYED2, ondestroy), stop(), resolve7({
              done: !0,
              value: void 0
            });
          }, ondestroy = function() {
            return onerr(new Error("stream destroyed"));
          };
          return new Promise(function(res2, rej) {
            reject = rej, resolve7 = res2, _this.once(DESTROYED2, ondestroy), _this.once("error", onerr), _this.once("end", onend), _this.once("data", ondata);
          });
        };
        return _define_property13({
          next,
          throw: stop,
          return: stop
        }, Symbol.asyncIterator, function() {
          return this;
        });
      }
    },
    {
      /**
      * Synchronous `for of` iteration.
      *
      * The iteration will terminate when the internal buffer runs out, even
      * if the stream has not yet terminated.
      */
      key: _Symbol_iterator4,
      value: function() {
        var _this = this;
        this[DISCARDED2] = !1;
        var stopped = !1, stop = function() {
          return _this.pause(), _this.off(ERROR2, stop), _this.off(DESTROYED2, stop), _this.off("end", stop), stopped = !0, {
            done: !0,
            value: void 0
          };
        }, next = function() {
          if (stopped)
            return stop();
          var value2 = _this.read();
          return value2 === null ? stop() : {
            done: !1,
            value: value2
          };
        };
        return this.once("end", stop), this.once(ERROR2, stop), this.once(DESTROYED2, stop), _define_property13({
          next,
          throw: stop,
          return: stop
        }, Symbol.iterator, function() {
          return this;
        });
      }
    },
    {
      /**
      * Destroy a stream, preventing it from being used for any further purpose.
      *
      * If the stream has a `close()` method, then it will be called on
      * destruction.
      *
      * After destruction, any attempt to write data, read data, or emit most
      * events will be ignored.
      *
      * If an error argument is provided, then it will be emitted in an
      * 'error' event.
      */
      key: "destroy",
      value: function(er) {
        if (this[DESTROYED2])
          return er ? this.emit("error", er) : this.emit(DESTROYED2), this;
        this[DESTROYED2] = !0, this[DISCARDED2] = !0, this[BUFFER2].length = 0, this[BUFFERLENGTH2] = 0;
        var wc = this;
        return typeof wc.close == "function" && !this[CLOSED2] && wc.close(), er ? this.emit("error", er) : this.emit(DESTROYED2), this;
      }
    }
  ], [
    {
      key: "isStream",
      get: (
        /**
        * Alias for {@link isStream}
        *
        * Former export location, maintained for backwards compatibility.
        *
        * @deprecated
        */
        function() {
          return isStream2;
        }
      )
    }
  ]), Minipass3;
}(import_events2.EventEmitter);

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/ignore.js
function _class_call_check11(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class9(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties9(Constructor.prototype, protoProps), staticProps && _defineProperties9(Constructor, staticProps), Constructor;
}
function _define_property14(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var defaultPlatform2 = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux", Ignore = /* @__PURE__ */ function() {
  "use strict";
  function Ignore2(ignored2, param) {
    var nobrace = param.nobrace, nocase = param.nocase, noext = param.noext, noglobstar = param.noglobstar, _param_platform = param.platform, platform = _param_platform === void 0 ? defaultPlatform2 : _param_platform;
    _class_call_check11(this, Ignore2), _define_property14(this, "relative", void 0), _define_property14(this, "relativeChildren", void 0), _define_property14(this, "absolute", void 0), _define_property14(this, "absoluteChildren", void 0), this.relative = [], this.absolute = [], this.relativeChildren = [], this.absoluteChildren = [];
    var mmopts = {
      dot: !0,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform,
      nocomment: !0,
      nonegate: !0
    }, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
    try {
      for (var _iterator = ignored2[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0)
        for (var ign = _step.value, mm = new Minimatch(ign, mmopts), i = 0; i < mm.set.length; i++) {
          var parsed = mm.set[i], globParts = mm.globParts[i], p = new Pattern(parsed, globParts, 0, platform), m = new Minimatch(p.globString(), mmopts), children = globParts[globParts.length - 1] === "**", absolute = p.isAbsolute();
          absolute ? this.absolute.push(m) : this.relative.push(m), children && (absolute ? this.absoluteChildren.push(m) : this.relativeChildren.push(m));
        }
    } catch (err) {
      _didIteratorError2 = !0, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError2)
          throw _iteratorError2;
      }
    }
  }
  return _create_class9(Ignore2, [
    {
      key: "ignored",
      value: function(p) {
        var fullpath = p.fullpath(), fullpaths = "".concat(fullpath, "/"), relative = p.relative() || ".", relatives = "".concat(relative, "/"), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = this.relative[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var m = _step.value;
            if (m.match(relative) || m.match(relatives))
              return !0;
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = this.absolute[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var m1 = _step1.value;
            if (m1.match(fullpath) || m1.match(fullpaths))
              return !0;
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        return !1;
      }
    },
    {
      key: "childrenIgnored",
      value: function(p) {
        var fullpath = p.fullpath() + "/", relative = (p.relative() || ".") + "/", _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = this.relativeChildren[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var m = _step.value;
            if (m.match(relative))
              return !0;
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = this.absoluteChildren[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var m1 = _step1.value;
            m1.match(fullpath);
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        return !1;
      }
    }
  ]), Ignore2;
}();

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/processor.js
function _array_like_to_array15(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes12(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes11(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array15(arr);
}
function _class_call_check12(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties10(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class10(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties10(Constructor.prototype, protoProps), staticProps && _defineProperties10(Constructor, staticProps), Constructor;
}
function _define_property15(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _instanceof10(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array11(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit11(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest12() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread11() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array11(arr, i) {
  return _array_with_holes12(arr) || _iterable_to_array_limit11(arr, i) || _unsupported_iterable_to_array15(arr, i) || _non_iterable_rest12();
}
function _to_consumable_array11(arr) {
  return _array_without_holes11(arr) || _iterable_to_array11(arr) || _unsupported_iterable_to_array15(arr) || _non_iterable_spread11();
}
function _unsupported_iterable_to_array15(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array15(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array15(o, minLen);
  }
}
var HasWalkedCache = /* @__PURE__ */ function() {
  "use strict";
  function HasWalkedCache2() {
    var store = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Map();
    _class_call_check12(this, HasWalkedCache2), _define_property15(this, "store", void 0), this.store = store;
  }
  return _create_class10(HasWalkedCache2, [
    {
      key: "copy",
      value: function() {
        return new HasWalkedCache2(new Map(this.store));
      }
    },
    {
      key: "hasWalked",
      value: function(target, pattern) {
        var _this_store_get;
        return (_this_store_get = this.store.get(target.fullpath())) === null || _this_store_get === void 0 ? void 0 : _this_store_get.has(pattern.globString());
      }
    },
    {
      key: "storeWalked",
      value: function(target, pattern) {
        var fullpath = target.fullpath(), cached = this.store.get(fullpath);
        cached ? cached.add(pattern.globString()) : this.store.set(fullpath, /* @__PURE__ */ new Set([
          pattern.globString()
        ]));
      }
    }
  ]), HasWalkedCache2;
}(), MatchRecord = /* @__PURE__ */ function() {
  "use strict";
  function MatchRecord2() {
    _class_call_check12(this, MatchRecord2), _define_property15(this, "store", /* @__PURE__ */ new Map());
  }
  return _create_class10(MatchRecord2, [
    {
      key: "add",
      value: function(target, absolute, ifDir) {
        var n = (absolute ? 2 : 0) | (ifDir ? 1 : 0), current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
    },
    {
      // match, absolute, ifdir
      key: "entries",
      value: function() {
        return _to_consumable_array11(this.store.entries()).map(function(param) {
          var _param = _sliced_to_array11(param, 2), path6 = _param[0], n = _param[1];
          return [
            path6,
            !!(n & 2),
            !!(n & 1)
          ];
        });
      }
    }
  ]), MatchRecord2;
}(), SubWalks = /* @__PURE__ */ function() {
  "use strict";
  function SubWalks2() {
    _class_call_check12(this, SubWalks2), _define_property15(this, "store", /* @__PURE__ */ new Map());
  }
  return _create_class10(SubWalks2, [
    {
      key: "add",
      value: function(target, pattern) {
        if (target.canReaddir()) {
          var subs = this.store.get(target);
          subs ? subs.find(function(p) {
            return p.globString() === pattern.globString();
          }) || subs.push(pattern) : this.store.set(target, [
            pattern
          ]);
        }
      }
    },
    {
      key: "get",
      value: function(target) {
        var subs = this.store.get(target);
        if (!subs)
          throw new Error("attempting to walk unknown path");
        return subs;
      }
    },
    {
      key: "entries",
      value: function() {
        var _this = this;
        return this.keys().map(function(k) {
          return [
            k,
            _this.store.get(k)
          ];
        });
      }
    },
    {
      key: "keys",
      value: function() {
        return _to_consumable_array11(this.store.keys()).filter(function(t) {
          return t.canReaddir();
        });
      }
    }
  ]), SubWalks2;
}(), Processor = /* @__PURE__ */ function() {
  "use strict";
  function Processor2(opts, hasWalkedCache) {
    _class_call_check12(this, Processor2), _define_property15(this, "hasWalkedCache", void 0), _define_property15(this, "matches", new MatchRecord()), _define_property15(this, "subwalks", new SubWalks()), _define_property15(this, "patterns", void 0), _define_property15(this, "follow", void 0), _define_property15(this, "dot", void 0), _define_property15(this, "opts", void 0), this.opts = opts, this.follow = !!opts.follow, this.dot = !!opts.dot, this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  return _create_class10(Processor2, [
    {
      key: "processPatterns",
      value: function(target, patterns) {
        this.patterns = patterns;
        var processingSet = patterns.map(function(p2) {
          return [
            target,
            p2
          ];
        }), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = processingSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array11(_step.value, 2), t = _step_value[0], pattern = _step_value[1];
            this.hasWalkedCache.storeWalked(t, pattern);
            var root = pattern.root(), absolute = pattern.isAbsolute() && this.opts.absolute !== !1;
            if (root) {
              t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
              var rest = pattern.rest();
              if (rest)
                pattern = rest;
              else {
                this.matches.add(t, !0, !1);
                continue;
              }
            }
            if (!t.isENOENT()) {
              for (var p = void 0, rest1 = void 0, changed = !1; typeof (p = pattern.pattern()) == "string" && (rest1 = pattern.rest()); ) {
                var c = t.resolve(p);
                if (c.isUnknown() && p !== "..")
                  break;
                t = c, pattern = rest1, changed = !0;
              }
              if (p = pattern.pattern(), rest1 = pattern.rest(), changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                  continue;
                this.hasWalkedCache.storeWalked(t, pattern);
              }
              if (typeof p == "string") {
                if (rest1)
                  this.subwalks.add(t, pattern);
                else {
                  var ifDir = p === ".." || p === "" || p === ".";
                  this.matches.add(t.resolve(p), absolute, ifDir);
                }
                continue;
              } else if (p === GLOBSTAR) {
                (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) && this.subwalks.add(t, pattern);
                var rp = rest1 == null ? void 0 : rest1.pattern(), rrest = rest1 == null ? void 0 : rest1.rest();
                if (!rest1 || (rp === "" || rp === ".") && !rrest)
                  this.matches.add(t, absolute, rp === "" || rp === ".");
                else if (rp === "..") {
                  var tp = t.parent || t;
                  rrest ? this.hasWalkedCache.hasWalked(tp, rrest) || this.subwalks.add(tp, rrest) : this.matches.add(tp, absolute, !0);
                }
              } else
                _instanceof10(p, RegExp) && this.subwalks.add(t, pattern);
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return this;
      }
    },
    {
      key: "subwalkTargets",
      value: function() {
        return this.subwalks.keys();
      }
    },
    {
      key: "child",
      value: function() {
        return new Processor2(this.opts, this.hasWalkedCache);
      }
    },
    {
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      key: "filterEntries",
      value: function(parent, entries) {
        var patterns = this.subwalks.get(parent), results = this.child(), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var e = _step.value, _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
            try {
              for (var _iterator1 = patterns[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
                var pattern = _step1.value, absolute = pattern.isAbsolute(), p = pattern.pattern(), rest = pattern.rest();
                p === GLOBSTAR ? results.testGlobstar(e, pattern, rest, absolute) : _instanceof10(p, RegExp) ? results.testRegExp(e, p, rest, absolute) : results.testString(e, p, rest, absolute);
              }
            } catch (err) {
              _didIteratorError12 = !0, _iteratorError12 = err;
            } finally {
              try {
                !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        return results;
      }
    },
    {
      key: "testGlobstar",
      value: function(e, pattern, rest, absolute) {
        if ((this.dot || !e.name.startsWith(".")) && (pattern.hasMore() || this.matches.add(e, absolute, !1), e.canReaddir() && (this.follow || !e.isSymbolicLink() ? this.subwalks.add(e, pattern) : e.isSymbolicLink() && (rest && pattern.checkFollowGlobstar() ? this.subwalks.add(e, rest) : pattern.markFollowGlobstar() && this.subwalks.add(e, pattern)))), rest) {
          var rp = rest.pattern();
          if (typeof rp == "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".")
            this.testString(e, rp, rest.rest(), absolute);
          else if (rp === "..") {
            var ep = e.parent || e;
            this.subwalks.add(ep, rest);
          } else
            _instanceof10(rp, RegExp) && this.testRegExp(e, rp, rest.rest(), absolute);
        }
      }
    },
    {
      key: "testRegExp",
      value: function(e, p, rest, absolute) {
        p.test(e.name) && (rest ? this.subwalks.add(e, rest) : this.matches.add(e, absolute, !1));
      }
    },
    {
      key: "testString",
      value: function(e, p, rest, absolute) {
        e.isNamed(p) && (rest ? this.subwalks.add(e, rest) : this.matches.add(e, absolute, !1));
      }
    }
  ]), Processor2;
}();

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/walker.js
function _array_like_to_array16(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes13(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _assert_this_initialized9(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function asyncGeneratorStep9(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator9(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep9(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep9(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _check_private_redeclaration5(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _class_apply_descriptor_get5(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _class_apply_descriptor_set5(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _class_call_check13(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _class_extract_field_descriptor5(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}
function _class_private_field_get5(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor5(receiver, privateMap, "get");
  return _class_apply_descriptor_get5(receiver, descriptor);
}
function _class_private_field_init5(obj, privateMap, value) {
  _check_private_redeclaration5(obj, privateMap), privateMap.set(obj, value);
}
function _class_private_field_set5(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor5(receiver, privateMap, "set");
  return _class_apply_descriptor_set5(receiver, descriptor, value), value;
}
function _class_private_method_get4(receiver, privateSet, fn) {
  if (!privateSet.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return fn;
}
function _class_private_method_init4(obj, privateSet) {
  _check_private_redeclaration5(obj, privateSet), privateSet.add(obj);
}
function _defineProperties11(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class11(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties11(Constructor.prototype, protoProps), staticProps && _defineProperties11(Constructor, staticProps), Constructor;
}
function _define_property16(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _get_prototype_of9(o) {
  return _get_prototype_of9 = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of9(o);
}
function _inherits9(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of9(subClass, superClass);
}
function _iterable_to_array_limit12(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest13() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return9(self, call) {
  return call && (_type_of10(call) === "object" || typeof call == "function") ? call : _assert_this_initialized9(self);
}
function _set_prototype_of9(o, p) {
  return _set_prototype_of9 = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of9(o, p);
}
function _sliced_to_array12(arr, i) {
  return _array_with_holes13(arr) || _iterable_to_array_limit12(arr, i) || _unsupported_iterable_to_array16(arr, i) || _non_iterable_rest13();
}
function _type_of10(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array16(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array16(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array16(o, minLen);
  }
}
function _is_native_reflect_construct9() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _create_super9(Derived) {
  var hasNativeReflectConstruct = _is_native_reflect_construct9();
  return function() {
    var Super = _get_prototype_of9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _get_prototype_of9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possible_constructor_return9(this, result);
  };
}
function _ts_generator9(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var makeIgnore = function(ignore, opts) {
  return typeof ignore == "string" ? new Ignore([
    ignore
  ], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
}, _onResume = /* @__PURE__ */ new WeakMap(), _ignore = /* @__PURE__ */ new WeakMap(), _sep = /* @__PURE__ */ new WeakMap(), _ignored = /* @__PURE__ */ new WeakSet(), _childrenIgnored = /* @__PURE__ */ new WeakSet(), GlobUtil = /* @__PURE__ */ function() {
  "use strict";
  function GlobUtil2(patterns, path6, opts) {
    var _this = this;
    _class_call_check13(this, GlobUtil2), _class_private_method_init4(this, _ignored), _class_private_method_init4(this, _childrenIgnored), _define_property16(this, "path", void 0), _define_property16(this, "patterns", void 0), _define_property16(this, "opts", void 0), _define_property16(this, "seen", /* @__PURE__ */ new Set()), _define_property16(this, "paused", !1), _define_property16(this, "aborted", !1), _class_private_field_init5(this, _onResume, {
      writable: !0,
      value: []
    }), _class_private_field_init5(this, _ignore, {
      writable: !0,
      value: void 0
    }), _class_private_field_init5(this, _sep, {
      writable: !0,
      value: void 0
    }), _define_property16(this, "signal", void 0), _define_property16(this, "maxDepth", void 0), this.patterns = patterns, this.path = path6, this.opts = opts, _class_private_field_set5(this, _sep, !opts.posix && opts.platform === "win32" ? "\\" : "/"), opts.ignore && _class_private_field_set5(this, _ignore, makeIgnore(opts.ignore, opts)), this.maxDepth = opts.maxDepth || 1 / 0, opts.signal && (this.signal = opts.signal, this.signal.addEventListener("abort", function() {
      _class_private_field_get5(_this, _onResume).length = 0;
    }));
  }
  return _create_class11(GlobUtil2, [
    {
      // backpressure mechanism
      key: "pause",
      value: function() {
        this.paused = !0;
      }
    },
    {
      key: "resume",
      value: function() {
        var _this_signal;
        if (!(!((_this_signal = this.signal) === null || _this_signal === void 0) && _this_signal.aborted)) {
          this.paused = !1;
          for (var fn = void 0; !this.paused && (fn = _class_private_field_get5(this, _onResume).shift()); )
            fn();
        }
      }
    },
    {
      key: "onResume",
      value: function(fn) {
        var _this_signal;
        !((_this_signal = this.signal) === null || _this_signal === void 0) && _this_signal.aborted || (this.paused ? _class_private_field_get5(this, _onResume).push(fn) : fn());
      }
    },
    {
      key: "matchCheck",
      value: (
        // do the requisite realpath/stat checking, and return the path
        // to add or undefined to filter it out.
        function(e, ifDir) {
          var _this = this;
          return _async_to_generator9(function() {
            var rpc, _tmp, needStat, _, _tmp1;
            return _ts_generator9(this, function(_state) {
              switch (_state.label) {
                case 0:
                  return ifDir && _this.opts.nodir ? [
                    2,
                    void 0
                  ] : _this.opts.realpath ? (_tmp = e.realpathCached(), _tmp ? [
                    3,
                    2
                  ] : [
                    4,
                    e.realpath()
                  ]) : [
                    3,
                    3
                  ];
                case 1:
                  _tmp = _state.sent(), _state.label = 2;
                case 2:
                  if (rpc = _tmp, !rpc)
                    return [
                      2,
                      void 0
                    ];
                  e = rpc, _state.label = 3;
                case 3:
                  return needStat = e.isUnknown() || _this.opts.stat, _ = _this.matchCheckTest, needStat ? [
                    4,
                    e.lstat()
                  ] : [
                    3,
                    5
                  ];
                case 4:
                  return _tmp1 = _state.sent(), [
                    3,
                    6
                  ];
                case 5:
                  _tmp1 = e, _state.label = 6;
                case 6:
                  return [
                    2,
                    _.apply(_this, [
                      _tmp1,
                      ifDir
                    ])
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "matchCheckTest",
      value: function(e, ifDir) {
        return e && (this.maxDepth === 1 / 0 || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !_class_private_method_get4(this, _ignored, ignored).call(this, e) ? e : void 0;
      }
    },
    {
      key: "matchCheckSync",
      value: function(e, ifDir) {
        if (!(ifDir && this.opts.nodir)) {
          var rpc;
          if (this.opts.realpath) {
            if (rpc = e.realpathCached() || e.realpathSync(), !rpc)
              return;
            e = rpc;
          }
          var needStat = e.isUnknown() || this.opts.stat;
          return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
        }
      }
    },
    {
      key: "matchFinish",
      value: function(e, absolute) {
        if (!_class_private_method_get4(this, _ignored, ignored).call(this, e)) {
          var abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
          this.seen.add(e);
          var mark = this.opts.mark && e.isDirectory() ? _class_private_field_get5(this, _sep) : "";
          if (this.opts.withFileTypes)
            this.matchEmit(e);
          else if (abs) {
            var abs1 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs1 + mark);
          } else {
            var rel = this.opts.posix ? e.relativePosix() : e.relative(), pre = this.opts.dotRelative && !rel.startsWith(".." + _class_private_field_get5(this, _sep)) ? "." + _class_private_field_get5(this, _sep) : "";
            this.matchEmit(rel ? pre + rel + mark : "." + mark);
          }
        }
      }
    },
    {
      key: "match",
      value: function(e, absolute, ifDir) {
        var _this = this;
        return _async_to_generator9(function() {
          var p;
          return _ts_generator9(this, function(_state) {
            switch (_state.label) {
              case 0:
                return [
                  4,
                  _this.matchCheck(e, ifDir)
                ];
              case 1:
                return p = _state.sent(), p && _this.matchFinish(p, absolute), [
                  2
                ];
            }
          });
        })();
      }
    },
    {
      key: "matchSync",
      value: function(e, absolute, ifDir) {
        var p = this.matchCheckSync(e, ifDir);
        p && this.matchFinish(p, absolute);
      }
    },
    {
      key: "walkCB",
      value: function(target, patterns, cb) {
        var _this_signal;
        !((_this_signal = this.signal) === null || _this_signal === void 0) && _this_signal.aborted && cb(), this.walkCB2(target, patterns, new Processor(this.opts), cb);
      }
    },
    {
      key: "walkCB2",
      value: function(target, patterns, processor, cb) {
        var _this = this, _this_signal;
        if (_class_private_method_get4(this, _childrenIgnored, childrenIgnored).call(this, target))
          return cb();
        if (!((_this_signal = this.signal) === null || _this_signal === void 0) && _this_signal.aborted && cb(), this.paused) {
          this.onResume(function() {
            return _this.walkCB2(target, patterns, processor, cb);
          });
          return;
        }
        processor.processPatterns(target, patterns);
        var tasks = 1, next = function() {
          --tasks === 0 && cb();
        }, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = processor.matches.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array12(_step.value, 3), m = _step_value[0], absolute = _step_value[1], ifDir = _step_value[2];
            _class_private_method_get4(this, _ignored, ignored).call(this, m) || (tasks++, this.match(m, absolute, ifDir).then(function() {
              return next();
            }));
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _this1 = this, _loop = function() {
            var t = _step1.value;
            if (_this1.maxDepth !== 1 / 0 && t.depth() >= _this1.maxDepth)
              return "continue";
            tasks++;
            var childrenCached = t.readdirCached();
            t.calledReaddir() ? _this1.walkCB3(t, childrenCached, processor, next) : t.readdirCB(function(_, entries) {
              return _this.walkCB3(t, entries, processor, next);
            }, !0);
          }, _iterator1 = processor.subwalkTargets()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0)
            _loop();
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        next();
      }
    },
    {
      key: "walkCB3",
      value: function(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        var tasks = 1, next = function() {
          --tasks === 0 && cb();
        }, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = processor.matches.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array12(_step.value, 3), m = _step_value[0], absolute = _step_value[1], ifDir = _step_value[2];
            _class_private_method_get4(this, _ignored, ignored).call(this, m) || (tasks++, this.match(m, absolute, ifDir).then(function() {
              return next();
            }));
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = processor.subwalks.entries()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var _step_value1 = _sliced_to_array12(_step1.value, 2), _$target = _step_value1[0], patterns = _step_value1[1];
            tasks++, this.walkCB2(_$target, patterns, processor.child(), next);
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        next();
      }
    },
    {
      key: "walkCBSync",
      value: function(target, patterns, cb) {
        var _this_signal;
        !((_this_signal = this.signal) === null || _this_signal === void 0) && _this_signal.aborted && cb(), this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
      }
    },
    {
      key: "walkCB2Sync",
      value: function(target, patterns, processor, cb) {
        var _this = this, _this_signal;
        if (_class_private_method_get4(this, _childrenIgnored, childrenIgnored).call(this, target))
          return cb();
        if (!((_this_signal = this.signal) === null || _this_signal === void 0) && _this_signal.aborted && cb(), this.paused) {
          this.onResume(function() {
            return _this.walkCB2Sync(target, patterns, processor, cb);
          });
          return;
        }
        processor.processPatterns(target, patterns);
        var tasks = 1, next = function() {
          --tasks === 0 && cb();
        }, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = processor.matches.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array12(_step.value, 3), m = _step_value[0], absolute = _step_value[1], ifDir = _step_value[2];
            _class_private_method_get4(this, _ignored, ignored).call(this, m) || this.matchSync(m, absolute, ifDir);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = processor.subwalkTargets()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var t = _step1.value;
            if (!(this.maxDepth !== 1 / 0 && t.depth() >= this.maxDepth)) {
              tasks++;
              var children = t.readdirSync();
              this.walkCB3Sync(t, children, processor, next);
            }
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        next();
      }
    },
    {
      key: "walkCB3Sync",
      value: function(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        var tasks = 1, next = function() {
          --tasks === 0 && cb();
        }, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
        try {
          for (var _iterator = processor.matches.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
            var _step_value = _sliced_to_array12(_step.value, 3), m = _step_value[0], absolute = _step_value[1], ifDir = _step_value[2];
            _class_private_method_get4(this, _ignored, ignored).call(this, m) || this.matchSync(m, absolute, ifDir);
          }
        } catch (err) {
          _didIteratorError2 = !0, _iteratorError2 = err;
        } finally {
          try {
            !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError2)
              throw _iteratorError2;
          }
        }
        var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
        try {
          for (var _iterator1 = processor.subwalks.entries()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion12 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion12 = !0) {
            var _step_value1 = _sliced_to_array12(_step1.value, 2), _$target = _step_value1[0], patterns = _step_value1[1];
            tasks++, this.walkCB2Sync(_$target, patterns, processor.child(), next);
          }
        } catch (err) {
          _didIteratorError12 = !0, _iteratorError12 = err;
        } finally {
          try {
            !_iteratorNormalCompletion12 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError12)
              throw _iteratorError12;
          }
        }
        next();
      }
    }
  ]), GlobUtil2;
}();
function ignored(path6) {
  var _class_private_field_get_ignored, _$_class_private_field_get;
  return this.seen.has(path6) || !!(!((_$_class_private_field_get = _class_private_field_get5(this, _ignore)) === null || _$_class_private_field_get === void 0 || (_class_private_field_get_ignored = _$_class_private_field_get.ignored) === null || _class_private_field_get_ignored === void 0) && _class_private_field_get_ignored.call(_$_class_private_field_get, path6));
}
function childrenIgnored(path6) {
  var _class_private_field_get_childrenIgnored, _$_class_private_field_get;
  return !!(!((_$_class_private_field_get = _class_private_field_get5(this, _ignore)) === null || _$_class_private_field_get === void 0 || (_class_private_field_get_childrenIgnored = _$_class_private_field_get.childrenIgnored) === null || _class_private_field_get_childrenIgnored === void 0) && _class_private_field_get_childrenIgnored.call(_$_class_private_field_get, path6));
}
var GlobWalker = /* @__PURE__ */ function(GlobUtil2) {
  "use strict";
  _inherits9(GlobWalker2, GlobUtil2);
  var _super = _create_super9(GlobWalker2);
  function GlobWalker2(patterns, path6, opts) {
    _class_call_check13(this, GlobWalker2);
    var _this;
    return _this = _super.call(this, patterns, path6, opts), _define_property16(_assert_this_initialized9(_this), "matches", void 0), _this.matches = /* @__PURE__ */ new Set(), _this;
  }
  return _create_class11(GlobWalker2, [
    {
      key: "matchEmit",
      value: function(e) {
        this.matches.add(e);
      }
    },
    {
      key: "walk",
      value: function() {
        var _this = this;
        return _async_to_generator9(function() {
          var _this_signal;
          return _ts_generator9(this, function(_state) {
            switch (_state.label) {
              case 0:
                if (!((_this_signal = _this.signal) === null || _this_signal === void 0) && _this_signal.aborted)
                  throw _this.signal.reason;
                return _this.path.isUnknown() ? [
                  4,
                  _this.path.lstat()
                ] : [
                  3,
                  2
                ];
              case 1:
                _state.sent(), _state.label = 2;
              case 2:
                return [
                  4,
                  new Promise(function(res, rej) {
                    _this.walkCB(_this.path, _this.patterns, function() {
                      var _this_signal2;
                      !((_this_signal2 = _this.signal) === null || _this_signal2 === void 0) && _this_signal2.aborted ? rej(_this.signal.reason) : res(_this.matches);
                    });
                  })
                ];
              case 3:
                return _state.sent(), [
                  2,
                  _this.matches
                ];
            }
          });
        })();
      }
    },
    {
      key: "walkSync",
      value: function() {
        var _this = this, _this_signal;
        if (!((_this_signal = this.signal) === null || _this_signal === void 0) && _this_signal.aborted)
          throw this.signal.reason;
        return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, function() {
          var _this_signal2;
          if (!((_this_signal2 = _this.signal) === null || _this_signal2 === void 0) && _this_signal2.aborted)
            throw _this.signal.reason;
        }), this.matches;
      }
    }
  ]), GlobWalker2;
}(GlobUtil), GlobStream = /* @__PURE__ */ function(GlobUtil2) {
  "use strict";
  _inherits9(GlobStream2, GlobUtil2);
  var _super = _create_super9(GlobStream2);
  function GlobStream2(patterns, path6, opts) {
    _class_call_check13(this, GlobStream2);
    var _this;
    return _this = _super.call(this, patterns, path6, opts), _define_property16(_assert_this_initialized9(_this), "results", void 0), _this.results = new Minipass2({
      signal: _this.signal,
      objectMode: !0
    }), _this.results.on("drain", function() {
      return _this.resume();
    }), _this.results.on("resume", function() {
      return _this.resume();
    }), _this;
  }
  return _create_class11(GlobStream2, [
    {
      key: "matchEmit",
      value: function(e) {
        this.results.write(e), this.results.flowing || this.pause();
      }
    },
    {
      key: "stream",
      value: function() {
        var _this = this, target = this.path;
        return target.isUnknown() ? target.lstat().then(function() {
          _this.walkCB(target, _this.patterns, function() {
            return _this.results.end();
          });
        }) : this.walkCB(target, this.patterns, function() {
          return _this.results.end();
        }), this.results;
      }
    },
    {
      key: "streamSync",
      value: function() {
        var _this = this;
        return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, function() {
          return _this.results.end();
        }), this.results;
      }
    }
  ]), GlobStream2;
}(GlobUtil);

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/glob.js
function _array_like_to_array17(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes14(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes12(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array17(arr);
}
function asyncGeneratorStep10(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator10(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep10(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep10(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _class_call_check14(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties12(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class12(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties12(Constructor.prototype, protoProps), staticProps && _defineProperties12(Constructor, staticProps), Constructor;
}
function _define_property17(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _instanceof11(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array12(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit13(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest14() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread12() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property17(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props6(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array13(arr, i) {
  return _array_with_holes14(arr) || _iterable_to_array_limit13(arr, i) || _unsupported_iterable_to_array17(arr, i) || _non_iterable_rest14();
}
function _to_consumable_array12(arr) {
  return _array_without_holes12(arr) || _iterable_to_array12(arr) || _unsupported_iterable_to_array17(arr) || _non_iterable_spread12();
}
function _unsupported_iterable_to_array17(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array17(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array17(o, minLen);
  }
}
function _ts_generator10(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var defaultPlatform3 = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux", _Symbol_iterator5 = Symbol.iterator, _Symbol_asyncIterator4 = Symbol.asyncIterator, Glob = /* @__PURE__ */ function() {
  "use strict";
  function Glob2(pattern, opts) {
    var _this = this;
    if (_class_call_check14(this, Glob2), _define_property17(this, "absolute", void 0), _define_property17(this, "cwd", void 0), _define_property17(this, "root", void 0), _define_property17(this, "dot", void 0), _define_property17(this, "dotRelative", void 0), _define_property17(this, "follow", void 0), _define_property17(this, "ignore", void 0), _define_property17(this, "magicalBraces", void 0), _define_property17(this, "mark", void 0), _define_property17(this, "matchBase", void 0), _define_property17(this, "maxDepth", void 0), _define_property17(this, "nobrace", void 0), _define_property17(this, "nocase", void 0), _define_property17(this, "nodir", void 0), _define_property17(this, "noext", void 0), _define_property17(this, "noglobstar", void 0), _define_property17(this, "pattern", void 0), _define_property17(this, "platform", void 0), _define_property17(this, "realpath", void 0), _define_property17(this, "scurry", void 0), _define_property17(this, "stat", void 0), _define_property17(this, "signal", void 0), _define_property17(this, "windowsPathsNoEscape", void 0), _define_property17(this, "withFileTypes", void 0), _define_property17(this, "opts", void 0), _define_property17(this, "patterns", void 0), !opts)
      throw new TypeError("glob options required");
    if (this.withFileTypes = !!opts.withFileTypes, this.signal = opts.signal, this.follow = !!opts.follow, this.dot = !!opts.dot, this.dotRelative = !!opts.dotRelative, this.nodir = !!opts.nodir, this.mark = !!opts.mark, opts.cwd ? (_instanceof11(opts.cwd, URL) || opts.cwd.startsWith("file://")) && (opts.cwd = (0, import_url2.fileURLToPath)(opts.cwd)) : this.cwd = "", this.cwd = opts.cwd || "", this.root = opts.root, this.magicalBraces = !!opts.magicalBraces, this.nobrace = !!opts.nobrace, this.noext = !!opts.noext, this.realpath = !!opts.realpath, this.absolute = opts.absolute, this.noglobstar = !!opts.noglobstar, this.matchBase = !!opts.matchBase, this.maxDepth = typeof opts.maxDepth == "number" ? opts.maxDepth : 1 / 0, this.stat = !!opts.stat, this.ignore = opts.ignore, this.withFileTypes && this.absolute !== void 0)
      throw new Error("cannot set absolute and withFileTypes:true");
    if (typeof pattern == "string" && (pattern = [
      pattern
    ]), this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === !1, this.windowsPathsNoEscape && (pattern = pattern.map(function(p) {
      return p.replace(/\\/g, "/");
    })), this.matchBase) {
      if (opts.noglobstar)
        throw new TypeError("base matching requires globstar");
      pattern = pattern.map(function(p) {
        return p.includes("/") ? p : "./**/".concat(p);
      });
    }
    if (this.pattern = pattern, this.platform = opts.platform || defaultPlatform3, this.opts = _object_spread_props6(_object_spread9({}, opts), {
      platform: this.platform
    }), opts.scurry) {
      if (this.scurry = opts.scurry, opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase)
        throw new Error("nocase option contradicts provided scurry option");
    } else {
      var Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    var nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32", mmo = _object_spread_props6(_object_spread9(
      {},
      // default nocase based on platform
      opts
    ), {
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: !0,
      noext: this.noext,
      nonegate: !0,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    }), mms = this.pattern.map(function(p) {
      return new Minimatch(p, mmo);
    }), _mms_reduce = _sliced_to_array13(mms.reduce(function(set3, m) {
      var _set_, _set_1;
      return (_set_ = set3[0]).push.apply(_set_, _to_consumable_array12(m.set)), (_set_1 = set3[1]).push.apply(_set_1, _to_consumable_array12(m.globParts)), set3;
    }, [
      [],
      []
    ]), 2), matchSet = _mms_reduce[0], globParts = _mms_reduce[1];
    this.patterns = matchSet.map(function(set3, i) {
      return new Pattern(set3, globParts[i], 0, _this.platform);
    });
  }
  return _create_class12(Glob2, [
    {
      key: "walk",
      value: function() {
        var _this = this;
        return _async_to_generator10(function() {
          return _ts_generator10(this, function(_state) {
            switch (_state.label) {
              case 0:
                return [
                  4,
                  new GlobWalker(_this.patterns, _this.scurry.cwd, _object_spread_props6(_object_spread9({}, _this.opts), {
                    maxDepth: _this.maxDepth !== 1 / 0 ? _this.maxDepth + _this.scurry.cwd.depth() : 1 / 0,
                    platform: _this.platform,
                    nocase: _this.nocase
                  })).walk()
                ];
              case 1:
                return [
                  2,
                  _to_consumable_array12.apply(void 0, [
                    _state.sent()
                  ])
                ];
            }
          });
        })();
      }
    },
    {
      key: "walkSync",
      value: function() {
        return _to_consumable_array12(new GlobWalker(this.patterns, this.scurry.cwd, _object_spread_props6(_object_spread9({}, this.opts), {
          maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
          platform: this.platform,
          nocase: this.nocase
        })).walkSync());
      }
    },
    {
      key: "stream",
      value: function() {
        return new GlobStream(this.patterns, this.scurry.cwd, _object_spread_props6(_object_spread9({}, this.opts), {
          maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
          platform: this.platform,
          nocase: this.nocase
        })).stream();
      }
    },
    {
      key: "streamSync",
      value: function() {
        return new GlobStream(this.patterns, this.scurry.cwd, _object_spread_props6(_object_spread9({}, this.opts), {
          maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
          platform: this.platform,
          nocase: this.nocase
        })).streamSync();
      }
    },
    {
      /**
      * Default sync iteration function. Returns a Generator that
      * iterates over the results.
      */
      key: "iterateSync",
      value: function() {
        return this.streamSync()[Symbol.iterator]();
      }
    },
    {
      key: _Symbol_iterator5,
      value: function() {
        return this.iterateSync();
      }
    },
    {
      /**
      * Default async iteration function. Returns an AsyncGenerator that
      * iterates over the results.
      */
      key: "iterate",
      value: function() {
        return this.stream()[Symbol.asyncIterator]();
      }
    },
    {
      key: _Symbol_asyncIterator4,
      value: function() {
        return this.iterate();
      }
    }
  ]), Glob2;
}();

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/has-magic.js
var hasMagic = function(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Array.isArray(pattern) || (pattern = [
    pattern
  ]);
  var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _iterator = pattern[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
      var p = _step.value;
      if (new Minimatch(p, options).hasMagic())
        return !0;
    }
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
  return !1;
};

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/index.js
function asyncGeneratorStep11(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator11(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep11(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep11(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator11(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
function globStreamSync(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Glob(pattern, options).stream();
}
function globSync(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Glob(pattern, options).walkSync();
}
function glob_(pattern) {
  return _glob_.apply(this, arguments);
}
function _glob_() {
  return _glob_ = _async_to_generator11(function(pattern) {
    var options, _arguments = arguments;
    return _ts_generator11(this, function(_state) {
      return options = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, [
        2,
        new Glob(pattern, options).walk()
      ];
    });
  }), _glob_.apply(this, arguments);
}
function globIterateSync(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Glob(pattern, options).iterate();
}
var streamSync = globStreamSync, stream = Object.assign(globStream, {
  sync: globStreamSync
}), iterateSync = globIterateSync, iterate = Object.assign(globIterate, {
  sync: globIterateSync
}), sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
}), glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape
});
glob.glob = glob;

// ../../node_modules/rimraf/dist/mjs/fs.js
var import_fs3 = __toESM(require("fs"), 1), import_fs4 = require("fs"), import_fs5 = require("fs");
function _array_like_to_array18(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes13(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array18(arr);
}
function _iterable_to_array13(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _non_iterable_spread13() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array13(arr) {
  return _array_without_holes13(arr) || _iterable_to_array13(arr) || _unsupported_iterable_to_array18(arr) || _non_iterable_spread13();
}
function _unsupported_iterable_to_array18(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array18(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array18(o, minLen);
  }
}
var readdirSync2 = function(path6) {
  return (0, import_fs5.readdirSync)(path6, {
    withFileTypes: !0
  });
}, chmod = function(path6, mode) {
  return new Promise(function(res, rej) {
    return import_fs3.default.chmod(path6, mode, function(er) {
      for (var _len = arguments.length, d = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        d[_key - 1] = arguments[_key];
      return er ? rej(er) : res.apply(void 0, _to_consumable_array13(d));
    });
  });
}, mkdir = function(path6, options) {
  return new Promise(function(res, rej) {
    return import_fs3.default.mkdir(path6, options, function(er, made) {
      return er ? rej(er) : res(made);
    });
  });
}, readdir2 = function(path6) {
  return new Promise(function(res, rej) {
    return import_fs3.default.readdir(path6, {
      withFileTypes: !0
    }, function(er, data) {
      return er ? rej(er) : res(data);
    });
  });
}, rename = function(oldPath, newPath) {
  return new Promise(function(res, rej) {
    return import_fs3.default.rename(oldPath, newPath, function(er) {
      for (var _len = arguments.length, d = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        d[_key - 1] = arguments[_key];
      return er ? rej(er) : res.apply(void 0, _to_consumable_array13(d));
    });
  });
}, rm = function(path6, options) {
  return new Promise(function(res, rej) {
    return import_fs3.default.rm(path6, options, function(er) {
      for (var _len = arguments.length, d = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        d[_key - 1] = arguments[_key];
      return er ? rej(er) : res.apply(void 0, _to_consumable_array13(d));
    });
  });
}, rmdir = function(path6) {
  return new Promise(function(res, rej) {
    return import_fs3.default.rmdir(path6, function(er) {
      for (var _len = arguments.length, d = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        d[_key - 1] = arguments[_key];
      return er ? rej(er) : res.apply(void 0, _to_consumable_array13(d));
    });
  });
}, stat = function(path6) {
  return new Promise(function(res, rej) {
    return import_fs3.default.stat(path6, function(er, data) {
      return er ? rej(er) : res(data);
    });
  });
}, lstat2 = function(path6) {
  return new Promise(function(res, rej) {
    return import_fs3.default.lstat(path6, function(er, data) {
      return er ? rej(er) : res(data);
    });
  });
}, unlink = function(path6) {
  return new Promise(function(res, rej) {
    return import_fs3.default.unlink(path6, function(er) {
      for (var _len = arguments.length, d = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        d[_key - 1] = arguments[_key];
      return er ? rej(er) : res.apply(void 0, _to_consumable_array13(d));
    });
  });
}, promises = {
  chmod,
  mkdir,
  readdir: readdir2,
  rename,
  rm,
  rmdir,
  stat,
  lstat: lstat2,
  unlink
};

// ../../node_modules/rimraf/dist/mjs/rimraf-posix.js
var import_path4 = require("path");

// ../../node_modules/rimraf/dist/mjs/readdir-or-error.js
var readdir3 = promises.readdir, readdirOrError = function(path6) {
  return readdir3(path6).catch(function(er) {
    return er;
  });
}, readdirOrErrorSync = function(path6) {
  try {
    return readdirSync2(path6);
  } catch (er) {
    return er;
  }
};

// ../../node_modules/rimraf/dist/mjs/ignore-enoent.js
function asyncGeneratorStep12(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator12(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep12(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep12(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator12(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var ignoreENOENT = function() {
  var _ref = _async_to_generator12(function(p) {
    return _ts_generator12(this, function(_state) {
      return [
        2,
        p.catch(function(er) {
          if (er.code !== "ENOENT")
            throw er;
        })
      ];
    });
  });
  return function(p) {
    return _ref.apply(this, arguments);
  };
}(), ignoreENOENTSync = function(fn) {
  try {
    return fn();
  } catch (er) {
    if ((er == null ? void 0 : er.code) !== "ENOENT")
      throw er;
  }
};

// ../../node_modules/rimraf/dist/mjs/rimraf-posix.js
function asyncGeneratorStep13(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator13(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep13(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep13(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator13(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var lstat3 = promises.lstat, rmdir2 = promises.rmdir, unlink2 = promises.unlink, rimrafPosix = function() {
  var _ref = _async_to_generator13(function(path6, opt) {
    var _opt_signal, _tmp, er;
    return _ts_generator13(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
            throw opt.signal.reason;
          _state.label = 1;
        case 1:
          return _state.trys.push([
            1,
            4,
            ,
            5
          ]), _tmp = [
            path6,
            opt
          ], [
            4,
            lstat3(path6)
          ];
        case 2:
          return [
            4,
            rimrafPosixDir.apply(void 0, _tmp.concat([
              _state.sent()
            ]))
          ];
        case 3:
          return [
            2,
            _state.sent()
          ];
        case 4:
          if (er = _state.sent(), (er == null ? void 0 : er.code) === "ENOENT")
            return [
              2,
              !0
            ];
          throw er;
        case 5:
          return [
            2
          ];
      }
    });
  });
  return function(path6, opt) {
    return _ref.apply(this, arguments);
  };
}(), rimrafPosixSync = function(path6, opt) {
  var _opt_signal;
  if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
    throw opt.signal.reason;
  try {
    return rimrafPosixDirSync(path6, opt, (0, import_fs4.lstatSync)(path6));
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafPosixDir = function() {
  var _ref = _async_to_generator13(function(path6, opt, ent) {
    var _opt_signal, entries, _tmp, _tmp1, removedAll, _tmp2;
    return _ts_generator13(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
            throw opt.signal.reason;
          return ent.isDirectory() ? [
            4,
            readdirOrError(path6)
          ] : [
            3,
            2
          ];
        case 1:
          return _tmp = _state.sent(), [
            3,
            3
          ];
        case 2:
          _tmp = null, _state.label = 3;
        case 3:
          if (entries = _tmp, Array.isArray(entries))
            return [
              3,
              7
            ];
          if (entries) {
            if (entries.code === "ENOENT")
              return [
                2,
                !0
              ];
            if (entries.code !== "ENOTDIR")
              throw entries;
          }
          return _tmp1 = opt.filter, _tmp1 ? [
            4,
            opt.filter(path6, ent)
          ] : [
            3,
            5
          ];
        case 4:
          _tmp1 = !_state.sent(), _state.label = 5;
        case 5:
          return _tmp1 ? [
            2,
            !1
          ] : [
            4,
            ignoreENOENT(unlink2(path6))
          ];
        case 6:
          return _state.sent(), [
            2,
            !0
          ];
        case 7:
          return [
            4,
            Promise.all(entries.map(function(ent2) {
              return rimrafPosixDir((0, import_path4.resolve)(path6, ent2.name), opt, ent2);
            }))
          ];
        case 8:
          return removedAll = _state.sent().reduce(function(a, b) {
            return a && b;
          }, !0), removedAll ? opt.preserveRoot === !1 && path6 === (0, import_path4.parse)(path6).root ? [
            2,
            !1
          ] : (_tmp2 = opt.filter, _tmp2 ? [
            4,
            opt.filter(path6, ent)
          ] : [
            3,
            10
          ]) : [
            2,
            !1
          ];
        case 9:
          _tmp2 = !_state.sent(), _state.label = 10;
        case 10:
          return _tmp2 ? [
            2,
            !1
          ] : [
            4,
            ignoreENOENT(rmdir2(path6))
          ];
        case 11:
          return _state.sent(), [
            2,
            !0
          ];
      }
    });
  });
  return function(path6, opt, ent) {
    return _ref.apply(this, arguments);
  };
}(), rimrafPosixDirSync = function(path6, opt, ent) {
  var _opt_signal;
  if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
    throw opt.signal.reason;
  var entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(function() {
      return (0, import_fs4.unlinkSync)(path6);
    }), !0);
  }
  var removedAll = !0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
      var _$ent = _step.value, p = (0, import_path4.resolve)(path6, _$ent.name);
      removedAll = rimrafPosixDirSync(p, opt, _$ent) && removedAll;
    }
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
  return opt.preserveRoot === !1 && path6 === (0, import_path4.parse)(path6).root || !removedAll || opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(function() {
    return (0, import_fs4.rmdirSync)(path6);
  }), !0);
};

// ../../node_modules/rimraf/dist/mjs/rimraf-windows.js
var import_path7 = require("path");

// ../../node_modules/rimraf/dist/mjs/fix-eperm.js
function asyncGeneratorStep14(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator14(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep14(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep14(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator14(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var chmod2 = promises.chmod, fixEPERM = function(fn) {
  return function() {
    var _ref = _async_to_generator14(function(path6) {
      var er, fer, er2, fer2;
      return _ts_generator14(this, function(_state) {
        switch (_state.label) {
          case 0:
            return _state.trys.push([
              0,
              2,
              ,
              9
            ]), [
              4,
              fn(path6)
            ];
          case 1:
            return [
              2,
              _state.sent()
            ];
          case 2:
            if (er = _state.sent(), fer = er, (fer == null ? void 0 : fer.code) === "ENOENT")
              return [
                2
              ];
            if ((fer == null ? void 0 : fer.code) !== "EPERM")
              return [
                3,
                8
              ];
            _state.label = 3;
          case 3:
            return _state.trys.push([
              3,
              5,
              ,
              6
            ]), [
              4,
              chmod2(path6, 438)
            ];
          case 4:
            return _state.sent(), [
              3,
              6
            ];
          case 5:
            if (er2 = _state.sent(), fer2 = er2, (fer2 == null ? void 0 : fer2.code) === "ENOENT")
              return [
                2
              ];
            throw er;
          case 6:
            return [
              4,
              fn(path6)
            ];
          case 7:
            return [
              2,
              _state.sent()
            ];
          case 8:
            throw er;
          case 9:
            return [
              2
            ];
        }
      });
    });
    return function(path6) {
      return _ref.apply(this, arguments);
    };
  }();
}, fixEPERMSync = function(fn) {
  return function(path6) {
    try {
      return fn(path6);
    } catch (er) {
      var fer = er;
      if ((fer == null ? void 0 : fer.code) === "ENOENT")
        return;
      if ((fer == null ? void 0 : fer.code) === "EPERM") {
        try {
          (0, import_fs4.chmodSync)(path6, 438);
        } catch (er2) {
          var fer2 = er2;
          if ((fer2 == null ? void 0 : fer2.code) === "ENOENT")
            return;
          throw er;
        }
        return fn(path6);
      }
      throw er;
    }
  };
};

// ../../node_modules/rimraf/dist/mjs/retry-busy.js
function asyncGeneratorStep15(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator15(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep15(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep15(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator15(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var MAXBACKOFF = 200, RATE = 1.2, MAXRETRIES = 10, codes = /* @__PURE__ */ new Set([
  "EMFILE",
  "ENFILE",
  "EBUSY"
]), retryBusy = function(fn) {
  var method = function() {
    var _ref = _async_to_generator15(function(path6, opt) {
      var backoff, total, mbo, rate, max, retries, er, fer, _arguments = arguments;
      return _ts_generator15(this, function(_state) {
        switch (_state.label) {
          case 0:
            backoff = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : 1, total = _arguments.length > 3 && _arguments[3] !== void 0 ? _arguments[3] : 0, mbo = opt.maxBackoff || MAXBACKOFF, rate = opt.backoff || RATE, max = opt.maxRetries || MAXRETRIES, retries = 0, _state.label = 1;
          case 1:
            _state.label = 2;
          case 2:
            return _state.trys.push([
              2,
              4,
              ,
              5
            ]), [
              4,
              fn(path6)
            ];
          case 3:
            return [
              2,
              _state.sent()
            ];
          case 4:
            if (er = _state.sent(), fer = er, (fer == null ? void 0 : fer.path) === path6 && (fer != null && fer.code) && codes.has(fer.code)) {
              if (backoff = Math.ceil(backoff * rate), total = backoff + total, total < mbo)
                return [
                  2,
                  new Promise(function(res, rej) {
                    setTimeout(function() {
                      method(path6, opt, backoff, total).then(res, rej);
                    }, backoff);
                  })
                ];
              if (retries < max)
                return retries++, [
                  3,
                  1
                ];
            }
            throw er;
          case 5:
            return [
              3,
              1
            ];
          case 6:
            return [
              2
            ];
        }
      });
    });
    return function(path6, opt) {
      return _ref.apply(this, arguments);
    };
  }();
  return method;
}, retryBusySync = function(fn) {
  var method = function(path6, opt) {
    for (var max = opt.maxRetries || MAXRETRIES, retries = 0; ; )
      try {
        return fn(path6);
      } catch (er) {
        var fer = er;
        if ((fer == null ? void 0 : fer.path) === path6 && (fer != null && fer.code) && codes.has(fer.code) && retries < max) {
          retries++;
          continue;
        }
        throw er;
      }
  };
  return method;
};

// ../../node_modules/rimraf/dist/mjs/rimraf-move-remove.js
var import_path6 = require("path");

// ../../node_modules/rimraf/dist/mjs/default-tmp.js
var import_os = require("os"), import_path5 = require("path");
function asyncGeneratorStep16(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator16(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep16(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep16(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator16(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var stat2 = promises.stat, isDirSync = function(path6) {
  try {
    return (0, import_fs4.statSync)(path6).isDirectory();
  } catch {
    return !1;
  }
}, isDir = function(path6) {
  return stat2(path6).then(function(st) {
    return st.isDirectory();
  }, function() {
    return !1;
  });
}, win32DefaultTmp = function() {
  var _ref = _async_to_generator16(function(path6) {
    var root, tmp, _parse, tmpRoot, driveTmp;
    return _ts_generator16(this, function(_state) {
      switch (_state.label) {
        case 0:
          return root = (0, import_path5.parse)(path6).root, tmp = (0, import_os.tmpdir)(), _parse = (0, import_path5.parse)(tmp), tmpRoot = _parse.root, root.toLowerCase() === tmpRoot.toLowerCase() ? [
            2,
            tmp
          ] : (driveTmp = (0, import_path5.resolve)(root, "/temp"), [
            4,
            isDir(driveTmp)
          ]);
        case 1:
          return _state.sent() ? [
            2,
            driveTmp
          ] : [
            2,
            root
          ];
      }
    });
  });
  return function(path6) {
    return _ref.apply(this, arguments);
  };
}(), win32DefaultTmpSync = function(path6) {
  var root = (0, import_path5.parse)(path6).root, tmp = (0, import_os.tmpdir)(), _parse = (0, import_path5.parse)(tmp), tmpRoot = _parse.root;
  if (root.toLowerCase() === tmpRoot.toLowerCase())
    return tmp;
  var driveTmp = (0, import_path5.resolve)(root, "/temp");
  return isDirSync(driveTmp) ? driveTmp : root;
}, posixDefaultTmp = function() {
  var _ref = _async_to_generator16(function() {
    return _ts_generator16(this, function(_state) {
      return [
        2,
        (0, import_os.tmpdir)()
      ];
    });
  });
  return function() {
    return _ref.apply(this, arguments);
  };
}(), posixDefaultTmpSync = function() {
  return (0, import_os.tmpdir)();
}, defaultTmp = platform_default === "win32" ? win32DefaultTmp : posixDefaultTmp, defaultTmpSync = platform_default === "win32" ? win32DefaultTmpSync : posixDefaultTmpSync;

// ../../node_modules/rimraf/dist/mjs/rimraf-move-remove.js
function asyncGeneratorStep17(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator17(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep17(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep17(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _define_property18(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _object_spread10(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property18(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props7(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys7(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _ts_generator17(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var lstat4 = promises.lstat, rename2 = promises.rename, unlink3 = promises.unlink, rmdir3 = promises.rmdir, chmod3 = promises.chmod, uniqueFilename = function(path6) {
  return ".".concat((0, import_path6.basename)(path6), ".").concat(Math.random());
}, unlinkFixEPERM = function() {
  var _ref = _async_to_generator17(function(path6) {
    return _ts_generator17(this, function(_state) {
      return [
        2,
        unlink3(path6).catch(function(er) {
          if (er.code === "EPERM")
            return chmod3(path6, 438).then(function() {
              return unlink3(path6);
            }, function(er2) {
              if (er2.code !== "ENOENT")
                throw er;
            });
          if (er.code === "ENOENT")
            return;
          throw er;
        })
      ];
    });
  });
  return function(path6) {
    return _ref.apply(this, arguments);
  };
}(), unlinkFixEPERMSync = function(path6) {
  try {
    (0, import_fs4.unlinkSync)(path6);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "EPERM")
      try {
        return (0, import_fs4.chmodSync)(path6, 438);
      } catch (er2) {
        if ((er2 == null ? void 0 : er2.code) === "ENOENT")
          return;
        throw er;
      }
    else if ((er == null ? void 0 : er.code) === "ENOENT")
      return;
    throw er;
  }
}, rimrafMoveRemove = function() {
  var _ref = _async_to_generator17(function(path6, opt) {
    var _opt_signal, _tmp, er;
    return _ts_generator17(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
            throw opt.signal.reason;
          _state.label = 1;
        case 1:
          return _state.trys.push([
            1,
            4,
            ,
            5
          ]), _tmp = [
            path6,
            opt
          ], [
            4,
            lstat4(path6)
          ];
        case 2:
          return [
            4,
            rimrafMoveRemoveDir.apply(void 0, _tmp.concat([
              _state.sent()
            ]))
          ];
        case 3:
          return [
            2,
            _state.sent()
          ];
        case 4:
          if (er = _state.sent(), (er == null ? void 0 : er.code) === "ENOENT")
            return [
              2,
              !0
            ];
          throw er;
        case 5:
          return [
            2
          ];
      }
    });
  });
  return function(path6, opt) {
    return _ref.apply(this, arguments);
  };
}(), rimrafMoveRemoveDir = function() {
  var _ref = _async_to_generator17(function(path6, opt, ent) {
    var _opt_signal, _tmp, _tmp1, _tmp2, entries, _tmp3, _tmp4, removedAll, _tmp5;
    return _ts_generator17(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
            throw opt.signal.reason;
          return opt.tmp ? [
            3,
            2
          ] : (_tmp = [
            path6
          ], _tmp1 = [
            _object_spread10({}, opt)
          ], _tmp2 = {}, [
            4,
            defaultTmp(path6)
          ]);
        case 1:
          return [
            2,
            rimrafMoveRemoveDir.apply(void 0, _tmp.concat([
              _object_spread_props7.apply(void 0, _tmp1.concat([
                (_tmp2.tmp = _state.sent(), _tmp2)
              ])),
              ent
            ]))
          ];
        case 2:
          if (path6 === opt.tmp && (0, import_path6.parse)(path6).root !== path6)
            throw new Error("cannot delete temp directory used for deletion");
          return ent.isDirectory() ? [
            4,
            readdirOrError(path6)
          ] : [
            3,
            4
          ];
        case 3:
          return _tmp3 = _state.sent(), [
            3,
            5
          ];
        case 4:
          _tmp3 = null, _state.label = 5;
        case 5:
          if (entries = _tmp3, Array.isArray(entries))
            return [
              3,
              9
            ];
          if (entries) {
            if (entries.code === "ENOENT")
              return [
                2,
                !0
              ];
            if (entries.code !== "ENOTDIR")
              throw entries;
          }
          return _tmp4 = opt.filter, _tmp4 ? [
            4,
            opt.filter(path6, ent)
          ] : [
            3,
            7
          ];
        case 6:
          _tmp4 = !_state.sent(), _state.label = 7;
        case 7:
          return _tmp4 ? [
            2,
            !1
          ] : [
            4,
            ignoreENOENT(tmpUnlink(path6, opt.tmp, unlinkFixEPERM))
          ];
        case 8:
          return _state.sent(), [
            2,
            !0
          ];
        case 9:
          return [
            4,
            Promise.all(entries.map(function(ent2) {
              return rimrafMoveRemoveDir((0, import_path6.resolve)(path6, ent2.name), opt, ent2);
            }))
          ];
        case 10:
          return removedAll = _state.sent().reduce(function(a, b) {
            return a && b;
          }, !0), removedAll ? opt.preserveRoot === !1 && path6 === (0, import_path6.parse)(path6).root ? [
            2,
            !1
          ] : (_tmp5 = opt.filter, _tmp5 ? [
            4,
            opt.filter(path6, ent)
          ] : [
            3,
            12
          ]) : [
            2,
            !1
          ];
        case 11:
          _tmp5 = !_state.sent(), _state.label = 12;
        case 12:
          return _tmp5 ? [
            2,
            !1
          ] : [
            4,
            ignoreENOENT(tmpUnlink(path6, opt.tmp, rmdir3))
          ];
        case 13:
          return _state.sent(), [
            2,
            !0
          ];
      }
    });
  });
  return function(path6, opt, ent) {
    return _ref.apply(this, arguments);
  };
}(), tmpUnlink = function() {
  var _ref = _async_to_generator17(function(path6, tmp, rm3) {
    var tmpFile;
    return _ts_generator17(this, function(_state) {
      switch (_state.label) {
        case 0:
          return tmpFile = (0, import_path6.resolve)(tmp, uniqueFilename(path6)), [
            4,
            rename2(path6, tmpFile)
          ];
        case 1:
          return _state.sent(), [
            4,
            rm3(tmpFile)
          ];
        case 2:
          return [
            2,
            _state.sent()
          ];
      }
    });
  });
  return function(path6, tmp, rm3) {
    return _ref.apply(this, arguments);
  };
}(), rimrafMoveRemoveSync = function(path6, opt) {
  var _opt_signal;
  if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
    throw opt.signal.reason;
  try {
    return rimrafMoveRemoveDirSync(path6, opt, (0, import_fs4.lstatSync)(path6));
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafMoveRemoveDirSync = function(path6, opt, ent) {
  var _opt_signal;
  if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
    throw opt.signal.reason;
  if (!opt.tmp)
    return rimrafMoveRemoveDirSync(path6, _object_spread_props7(_object_spread10({}, opt), {
      tmp: defaultTmpSync(path6)
    }), ent);
  var tmp = opt.tmp;
  if (path6 === opt.tmp && (0, import_path6.parse)(path6).root !== path6)
    throw new Error("cannot delete temp directory used for deletion");
  var entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(function() {
      return tmpUnlinkSync(path6, tmp, unlinkFixEPERMSync);
    }), !0);
  }
  var removedAll = !0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
      var _$ent = _step.value, p = (0, import_path6.resolve)(path6, _$ent.name);
      removedAll = rimrafMoveRemoveDirSync(p, opt, _$ent) && removedAll;
    }
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
  return !removedAll || opt.preserveRoot === !1 && path6 === (0, import_path6.parse)(path6).root || opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(function() {
    return tmpUnlinkSync(path6, tmp, import_fs4.rmdirSync);
  }), !0);
}, tmpUnlinkSync = function(path6, tmp, rmSync2) {
  var tmpFile = (0, import_path6.resolve)(tmp, uniqueFilename(path6));
  return (0, import_fs4.renameSync)(path6, tmpFile), rmSync2(tmpFile);
};

// ../../node_modules/rimraf/dist/mjs/rimraf-windows.js
function asyncGeneratorStep18(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator18(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep18(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep18(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _object_without_properties2(source, excluded) {
  if (source == null)
    return {};
  var target = _object_without_properties_loose2(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose2(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _ts_generator18(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var unlink4 = promises.unlink, rmdir4 = promises.rmdir, lstat5 = promises.lstat, rimrafWindowsFile = retryBusy(fixEPERM(unlink4)), rimrafWindowsFileSync = retryBusySync(fixEPERMSync(import_fs4.unlinkSync)), rimrafWindowsDirRetry = retryBusy(fixEPERM(rmdir4)), rimrafWindowsDirRetrySync = retryBusySync(fixEPERMSync(import_fs4.rmdirSync)), rimrafWindowsDirMoveRemoveFallback = function() {
  var _ref = _async_to_generator18(function(path6, opt) {
    var _opt_signal, filter2, options, er;
    return _ts_generator18(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
            throw opt.signal.reason;
          filter2 = opt.filter, options = _object_without_properties2(opt, [
            "filter"
          ]), _state.label = 1;
        case 1:
          return _state.trys.push([
            1,
            3,
            ,
            6
          ]), [
            4,
            rimrafWindowsDirRetry(path6, options)
          ];
        case 2:
          return [
            2,
            _state.sent()
          ];
        case 3:
          return er = _state.sent(), (er == null ? void 0 : er.code) !== "ENOTEMPTY" ? [
            3,
            5
          ] : [
            4,
            rimrafMoveRemove(path6, options)
          ];
        case 4:
          return [
            2,
            _state.sent()
          ];
        case 5:
          throw er;
        case 6:
          return [
            2
          ];
      }
    });
  });
  return function(path6, opt) {
    return _ref.apply(this, arguments);
  };
}(), rimrafWindowsDirMoveRemoveFallbackSync = function(path6, opt) {
  var _opt_signal;
  if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
    throw opt.signal.reason;
  var filter2 = opt.filter, options = _object_without_properties2(opt, [
    "filter"
  ]);
  try {
    return rimrafWindowsDirRetrySync(path6, options);
  } catch (er) {
    var fer = er;
    if ((fer == null ? void 0 : fer.code) === "ENOTEMPTY")
      return rimrafMoveRemoveSync(path6, options);
    throw er;
  }
}, START = Symbol("start"), CHILD = Symbol("child"), FINISH = Symbol("finish"), rimrafWindows = function() {
  var _ref = _async_to_generator18(function(path6, opt) {
    var _opt_signal, _tmp, er;
    return _ts_generator18(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
            throw opt.signal.reason;
          _state.label = 1;
        case 1:
          return _state.trys.push([
            1,
            4,
            ,
            5
          ]), _tmp = [
            path6,
            opt
          ], [
            4,
            lstat5(path6)
          ];
        case 2:
          return [
            4,
            rimrafWindowsDir.apply(void 0, _tmp.concat([
              _state.sent(),
              START
            ]))
          ];
        case 3:
          return [
            2,
            _state.sent()
          ];
        case 4:
          if (er = _state.sent(), (er == null ? void 0 : er.code) === "ENOENT")
            return [
              2,
              !0
            ];
          throw er;
        case 5:
          return [
            2
          ];
      }
    });
  });
  return function(path6, opt) {
    return _ref.apply(this, arguments);
  };
}(), rimrafWindowsSync = function(path6, opt) {
  var _opt_signal;
  if (!(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
    throw opt.signal.reason;
  try {
    return rimrafWindowsDirSync(path6, opt, (0, import_fs4.lstatSync)(path6), START);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafWindowsDir = function() {
  var _ref = _async_to_generator18(function(path6, opt, ent) {
    var state, _opt_signal, entries, _tmp, _tmp1, s, removedAll, _tmp2, _arguments = arguments;
    return _ts_generator18(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (state = _arguments.length > 3 && _arguments[3] !== void 0 ? _arguments[3] : START, !(opt == null || (_opt_signal = opt.signal) === null || _opt_signal === void 0) && _opt_signal.aborted)
            throw opt.signal.reason;
          return ent.isDirectory() ? [
            4,
            readdirOrError(path6)
          ] : [
            3,
            2
          ];
        case 1:
          return _tmp = _state.sent(), [
            3,
            3
          ];
        case 2:
          _tmp = null, _state.label = 3;
        case 3:
          if (entries = _tmp, Array.isArray(entries))
            return [
              3,
              7
            ];
          if (entries) {
            if (entries.code === "ENOENT")
              return [
                2,
                !0
              ];
            if (entries.code !== "ENOTDIR")
              throw entries;
          }
          return _tmp1 = opt.filter, _tmp1 ? [
            4,
            opt.filter(path6, ent)
          ] : [
            3,
            5
          ];
        case 4:
          _tmp1 = !_state.sent(), _state.label = 5;
        case 5:
          return _tmp1 ? [
            2,
            !1
          ] : [
            4,
            ignoreENOENT(rimrafWindowsFile(path6, opt))
          ];
        case 6:
          return _state.sent(), [
            2,
            !0
          ];
        case 7:
          return s = state === START ? CHILD : state, [
            4,
            Promise.all(entries.map(function(ent2) {
              return rimrafWindowsDir((0, import_path7.resolve)(path6, ent2.name), opt, ent2, s);
            }))
          ];
        case 8:
          return removedAll = _state.sent().reduce(function(a, b) {
            return a && b;
          }, !0), state !== START ? [
            3,
            9
          ] : [
            2,
            rimrafWindowsDir(path6, opt, ent, FINISH)
          ];
        case 9:
          return state !== FINISH ? [
            3,
            13
          ] : opt.preserveRoot === !1 && path6 === (0, import_path7.parse)(path6).root ? [
            2,
            !1
          ] : removedAll ? (_tmp2 = opt.filter, _tmp2 ? [
            4,
            opt.filter(path6, ent)
          ] : [
            3,
            11
          ]) : [
            2,
            !1
          ];
        case 10:
          _tmp2 = !_state.sent(), _state.label = 11;
        case 11:
          return _tmp2 ? [
            2,
            !1
          ] : [
            4,
            ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path6, opt))
          ];
        case 12:
          _state.sent(), _state.label = 13;
        case 13:
          return [
            2,
            !0
          ];
      }
    });
  });
  return function(path6, opt, ent) {
    return _ref.apply(this, arguments);
  };
}(), rimrafWindowsDirSync = function(path6, opt, ent) {
  var state = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : START, entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(function() {
      return rimrafWindowsFileSync(path6, opt);
    }), !0);
  }
  var removedAll = !0, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = !0) {
      var _$ent = _step.value, s = state === START ? CHILD : state, p = (0, import_path7.resolve)(path6, _$ent.name);
      removedAll = rimrafWindowsDirSync(p, opt, _$ent, s) && removedAll;
    }
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
  if (state === START)
    return rimrafWindowsDirSync(path6, opt, ent, FINISH);
  if (state === FINISH) {
    if (opt.preserveRoot === !1 && path6 === (0, import_path7.parse)(path6).root || !removedAll || opt.filter && !opt.filter(path6, ent))
      return !1;
    ignoreENOENTSync(function() {
      rimrafWindowsDirMoveRemoveFallbackSync(path6, opt);
    });
  }
  return !0;
};

// ../../node_modules/rimraf/dist/mjs/rimraf-manual.js
var rimrafManual = platform_default === "win32" ? rimrafWindows : rimrafPosix, rimrafManualSync = platform_default === "win32" ? rimrafWindowsSync : rimrafPosixSync;

// ../../node_modules/rimraf/dist/mjs/rimraf-native.js
function asyncGeneratorStep19(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator19(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep19(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep19(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _define_property19(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _object_spread11(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property19(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props8(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys8(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _ts_generator19(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var rm2 = promises.rm, rimrafNative = function() {
  var _ref = _async_to_generator19(function(path6, opt) {
    return _ts_generator19(this, function(_state) {
      switch (_state.label) {
        case 0:
          return [
            4,
            rm2(path6, _object_spread_props8(_object_spread11({}, opt), {
              force: !0,
              recursive: !0
            }))
          ];
        case 1:
          return _state.sent(), [
            2,
            !0
          ];
      }
    });
  });
  return function(path6, opt) {
    return _ref.apply(this, arguments);
  };
}(), rimrafNativeSync = function(path6, opt) {
  return (0, import_fs4.rmSync)(path6, _object_spread_props8(_object_spread11({}, opt), {
    force: !0,
    recursive: !0
  })), !0;
};

// ../../node_modules/rimraf/dist/mjs/use-native.js
var version = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version, versArr = version.replace(/^v/, "").split("."), hasNative = +versArr[0] > 14 || +versArr[0] == 14 && +versArr[1] >= 14, useNative = !hasNative || platform_default === "win32" ? function() {
  return !1;
} : function(opt) {
  return !(opt != null && opt.signal) && !(opt != null && opt.filter);
}, useNativeSync = !hasNative || platform_default === "win32" ? function() {
  return !1;
} : function(opt) {
  return !(opt != null && opt.signal) && !(opt != null && opt.filter);
};

// ../../node_modules/rimraf/dist/mjs/index.js
function asyncGeneratorStep20(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator20(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep20(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep20(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _type_of11(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _ts_generator20(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var typeOrUndef = function(val, t) {
  return typeof val > "u" || (typeof val > "u" ? "undefined" : _type_of11(val)) === t;
}, isRimrafOptions = function(o) {
  return !!o && typeof o == "object" && typeOrUndef(o.preserveRoot, "boolean") && typeOrUndef(o.tmp, "string") && typeOrUndef(o.maxRetries, "number") && typeOrUndef(o.retryDelay, "number") && typeOrUndef(o.backoff, "number") && typeOrUndef(o.maxBackoff, "number") && (typeOrUndef(o.glob, "boolean") || o.glob && typeof o.glob == "object") && typeOrUndef(o.filter, "function");
}, assertRimrafOptions = function(o) {
  if (!isRimrafOptions(o))
    throw new Error("invalid rimraf options");
}, wrap = function(fn) {
  return function() {
    var _ref = _async_to_generator20(function(path6, opt) {
      var options;
      return _ts_generator20(this, function(_state) {
        switch (_state.label) {
          case 0:
            return options = optArg(opt), options.glob ? [
              4,
              glob(path6, options.glob)
            ] : [
              3,
              2
            ];
          case 1:
            path6 = _state.sent(), _state.label = 2;
          case 2:
            return Array.isArray(path6) ? [
              4,
              Promise.all(path6.map(function(p) {
                return fn(path_arg_default(p, options), options);
              }))
            ] : [
              3,
              4
            ];
          case 3:
            return [
              2,
              !!_state.sent().reduce(function(a, b) {
                return a && b;
              }, !0)
            ];
          case 4:
            return [
              4,
              fn(path_arg_default(path6, options), options)
            ];
          case 5:
            return [
              2,
              !!_state.sent()
            ];
          case 6:
            return [
              2
            ];
        }
      });
    });
    return function(path6, opt) {
      return _ref.apply(this, arguments);
    };
  }();
}, wrapSync = function(fn) {
  return function(path6, opt) {
    var options = optArgSync(opt);
    return options.glob && (path6 = globSync(path6, options.glob)), Array.isArray(path6) ? !!path6.map(function(p) {
      return fn(path_arg_default(p, options), options);
    }).reduce(function(a, b) {
      return a && b;
    }, !0) : !!fn(path_arg_default(path6, options), options);
  };
}, nativeSync = wrapSync(rimrafNativeSync), native = Object.assign(wrap(rimrafNative), {
  sync: nativeSync
}), manualSync = wrapSync(rimrafManualSync), manual = Object.assign(wrap(rimrafManual), {
  sync: manualSync
}), windowsSync = wrapSync(rimrafWindowsSync), windows = Object.assign(wrap(rimrafWindows), {
  sync: windowsSync
}), posixSync = wrapSync(rimrafPosixSync), posix2 = Object.assign(wrap(rimrafPosix), {
  sync: posixSync
}), moveRemoveSync = wrapSync(rimrafMoveRemoveSync), moveRemove = Object.assign(wrap(rimrafMoveRemove), {
  sync: moveRemoveSync
}), rimrafSync = wrapSync(function(path6, opt) {
  return useNativeSync(opt) ? rimrafNativeSync(path6, opt) : rimrafManualSync(path6, opt);
});
var rimraf_ = wrap(function(path6, opt) {
  return useNative(opt) ? rimrafNative(path6, opt) : rimrafManual(path6, opt);
}), rimraf = Object.assign(rimraf_, {
  rimraf: rimraf_,
  sync: rimrafSync,
  rimrafSync,
  manual,
  manualSync,
  native,
  nativeSync,
  posix: posix2,
  posixSync,
  windows,
  windowsSync,
  moveRemove,
  moveRemoveSync
});
rimraf.rimraf = rimraf;

// src/helpers/cloneStarter.ts
function _array_like_to_array19(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes14(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array19(arr);
}
function asyncGeneratorStep21(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator21(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep21(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep21(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _define_property20(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _instanceof12(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array14(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _non_iterable_spread14() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread12(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys9 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys9 = ownKeys9.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys9.forEach(function(key) {
      _define_property20(target, key, source[key]);
    });
  }
  return target;
}
function _tagged_template_literal(strings, raw) {
  return raw || (raw = strings.slice(0)), Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
function _to_consumable_array14(arr) {
  return _array_without_holes14(arr) || _iterable_to_array14(arr) || _unsupported_iterable_to_array19(arr) || _non_iterable_spread14();
}
function _unsupported_iterable_to_array19(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array19(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array19(o, minLen);
  }
}
function _ts_generator21(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
function _templateObject() {
  var data = _tagged_template_literal([
    "git switch -c ",
    ""
  ]);
  return _templateObject = function() {
    return data;
  }, data;
}
var open = require_opener(), exec = function(cmd, options) {
  return (0, import_child_process.execSync)(cmd, _object_spread12({
    stdio: process.env.DEBUG ? "inherit" : "ignore"
  }, options));
}, home = (0, import_os2.homedir)(), tamaguiDir = (0, import_path8.join)(home, ".tamagui"), targetGitDir = "", cloneStarter = function() {
  var _ref = _async_to_generator21(function(template, resolvedProjectPath, projectName) {
    var starterDir;
    return _ts_generator21(this, function(_state) {
      switch (_state.label) {
        case 0:
          return targetGitDir = IS_TEST ? (0, import_path8.join)(tamaguiDir, "tamagui-test", template.repo.url.split("/").at(-1)) : (0, import_path8.join)(tamaguiDir, "tamagui", template.repo.url.split("/").at(-1)), console.info(), [
            4,
            setupTamaguiDotDir(template)
          ];
        case 1:
          return _state.sent(), starterDir = import_path8.join.apply(void 0, [
            targetGitDir
          ].concat(_to_consumable_array14(template.repo.dir))), console.info(), console.info("Copying starter from ".concat(starterDir, " into ").concat(import_chalk7.default.blueBright(projectName), "...")), console.info(), [
            4,
            (0, import_fs_extra.copy)(starterDir, resolvedProjectPath)
          ];
        case 2:
          return _state.sent(), [
            4,
            rimraf("".concat(resolvedProjectPath, "/.git"))
          ];
        case 3:
          return _state.sent(), console.info(import_chalk7.default.green("".concat(projectName, " created!"))), console.info(), [
            2
          ];
      }
    });
  });
  return function(template, resolvedProjectPath, projectName) {
    return _ref.apply(this, arguments);
  };
}();
function setupTamaguiDotDir(template) {
  return _setupTamaguiDotDir.apply(this, arguments);
}
function _setupTamaguiDotDir() {
  return _setupTamaguiDotDir = _async_to_generator21(function(template) {
    var isRetry, repoRoot2, e, branch, isInSubDir, sourceGitRepo, sourceGitRepoSshFallback, cmd, sshCmd, _error_stderr, _template_repo_dir_, cmd1, cmd2, err, _arguments = arguments;
    return _ts_generator21(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (isRetry = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : !1, repoRoot2 = (0, import_path8.join)(__dirname, "..", "..", ".."), console.info("Setting up ".concat(import_chalk7.default.blueBright(targetGitDir), "...")), IS_TEST && cd(repoRoot2), !process.env.GITHUB_HEAD_REF)
            return [
              3,
              4
            ];
          _state.label = 1;
        case 1:
          return _state.trys.push([
            1,
            3,
            ,
            4
          ]), [
            4,
            $(_templateObject(), process.env.GITHUB_HEAD_REF)
          ];
        case 2:
          return _state.sent(), [
            3,
            4
          ];
        case 3:
          return e = _state.sent(), [
            3,
            4
          ];
        case 4:
          return branch = template.repo.branch, // setup tests for CI
          IS_TEST ? (console.info("Test mode: cleaning old tamagui git dir"), [
            4,
            (0, import_fs_extra.remove)(targetGitDir)
          ]) : [
            3,
            7
          ];
        case 5:
          return _state.sent(), [
            4,
            (0, import_fs_extra.pathExists)((0, import_path8.join)(repoRoot2, ".git"))
          ];
        case 6:
          if (!_state.sent())
            throw new Error("Not in a git folder");
          _state.label = 7;
        case 7:
          return [
            4,
            (0, import_fs_extra.ensureDir)(tamaguiDir)
          ];
        case 8:
          return _state.sent(), cd(tamaguiDir), isInSubDir = template.repo.dir.length > 0, [
            4,
            (0, import_fs_extra.pathExists)(targetGitDir)
          ];
        case 9:
          if (_state.sent())
            return [
              3,
              10
            ];
          console.info("Cloning tamagui base directory"), console.info(), sourceGitRepo = template.repo.url, sourceGitRepoSshFallback = template.repo.sshFallback, cmd = "git clone --branch ".concat(branch, " ").concat(isInSubDir ? "--depth 1 --sparse --filter=blob:none " : "").concat(sourceGitRepo, ' "').concat(targetGitDir, '"');
          try {
            try {
              console.info("$ ".concat(cmd)), console.info(), exec(cmd);
            } catch (error) {
              if (cmd.includes("https://"))
                console.info("https failed - trying with ssh now..."), sshCmd = cmd.replace(sourceGitRepo, sourceGitRepoSshFallback), console.info("$ ".concat(sshCmd)), console.info(), exec(sshCmd);
              else
                throw error;
            }
          } catch (error) {
            throw _instanceof12(error, Error) && template.value === "takeout-starter" && !(error == null || (_error_stderr = error.stderr) === null || _error_stderr === void 0) && _error_stderr.includes("Repository not found") && (console.info(import_chalk7.default.yellow("You don't have access to this starter. Check \u{1F961} Tamagui Takeout (https://tamagui.dev/takeout) for more info.")), open("https://tamagui.dev/takeout"), process.exit(0)), error;
          }
          return [
            3,
            12
          ];
        case 10:
          return [
            4,
            (0, import_fs_extra.pathExists)((0, import_path8.join)(targetGitDir, ".git"))
          ];
        case 11:
          _state.sent() || (console.error("Corrupt Tamagui directory, please delete ".concat(targetGitDir, " and re-run")), process.exit(1)), _state.label = 12;
        case 12:
          isInSubDir && (cmd1 = "git sparse-checkout set ".concat((_template_repo_dir_ = template.repo.dir[0]) !== null && _template_repo_dir_ !== void 0 ? _template_repo_dir_ : "."), exec(cmd1, {
            cwd: targetGitDir
          }), console.info()), _state.label = 13;
        case 13:
          return _state.trys.push([
            13,
            14,
            ,
            17
          ]), cmd2 = "git pull --rebase --allow-unrelated-histories --depth 1 origin ".concat(branch), exec(cmd2, {
            cwd: targetGitDir
          }), console.info(), [
            3,
            17
          ];
        case 14:
          return err = _state.sent(), console.info("Error updating: ".concat(err.message, " ").concat(isRetry ? `failing.
`.concat(err.stack) : "trying from fresh.")), isRetry && (console.info("Please file an issue: https://github.com/tamagui/tamagui/issues/new?assignees=&labels=&template=bug_report.md&title="), process.exit(1)), [
            4,
            (0, import_fs_extra.remove)(targetGitDir)
          ];
        case 15:
          return _state.sent(), [
            4,
            setupTamaguiDotDir(template, !0)
          ];
        case 16:
          return _state.sent(), [
            3,
            17
          ];
        case 17:
          return [
            2
          ];
      }
    });
  }), _setupTamaguiDotDir.apply(this, arguments);
}

// src/helpers/getProjectName.ts
var import_path9 = __toESM(require("path")), import_chalk8 = __toESM(require_source()), import_prompts = __toESM(require_prompts3());

// src/helpers/validateNpmPackage.ts
var import_validate_npm_package_name = __toESM(require_validate_npm_package_name());
function _array_like_to_array20(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes15(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array20(arr);
}
function _iterable_to_array15(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _non_iterable_spread15() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array15(arr) {
  return _array_without_holes15(arr) || _iterable_to_array15(arr) || _unsupported_iterable_to_array20(arr) || _non_iterable_spread15();
}
function _unsupported_iterable_to_array20(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array20(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array20(o, minLen);
  }
}
function validateNpmName(name) {
  var nameValidation = (0, import_validate_npm_package_name.default)(name);
  return nameValidation.validForNewPackages ? {
    valid: !0
  } : {
    valid: !1,
    problems: _to_consumable_array15(nameValidation.errors || []).concat(_to_consumable_array15(nameValidation.warnings || []))
  };
}

// src/helpers/getProjectName.ts
function asyncGeneratorStep22(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator22(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep22(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep22(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator22(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var getProjectName = function() {
  var _ref = _async_to_generator22(function(projectPath2) {
    var res;
    return _ts_generator22(this, function(_state) {
      switch (_state.label) {
        case 0:
          return typeof projectPath2 == "string" && (projectPath2 = projectPath2.trim()), projectPath2 ? [
            3,
            2
          ] : [
            4,
            (0, import_prompts.default)({
              type: "text",
              name: "path",
              message: "Project name:",
              initial: "myapp",
              validate: function(name) {
                var validation = validateNpmName(import_path9.default.basename(import_path9.default.resolve(name)));
                return validation.valid ? !0 : "Invalid project name: " + validation.problems[0];
              }
            })
          ];
        case 1:
          res = _state.sent(), typeof res.path == "string" && (projectPath2 = res.path.trim()), _state.label = 2;
        case 2:
          return projectPath2 || (console.info(), console.info("Please specify the project directory:"), console.info("  ".concat(import_chalk8.default.cyan(package_default.name), " ").concat(import_chalk8.default.green("<project-directory>"))), console.info(), console.info("For example:"), console.info("  ".concat(import_chalk8.default.cyan(package_default.name), " ").concat(import_chalk8.default.green("my-tamagui-app"))), console.info(), console.info("Run ".concat(import_chalk8.default.cyan("".concat(package_default.name, " --help")), " to see all options.")), process.exit(1)), [
            2,
            projectPath2
          ];
      }
    });
  });
  return function(projectPath2) {
    return _ref.apply(this, arguments);
  };
}();

// src/helpers/getTemplateInfo.ts
var import_prompts3 = __toESM(require_prompts3());

// src/templates.ts
var import_fs14 = require("fs"), import_path11 = require("path"), import_chalk14 = __toESM(require_source());

// src/steps/simple-web.ts
var import_chalk9 = __toESM(require_source());
function asyncGeneratorStep23(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator23(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep23(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep23(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator23(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var packageManager = "yarn", useYarn = packageManager === "yarn", runCommand = function(scriptName) {
  return "".concat(packageManager, " ").concat(useYarn ? "" : "run ").concat(scriptName);
}, main = function() {
  var _ref = _async_to_generator23(function(param) {
    var isFullClone, projectName;
    return _ts_generator23(this, function(_state) {
      return isFullClone = param.isFullClone, projectName = param.projectName, isFullClone && console.info(`
  `.concat(import_chalk9.default.green.bold("Done!"), " created a new project under ./").concat(projectName, `

visit your project:
  `).concat(import_chalk9.default.green("cd"), " ").concat(projectName, `
`)), console.info(`
  To start the Next.js development server, run:
    `.concat(import_chalk9.default.green(runCommand("web")), `
`)), [
        2
      ];
    });
  });
  return function(_) {
    return _ref.apply(this, arguments);
  };
}(), simple_web_default = main;

// src/steps/expo-router.ts
var import_chalk10 = __toESM(require_source());
function asyncGeneratorStep24(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator24(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep24(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep24(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator24(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var main2 = function() {
  var _ref = _async_to_generator24(function(param) {
    var isFullClone, projectName;
    return _ts_generator24(this, function(_state) {
      return isFullClone = param.isFullClone, projectName = param.projectName, isFullClone && console.info(`
  `.concat(import_chalk10.default.green.bold("Done!"), " created a new project under ./").concat(projectName, `

visit your project:
  `).concat(import_chalk10.default.green("cd"), " ").concat(projectName, `
`)), [
        2
      ];
    });
  });
  return function(_) {
    return _ref.apply(this, arguments);
  };
}(), expo_router_default = main2;

// src/steps/starter-free.ts
var import_chalk11 = __toESM(require_source());
function asyncGeneratorStep25(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator25(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep25(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep25(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator25(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var packageManager2 = "yarn", useYarn2 = packageManager2 === "yarn", runCommand2 = function(scriptName) {
  return "".concat(packageManager2, " ").concat(useYarn2 ? "" : "run ").concat(scriptName);
}, main3 = function() {
  var _ref = _async_to_generator25(function(param) {
    var isFullClone, projectName;
    return _ts_generator25(this, function(_state) {
      return isFullClone = param.isFullClone, projectName = param.projectName, console.info("Note: you need yarn for this repo."), isFullClone && console.info("".concat(import_chalk11.default.green.bold("Done!"), " created a new project under ./").concat(projectName, `

visit your project:
  `).concat(import_chalk11.default.green("cd"), " ").concat(projectName, `
`)), console.info(`
  To start the Next.js development server, run:
    `.concat(import_chalk11.default.green(runCommand2("web")), `
    
  To start Expo Go for mobile development, run:
    `).concat(import_chalk11.default.green(runCommand2("native")), `

  You can also create Expo development builds by doing:
  
    `).concat(import_chalk11.default.green("cd apps/expo"), ` 
    then:
    `).concat(import_chalk11.default.green(runCommand2("ios")), ` 
    or...
    `).concat(import_chalk11.default.green(runCommand2("android")), `

  Be sure to replace yourprojectsname in app.json with the uid you'd like for your app.
`)), [
        2
      ];
    });
  });
  return function(_) {
    return _ref.apply(this, arguments);
  };
}(), starter_free_default = main3;

// src/steps/remix.ts
var import_chalk12 = __toESM(require_source());
function asyncGeneratorStep26(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator26(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep26(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep26(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator26(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var packageManager3 = "yarn", useYarn3 = packageManager3 === "yarn", runCommand3 = function(scriptName) {
  return "".concat(packageManager3, " ").concat(useYarn3 ? "" : "run ").concat(scriptName);
}, main4 = function() {
  var _ref = _async_to_generator26(function(param) {
    var isFullClone, projectName;
    return _ts_generator26(this, function(_state) {
      return isFullClone = param.isFullClone, projectName = param.projectName, isFullClone && console.info(`
  `.concat(import_chalk12.default.green.bold("Done!"), " created a new project under ./").concat(projectName, `

visit your project:
  `).concat(import_chalk12.default.green("cd"), " ").concat(projectName, `
`)), console.info(`
  To start the Remix development server, run:
    `.concat(import_chalk12.default.green(runCommand3("dev")), `
`)), [
        2
      ];
    });
  });
  return function(_) {
    return _ref.apply(this, arguments);
  };
}(), remix_default = main4;

// src/steps/takeout.ts
var import_child_process2 = require("child_process"), import_fs13 = require("fs"), import_promises2 = __toESM(require("fs/promises")), import_path10 = __toESM(require("path")), import_chalk13 = __toESM(require_source()), import_prompts2 = __toESM(require_prompts3());
function _array_like_to_array21(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes15(arr) {
  if (Array.isArray(arr))
    return arr;
}
function asyncGeneratorStep27(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator27(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep27(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep27(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _iterable_to_array_limit14(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest15() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array14(arr, i) {
  return _array_with_holes15(arr) || _iterable_to_array_limit14(arr, i) || _unsupported_iterable_to_array21(arr, i) || _non_iterable_rest15();
}
function _unsupported_iterable_to_array21(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array21(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array21(o, minLen);
  }
}
function _ts_generator27(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var packageManager4 = "yarn", useYarn4 = packageManager4 === "yarn", runCommand4 = function(scriptName) {
  return "".concat(packageManager4, " ").concat(useYarn4 ? "" : "run ").concat(scriptName);
}, main5 = function() {
  var _ref = _async_to_generator27(function(param) {
    var isFullClone, projectName, projectPath2, setupSupabase, startLocalSupabase, supabaseStarted, setUpSupabaseEnv, envs, newEnvContent, setupRemoteSupabase;
    return _ts_generator27(this, function(_state) {
      switch (_state.label) {
        case 0:
          return isFullClone = param.isFullClone, projectName = param.projectName, projectPath2 = param.projectPath, console.info(`
`.concat(tamaguiRainbowAsciiArt.split(`
`).map(function(line) {
            return "                ".concat(line);
          }).join(`
`), `
`).concat(takeoutAsciiArt, `

`)), console.info(), [
            4,
            (0, import_prompts2.default)({
              name: "setupSupabase",
              message: "Set up Supabase?",
              type: "confirm",
              initial: !0
            })
          ];
        case 1:
          return setupSupabase = _state.sent().setupSupabase, setupSupabase ? (console.info(), [
            4,
            (0, import_prompts2.default)({
              name: "startLocalSupabase",
              type: "confirm",
              message: "Start local Supabase instance for you? (Requires Docker)",
              initial: !0
            })
          ]) : [
            3,
            10
          ];
        case 2:
          return startLocalSupabase = _state.sent().startLocalSupabase, startLocalSupabase ? [
            4,
            runRetryableCommand("yarn supa start")
          ] : [
            3,
            6
          ];
        case 3:
          return supabaseStarted = _state.sent(), supabaseStarted ? (console.info(), [
            4,
            (0, import_prompts2.default)({
              name: "setUpSupabaseEnv",
              type: "confirm",
              message: "Do you want us to add the local env variables for you? This will create a file called .env.local.",
              initial: !0
            })
          ]) : [
            3,
            6
          ];
        case 4:
          return setUpSupabaseEnv = _state.sent().setUpSupabaseEnv, setUpSupabaseEnv ? (envs = getEnvFromSupabaseStatus((0, import_child_process2.execSync)("yarn supa status").toString()), newEnvContent = Object.entries(envs).map(function(param2) {
            var _param = _sliced_to_array14(param2, 2), key = _param[0], value = _param[1];
            return "".concat(key, "=").concat(value);
          }).join(`
`), (0, import_fs13.existsSync)(import_path10.default.join(projectPath2, ".env.local")) && (0, import_fs13.readFileSync)(import_path10.default.join(projectPath2, ".env.local")).toString() !== newEnvContent && (0, import_fs13.renameSync)(import_path10.default.join(projectPath2, ".env.local"), import_path10.default.join(projectPath2, ".env.local.old-".concat(Number(/* @__PURE__ */ new Date())))), [
            4,
            import_promises2.default.writeFile(import_path10.default.join(projectPath2, "./.env.local"), newEnvContent)
          ]) : [
            3,
            6
          ];
        case 5:
          _state.sent(), _state.label = 6;
        case 6:
          return console.info(), [
            4,
            (0, import_prompts2.default)({
              name: "setupRemoteSupabase",
              type: "confirm",
              message: "Link remote Supabase instance for you? (Create a project on https://app.supabase.com/projects first)",
              initial: !0
            })
          ];
        case 7:
          return setupRemoteSupabase = _state.sent().setupRemoteSupabase, setupRemoteSupabase ? [
            4,
            runRetryableCommand("npx supabase login")
          ] : [
            3,
            10
          ];
        case 8:
          return _state.sent(), console.info(), [
            4,
            linkSupabase()
          ];
        case 9:
          _state.sent(), _state.label = 10;
        case 10:
          return isFullClone && console.info(`
  `.concat(import_chalk13.default.green.bold("Done!"), " created a new project under ./").concat(projectName, `

visit your project:
  `).concat(import_chalk13.default.green("  cd"), " ").concat(projectName, `
  `)), console.info(`
  To start the Next.js development server, run:
    `.concat(import_chalk13.default.green(runCommand4("web")), `

  To start developing with Expo for native, run:
    `).concat(import_chalk13.default.green(runCommand4("native")), `

  To start developing for Expo dev build, run:
    `).concat(import_chalk13.default.green(runCommand4("ios")), `
    `).concat(import_chalk13.default.green(runCommand4("android")), `

  To run Supabase scripts, cd into the supabase package:
    `).concat(import_chalk13.default.green("cd supabase"), `

    `).concat(import_chalk13.default.green("yarn reset"), ` - Resets local database
    `).concat(import_chalk13.default.green("yarn generate"), ` - Generates new types

    Find info on the rest of the scripts in `).concat(import_chalk13.default.cyan("supabase/README.md"), `

    If you've purchased and gained access to font and icon packages, you can run:
    `).concat(import_chalk13.default.green("yarn tamagui add icon"), `
    `).concat(import_chalk13.default.green("yarn tamagui add font"), `
  `)), [
            2
          ];
      }
    });
  });
  return function(_) {
    return _ref.apply(this, arguments);
  };
}(), takeout_default = main5;
function runRetryableCommand(cmd) {
  return _runRetryableCommand.apply(this, arguments);
}
function _runRetryableCommand() {
  return _runRetryableCommand = _async_to_generator27(function(cmd) {
    var retriesCount, error, tryAgain, _arguments = arguments;
    return _ts_generator27(this, function(_state) {
      switch (_state.label) {
        case 0:
          retriesCount = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : 0, _state.label = 1;
        case 1:
          return _state.trys.push([
            1,
            2,
            ,
            7
          ]), (0, import_child_process2.execSync)(cmd, {
            stdio: "inherit"
          }), [
            2,
            !0
          ];
        case 2:
          return error = _state.sent(), [
            4,
            (0, import_prompts2.default)({
              name: "tryAgain",
              message: "An error occurred. Do you want to try again?",
              type: "confirm",
              initial: !0
            })
          ];
        case 3:
          return tryAgain = _state.sent().tryAgain, tryAgain ? [
            4,
            runRetryableCommand(cmd, retriesCount + 1)
          ] : [
            3,
            5
          ];
        case 4:
          return _state.sent(), [
            3,
            6
          ];
        case 5:
          return console.info(import_chalk13.default.yellow("\u26A0\uFE0F Skipping this step. You can try running this command later. The failed command was `".concat(import_chalk13.default.underline(cmd), "`."))), [
            2,
            !1
          ];
        case 6:
          return [
            3,
            7
          ];
        case 7:
          return [
            2
          ];
      }
    });
  }), _runRetryableCommand.apply(this, arguments);
}
function linkSupabase() {
  return _linkSupabase.apply(this, arguments);
}
function _linkSupabase() {
  return _linkSupabase = _async_to_generator27(function() {
    var supabaseRefId, cmd, error, tryAgain;
    return _ts_generator27(this, function(_state) {
      switch (_state.label) {
        case 0:
          return [
            4,
            (0, import_prompts2.default)({
              name: "supabaseRefId",
              type: "text",
              message: "Enter your supabase project's ID (e.g. abcdefghijklmnopqrst)",
              initial: !0
            })
          ];
        case 1:
          supabaseRefId = _state.sent().supabaseRefId, cmd = "npx supabase link --project-ref ".concat(supabaseRefId.trim()), _state.label = 2;
        case 2:
          return _state.trys.push([
            2,
            3,
            ,
            8
          ]), (0, import_child_process2.execSync)(cmd, {
            stdio: "inherit"
          }), [
            2,
            !0
          ];
        case 3:
          return error = _state.sent(), [
            4,
            (0, import_prompts2.default)({
              name: "tryAgain",
              message: "An error occurred. Do you want to try again?",
              type: "confirm",
              initial: !0
            })
          ];
        case 4:
          return tryAgain = _state.sent().tryAgain, tryAgain ? [
            4,
            linkSupabase()
          ] : [
            3,
            6
          ];
        case 5:
          return _state.sent(), [
            3,
            7
          ];
        case 6:
          return console.info(import_chalk13.default.yellow("\u26A0\uFE0F Skipping this step. You can try running this command later. The failed command was `".concat(import_chalk13.default.underline(cmd), "`."))), [
            2,
            !1
          ];
        case 7:
          return [
            3,
            8
          ];
        case 8:
          return [
            2
          ];
      }
    });
  }), _linkSupabase.apply(this, arguments);
}
function getEnvFromSupabaseStatus(status) {
  var _status_match, _status_match1, _status_match2, _status_match3, _status_match4, _status_match5;
  return {
    NEXT_PUBLIC_SUPABASE_URL: (_status_match = status.match(/API URL: (.*)/)) === null || _status_match === void 0 ? void 0 : _status_match[1],
    NEXT_PUBLIC_SUPABASE_GRAPHQL_URL: (_status_match1 = status.match(/GraphQL URL: (.*)/)) === null || _status_match1 === void 0 ? void 0 : _status_match1[1],
    SUPABASE_DB_URL: (_status_match2 = status.match(/DB URL: (.*)/)) === null || _status_match2 === void 0 ? void 0 : _status_match2[1],
    NEXT_PUBLIC_SUPABASE_ANON_KEY: (_status_match3 = status.match(/anon key: (.*)/)) === null || _status_match3 === void 0 ? void 0 : _status_match3[1],
    SUPABASE_SERVICE_ROLE: (_status_match4 = status.match(/service_role key: (.*)/)) === null || _status_match4 === void 0 ? void 0 : _status_match4[1],
    SUPABASE_JWT_SECRET: (_status_match5 = status.match(/JWT secret: (.*)/)) === null || _status_match5 === void 0 ? void 0 : _status_match5[1]
  };
}

// src/templates.ts
var repoRoot = (0, import_path11.join)(__dirname, "..", "..", ".."), starterFreeRoot = (0, import_path11.join)(__dirname, "..", "..", "..", "..", "starter-free"), starterExists = (0, import_fs14.existsSync)(starterFreeRoot), templates = [
  {
    title: "Free - Expo + Next in a production ready monorepo",
    value: "starter-free",
    type: "free",
    hidden: !1,
    packageManager: "yarn",
    repo: {
      url: IS_TEST && starterExists ? "file://".concat(starterFreeRoot) : "https://github.com/tamagui/starter-free.git",
      sshFallback: "git@github.com:tamagui/starter-free.git",
      dir: [],
      branch: "main"
    },
    extraSteps: starter_free_default
  },
  {
    title: "".concat(import_chalk14.default.bold.underline("\u{1F961} ".concat(import_chalk14.default.magenta("Take")).concat(import_chalk14.default.red("out"))), " - Supported stack with more to start: https://tamagui.dev/takeout"),
    value: "takeout-starter",
    type: "premium",
    packageManager: "yarn",
    hidden: !1,
    repo: {
      url: "https://github.com/tamagui/takeout",
      sshFallback: "git@github.com:tamagui/takeout.git",
      dir: [],
      branch: "main"
    },
    extraSteps: takeout_default
  },
  {
    title: "Expo Router (beta) - Expo Router starter with Tamagui set up",
    value: "expo-router",
    type: "included-in-monorepo",
    hidden: !1,
    repo: {
      url: IS_TEST ? "file://".concat(repoRoot) : "https://github.com/tamagui/tamagui.git",
      sshFallback: "git@github.com:tamagui/tamagui.git",
      dir: [
        "starters",
        "expo-router"
      ],
      branch: "master"
    },
    extraSteps: expo_router_default
  },
  {
    title: "Learn - Vite + Webpack, Tamagui config from scratch",
    value: "simple-web",
    type: "included-in-monorepo",
    hidden: !1,
    repo: {
      url: IS_TEST ? "file://".concat(repoRoot) : "https://github.com/tamagui/tamagui.git",
      sshFallback: "git@github.com:tamagui/tamagui.git",
      dir: [
        "starters",
        "simple-web"
      ],
      branch: "master"
    },
    extraSteps: simple_web_default
  },
  {
    title: "Remix - Remix + Vite starter with Tamagui set up",
    value: "remix",
    type: "included-in-monorepo",
    hidden: !1,
    repo: {
      url: IS_TEST ? "file://".concat(repoRoot) : "https://github.com/tamagui/tamagui.git",
      sshFallback: "git@github.com:tamagui/tamagui.git",
      dir: [
        "starters",
        "remix"
      ],
      branch: "master"
    },
    extraSteps: remix_default
  }
];

// src/helpers/getTemplateInfo.ts
function asyncGeneratorStep28(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator28(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep28(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep28(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator28(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var validTemplates = templates.map(function(param) {
  var value = param.value;
  return value;
}).join(", "), getTemplateInfo = function() {
  var _ref = _async_to_generator28(function(template) {
    var res;
    return _ts_generator28(this, function(_state) {
      switch (_state.label) {
        case 0:
          return res = getValidTemplate(template), template && !res && (console.warn("template ".concat(template, " is not valid. valid options: ").concat(validTemplates)), process.exit(1)), res ? [
            3,
            2
          ] : [
            4,
            (0, import_prompts3.default)({
              name: "template",
              type: "select",
              message: "Pick a template:",
              choices: templates.filter(function(t) {
                return !t.hidden;
              })
            })
          ];
        case 1:
          template = _state.sent().template, _state.label = 2;
        case 2:
          return res = getValidTemplate("".concat(template)), res || (console.warn("template ".concat(template, " is not valid. valid options: ").concat(validTemplates)), process.exit(1)), [
            2,
            res
          ];
      }
    });
  });
  return function(template) {
    return _ref.apply(this, arguments);
  };
}(), getValidTemplate = function(template) {
  return typeof template == "string" && templates.find(function(param) {
    var value = param.value;
    return value === template;
  });
};

// src/helpers/installDependencies.ts
var PackageManager = __toESM(require_build());
function asyncGeneratorStep29(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator29(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep29(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep29(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator29(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
function installDependencies(projectRoot, packageManager5) {
  return _installDependencies.apply(this, arguments);
}
function _installDependencies() {
  return _installDependencies = _async_to_generator29(function(projectRoot, packageManager5) {
    var options, yarn;
    return _ts_generator29(this, function(_state) {
      switch (_state.label) {
        case 0:
          return options = {
            cwd: projectRoot
          }, packageManager5 !== "yarn" ? [
            3,
            2
          ] : (yarn = new PackageManager.YarnPackageManager(options), [
            4,
            yarn.installAsync()
          ]);
        case 1:
          return _state.sent(), [
            3,
            4
          ];
        case 2:
          return [
            4,
            new PackageManager.NpmPackageManager(options).installAsync()
          ];
        case 3:
          _state.sent(), _state.label = 4;
        case 4:
          return [
            2
          ];
      }
    });
  }), _installDependencies.apply(this, arguments);
}

// src/index.ts
function asyncGeneratorStep30(gen, resolve7, reject, _next2, _throw, key, arg) {
  try {
    var info2 = gen[key](arg), value = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  info2.done ? resolve7(value) : Promise.resolve(value).then(_next2, _throw);
}
function _async_to_generator30(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve7, reject) {
      var gen = fn.apply(self, args);
      function _next2(value) {
        asyncGeneratorStep30(gen, resolve7, reject, _next2, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep30(gen, resolve7, reject, _next2, _throw, "throw", err);
      }
      _next2(void 0);
    });
  };
}
function _ts_generator30(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [
          op[0] & 2,
          t.value
        ]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {
              value: op[1],
              done: !1
            };
          case 5:
            _.label++, y = op[1], op = [
              0
            ];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [
          6,
          e
        ], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var projectPath = "";
IS_TEST && console.info("\u{1F9D0} Running create-tamagui in test mode \u{1F9D0}");
function exit() {
  process.exit(0);
}
process.on("SIGTERM", exit);
process.on("SIGINT", exit);
var program = new import_commander.default.Command(package_default.name).version(package_default.version).arguments("<project-directory>").action(function(name) {
  projectPath = name;
}).option("--info", "Just shows the setup guide for the starter.").option("--template <template>, -t <template>", "Choose between four or more starter templates.", "").allowUnknownOption().usage("".concat(import_chalk15.default.green("<project-directory>"), ` [options]

Example usage:

`).concat(import_chalk15.default.blueBright("npx ".concat(package_default.name, " next-expo")))).parse(process.argv);
process.argv.includes("--version") && (console.info(package_default.version), process.exit(0));
var info = !!program.info;
function run() {
  return _run.apply(this, arguments);
}
function _run() {
  return _run = _async_to_generator30(function() {
    var template, gitVersionString, _tmp, template1, didPurchase, resolvedProjectPath, projectName, _validateNpmName, valid, problems, e, packageManager5, _tmp1, e1;
    return _ts_generator30(this, function(_state) {
      switch (_state.label) {
        case 0:
          return info ? [
            4,
            getTemplateInfo(program.template)
          ] : [
            3,
            3
          ];
        case 1:
          return template = _state.sent(), [
            4,
            template.extraSteps({
              isFullClone: !1,
              projectName: import_path12.default.basename((0, import_process.cwd)()),
              projectPath: (0, import_process.cwd)()
            })
          ];
        case 2:
          return _state.sent(), [
            2
          ];
        case 3:
          return console.info(), console.info(import_chalk15.default.bold(' Note: You may need to run "npm create tamagui@latest" to get the latest version!')), console.info(), console.info(), console.info(tamaguiRainbowAsciiArt), console.info(import_chalk15.default.bold("Creating tamagui app...")), gitVersionString = parseFloat((0, import_child_process3.execSync)("git --version").toString().replace("git version ", "").trim()), gitVersionString < 2.27 && (console.error(`

 \u26A0\uFE0F Tamagui can't install: Git version must be >= 2.27

`), process.exit(1)), _tmp = projectPath, _tmp ? [
            3,
            5
          ] : [
            4,
            getProjectName(projectPath)
          ];
        case 4:
          _tmp = projectPath = _state.sent(), _state.label = 5;
        case 5:
          return [
            4,
            getTemplateInfo(program.template)
          ];
        case 6:
          return template1 = _state.sent(), template1.type !== "premium" ? [
            3,
            8
          ] : [
            4,
            (0, import_prompts4.default)({
              type: "confirm",
              name: "purchased",
              message: "Have you purchased Takeout on https://tamagui.dev/takeout"
            })
          ];
        case 7:
          didPurchase = _state.sent().purchased, didPurchase || ((0, import_opener.default)("https://tamagui.dev/takeout"), console.info(`
Opening Takeout website - once you purchase you can restart the create process. Thank you!
`), process.exit(0)), _state.label = 8;
        case 8:
          console.info(), resolvedProjectPath = import_path12.default.resolve(process.cwd(), projectPath), projectName = import_path12.default.basename(resolvedProjectPath), _validateNpmName = validateNpmName(projectName), valid = _validateNpmName.valid, problems = _validateNpmName.problems, valid || (console.error("Could not create a project called ".concat(import_chalk15.default.red('"'.concat(projectName, '"')), " because of npm naming restrictions:")), problems.forEach(function(p) {
            return console.error("    ".concat(import_chalk15.default.red.bold("*"), " ").concat(p));
          }), process.exit(1)), import_fs15.default.existsSync(resolvedProjectPath) && (console.info(), console.info(import_chalk15.default.red("\u{1F6A8} [tamagui] error"), "You tried to make a project called ".concat(import_chalk15.default.underline(import_chalk15.default.blueBright(projectName)), ", but a folder with that name already exists: ").concat(import_chalk15.default.blueBright(resolvedProjectPath), `

`).concat(import_chalk15.default.bold(import_chalk15.default.red("Please pick a different project name \u{1F978}")))), console.info(), console.info(), process.exit(1)), console.info(), console.info("Creating a new tamagui app ".concat(import_chalk15.default.blueBright(resolvedProjectPath), "...")), import_fs15.default.mkdirSync(resolvedProjectPath), console.info(import_chalk15.default.green("".concat(projectName, " folder created."))), _state.label = 9;
        case 9:
          return _state.trys.push([
            9,
            11,
            ,
            12
          ]), [
            4,
            cloneStarter(template1, resolvedProjectPath, projectName)
          ];
        case 10:
          return _state.sent(), cd(resolvedProjectPath), console.info(), [
            3,
            12
          ];
        case 11:
          return e = _state.sent(), console.error("[tamagui] Failed to copy example into ".concat(resolvedProjectPath, `

`), e), process.exit(1), [
            3,
            12
          ];
        case 12:
          return updatePackageJsonName(projectName, resolvedProjectPath), console.info("Installing packages. This might take a couple of minutes."), console.info(), _tmp1 = "packageManager" in template1 ? template1.packageManager : void 0, _tmp1 ? [
            3,
            14
          ] : [
            4,
            detect()
          ];
        case 13:
          _tmp1 = _state.sent(), _state.label = 14;
        case 14:
          packageManager5 = _tmp1, _state.label = 15;
        case 15:
          return _state.trys.push([
            15,
            17,
            ,
            18
          ]), console.info("installing with " + packageManager5), [
            4,
            installDependencies(resolvedProjectPath, packageManager5)
          ];
        case 16:
          return _state.sent(), [
            3,
            18
          ];
        case 17:
          return e1 = _state.sent(), console.error("[tamagui] error installing with " + packageManager5 + `
` + "".concat(e1)), process.exit(1), [
            3,
            18
          ];
        case 18:
          return [
            4,
            template1.extraSteps({
              isFullClone: !0,
              projectName,
              projectPath: resolvedProjectPath
            })
          ];
        case 19:
          return _state.sent(), console.info(), console.info(import_chalk15.default.gray(tamaguiDuckAsciiArt)), [
            2
          ];
      }
    });
  }), _run.apply(this, arguments);
}
function updatePackageJsonName(projectName, dir) {
  var packageJsonPath = import_path12.default.join(dir, "package.json");
  if ((0, import_fs_extra2.existsSync)(packageJsonPath)) {
    var content = (0, import_fs_extra2.readFileSync)(packageJsonPath).toString(), contentWithUpdatedName = content.replace(/("name": ")(.*)(",)/, "$1".concat(projectName, "$3"));
    (0, import_fs_extra2.writeFileSync)(packageJsonPath, contentWithUpdatedName);
  }
}
run();
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)
*/
//# sourceMappingURL=index.js.map
